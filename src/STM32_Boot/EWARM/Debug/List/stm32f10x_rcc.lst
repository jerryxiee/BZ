###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     22/May/2012  09:34:57 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\STM32 #
#                    F10x_StdPeriph_Driver\src\stm32f10x_rcc.c                #
#    Command line =  D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\STM32 #
#                    F10x_StdPeriph_Driver\src\stm32f10x_rcc.c -D             #
#                    STM32F10X_CL -D USE_STDPERIPH_DRIVER -lcN                #
#                    D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\EWARM #
#                    \Debug\List\ -o D:\work\行标产品\一体机\程序\STM32_Boot\ #
#                    STM32_Boot\EWARM\Debug\Obj\ --debug --endian=little      #
#                    --cpu=Cortex-M3 -e --warnings_are_errors --fpu=None      #
#                    --dlib_config "E:\sofewareinstall\IAR                    #
#                    Systems\arm\INC\c\DLib_Config_Normal.h" -I               #
#                    D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\EWARM #
#                    \..\inc\ -I D:\work\行标产品\一体机\程序\STM32_Boot\STM3 #
#                    2_Boot\EWARM\..\CMSIS\Core\CM3\ -I                       #
#                    D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\EWARM #
#                    \..\STM32F10x_StdPeriph_Driver\inc\ -I                   #
#                    D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\EWARM #
#                    \..\..\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10 #
#                    x_StdPeriph_Driver\inc\ -I D:\work\行标产品\一体机\程序\ #
#                    STM32_Boot\STM32_Boot\EWARM\..\..\STM32F10x_StdPeriph_Li #
#                    b_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\ #
#                     -I D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\E #
#                    WARM\..\..\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSI #
#                    S\CM3\CoreSupport\ -Oh --use_c++_inline                  #
#    List file    =  D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\EWARM #
#                    \Debug\List\stm32f10x_rcc.lst                            #
#    Object file  =  D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\EWARM #
#                    \Debug\Obj\stm32f10x_rcc.o                               #
#                                                                             #
#                                                                             #
###############################################################################

D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\STM32F10x_StdPeriph_Driver\src\stm32f10x_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_rcc.c
      4            * @author  MCD Application Team
      5            * @version V3.1.0
      6            * @date    06/19/2009
      7            * @brief   This file provides all the RCC firmware functions.
      8            ******************************************************************************
      9            * @copy
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2009 STMicroelectronics</center></h2>
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm32f10x_rcc.h"
     23          
     24          /** @addtogroup STM32F10x_StdPeriph_Driver
     25            * @{
     26            */
     27          
     28          /** @defgroup RCC 
     29            * @brief RCC driver modules
     30            * @{
     31            */ 
     32          
     33          /** @defgroup RCC_Private_TypesDefinitions
     34            * @{
     35            */
     36          
     37          /**
     38            * @}
     39            */
     40          
     41          /** @defgroup RCC_Private_Defines
     42            * @{
     43            */
     44          
     45          /* ------------ RCC registers bit address in the alias region ----------- */
     46          #define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
     47          
     48          /* --- CR Register ---*/
     49          
     50          /* Alias word address of HSION bit */
     51          #define CR_OFFSET                 (RCC_OFFSET + 0x00)
     52          #define HSION_BitNumber           0x00
     53          #define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
     54          
     55          /* Alias word address of PLLON bit */
     56          #define PLLON_BitNumber           0x18
     57          #define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
     58          
     59          #ifdef STM32F10X_CL
     60           /* Alias word address of PLL2ON bit */
     61           #define PLL2ON_BitNumber          0x1A
     62           #define CR_PLL2ON_BB              (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLL2ON_BitNumber * 4))
     63          
     64           /* Alias word address of PLL3ON bit */
     65           #define PLL3ON_BitNumber          0x1C
     66           #define CR_PLL3ON_BB              (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLL3ON_BitNumber * 4))
     67          #endif /* STM32F10X_CL */ 
     68          
     69          /* Alias word address of CSSON bit */
     70          #define CSSON_BitNumber           0x13
     71          #define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
     72          
     73          /* --- CFGR Register ---*/
     74          
     75          /* Alias word address of USBPRE bit */
     76          #define CFGR_OFFSET               (RCC_OFFSET + 0x04)
     77          
     78          #ifndef STM32F10X_CL
     79           #define USBPRE_BitNumber          0x16
     80           #define CFGR_USBPRE_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (USBPRE_BitNumber * 4))
     81          #else
     82           #define OTGFSPRE_BitNumber        0x16
     83           #define CFGR_OTGFSPRE_BB          (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (OTGFSPRE_BitNumber * 4))
     84          #endif /* STM32F10X_CL */ 
     85          
     86          /* --- BDCR Register ---*/
     87          
     88          /* Alias word address of RTCEN bit */
     89          #define BDCR_OFFSET               (RCC_OFFSET + 0x20)
     90          #define RTCEN_BitNumber           0x0F
     91          #define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
     92          
     93          /* Alias word address of BDRST bit */
     94          #define BDRST_BitNumber           0x10
     95          #define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
     96          
     97          /* --- CSR Register ---*/
     98          
     99          /* Alias word address of LSION bit */
    100          #define CSR_OFFSET                (RCC_OFFSET + 0x24)
    101          #define LSION_BitNumber           0x00
    102          #define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
    103          
    104          #ifdef STM32F10X_CL
    105          /* --- CFGR2 Register ---*/
    106          
    107           /* Alias word address of I2S2SRC bit */
    108           #define CFGR2_OFFSET              (RCC_OFFSET + 0x2C)
    109           #define I2S2SRC_BitNumber         0x11
    110           #define CFGR2_I2S2SRC_BB          (PERIPH_BB_BASE + (CFGR2_OFFSET * 32) + (I2S2SRC_BitNumber * 4))
    111          
    112           /* Alias word address of I2S3SRC bit */
    113           #define I2S3SRC_BitNumber         0x12
    114           #define CFGR2_I2S3SRC_BB          (PERIPH_BB_BASE + (CFGR2_OFFSET * 32) + (I2S3SRC_BitNumber * 4))
    115          #endif /* STM32F10X_CL */
    116          
    117          /* ---------------------- RCC registers bit mask ------------------------ */
    118          
    119          /* CR register bit mask */
    120          #define CR_HSEBYP_Reset           ((uint32_t)0xFFFBFFFF)
    121          #define CR_HSEBYP_Set             ((uint32_t)0x00040000)
    122          #define CR_HSEON_Reset            ((uint32_t)0xFFFEFFFF)
    123          #define CR_HSEON_Set              ((uint32_t)0x00010000)
    124          #define CR_HSITRIM_Mask           ((uint32_t)0xFFFFFF07)
    125          
    126          /* CFGR register bit mask */
    127          #ifndef STM32F10X_CL
    128           #define CFGR_PLL_Mask            ((uint32_t)0xFFC0FFFF)
    129          #else
    130           #define CFGR_PLL_Mask           ((uint32_t)0xFFC2FFFF)
    131          #endif /* STM32F10X_CL */ 
    132          
    133          #define CFGR_PLLMull_Mask         ((uint32_t)0x003C0000)
    134          #define CFGR_PLLSRC_Mask          ((uint32_t)0x00010000)
    135          #define CFGR_PLLXTPRE_Mask        ((uint32_t)0x00020000)
    136          #define CFGR_SWS_Mask             ((uint32_t)0x0000000C)
    137          #define CFGR_SW_Mask              ((uint32_t)0xFFFFFFFC)
    138          #define CFGR_HPRE_Reset_Mask      ((uint32_t)0xFFFFFF0F)
    139          #define CFGR_HPRE_Set_Mask        ((uint32_t)0x000000F0)
    140          #define CFGR_PPRE1_Reset_Mask     ((uint32_t)0xFFFFF8FF)
    141          #define CFGR_PPRE1_Set_Mask       ((uint32_t)0x00000700)
    142          #define CFGR_PPRE2_Reset_Mask     ((uint32_t)0xFFFFC7FF)
    143          #define CFGR_PPRE2_Set_Mask       ((uint32_t)0x00003800)
    144          #define CFGR_ADCPRE_Reset_Mask    ((uint32_t)0xFFFF3FFF)
    145          #define CFGR_ADCPRE_Set_Mask      ((uint32_t)0x0000C000)
    146          
    147          /* CSR register bit mask */
    148          #define CSR_RMVF_Set              ((uint32_t)0x01000000)
    149          
    150          #ifdef STM32F10X_CL
    151          /* CFGR2 register bit mask */
    152           #define CFGR2_PREDIV1SRC         ((uint32_t)0x00010000)
    153           #define CFGR2_PREDIV1            ((uint32_t)0x0000000F)
    154           #define CFGR2_PREDIV2            ((uint32_t)0x000000F0)
    155           #define CFGR2_PLL2MUL            ((uint32_t)0x00000F00)
    156           #define CFGR2_PLL3MUL            ((uint32_t)0x0000F000)
    157          #endif /* STM32F10X_CL */ 
    158          
    159          /* RCC Flag Mask */
    160          #define FLAG_Mask                 ((uint8_t)0x1F)
    161          
    162          #ifndef HSI_Value
    163          /* Typical Value of the HSI in Hz */
    164           #define HSI_Value                 ((uint32_t)8000000)
    165          #endif /* HSI_Value */
    166          
    167          /* CIR register byte 2 (Bits[15:8]) base address */
    168          #define CIR_BYTE2_ADDRESS         ((uint32_t)0x40021009)
    169          
    170          /* CIR register byte 3 (Bits[23:16]) base address */
    171          #define CIR_BYTE3_ADDRESS         ((uint32_t)0x4002100A)
    172          
    173          /* CFGR register byte 4 (Bits[31:24]) base address */
    174          #define CFGR_BYTE4_ADDRESS        ((uint32_t)0x40021007)
    175          
    176          /* BDCR register base address */
    177          #define BDCR_ADDRESS              (PERIPH_BASE + BDCR_OFFSET)
    178          
    179          #ifndef HSEStartUp_TimeOut
    180          /* Time out for HSE start up */
    181           #define HSEStartUp_TimeOut        ((uint16_t)0x0500)
    182          #endif /* HSEStartUp_TimeOut */
    183          
    184          /**
    185            * @}
    186            */ 
    187          
    188          /** @defgroup RCC_Private_Macros
    189            * @{
    190            */ 
    191          
    192          /**
    193            * @}
    194            */ 
    195          
    196          /** @defgroup RCC_Private_Variables
    197            * @{
    198            */ 
    199          
    200          static __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
    201          static __I uint8_t ADCPrescTable[4] = {2, 4, 6, 8};
    202          
    203          /**
    204            * @}
    205            */
    206          
    207          /** @defgroup RCC_Private_FunctionPrototypes
    208            * @{
    209            */
    210          
    211          /**
    212            * @}
    213            */
    214          
    215          /** @defgroup RCC_Private_Functions
    216            * @{
    217            */
    218          
    219          /**
    220            * @brief  Resets the RCC clock configuration to the default reset state.
    221            * @param  None
    222            * @retval None
    223            */
    224          void RCC_DeInit(void)
    225          {
    226            /* Set HSION bit */
    227            RCC->CR |= (uint32_t)0x00000001;
    228          
    229            /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
    230          #ifndef STM32F10X_CL
    231            RCC->CFGR &= (uint32_t)0xF8FF0000;
    232          #else
    233            RCC->CFGR &= (uint32_t)0xF0FF0000;
    234          #endif /* STM32F10X_CL */   
    235            
    236            /* Reset HSEON, CSSON and PLLON bits */
    237            RCC->CR &= (uint32_t)0xFEF6FFFF;
    238          
    239            /* Reset HSEBYP bit */
    240            RCC->CR &= (uint32_t)0xFFFBFFFF;
    241          
    242            /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
    243            RCC->CFGR &= (uint32_t)0xFF80FFFF;
    244          
    245          #ifndef STM32F10X_CL
    246            /* Disable all interrupts and clear pending bits  */
    247            RCC->CIR = 0x009F0000;
    248          #else
    249            /* Reset PLL2ON and PLL3ON bits */
    250            RCC->CR &= (uint32_t)0xEBFFFFFF;
    251          
    252            /* Disable all interrupts and clear pending bits  */
    253            RCC->CIR = 0x00FF0000;
    254          
    255            /* Reset CFGR2 register */
    256            RCC->CFGR2 = 0x00000000;
    257          #endif /* STM32F10X_CL */
    258          }
    259          
    260          /**
    261            * @brief  Configures the External High Speed oscillator (HSE).
    262            * @note   HSE can not be stopped if it is used directly or through the PLL as system clock.
    263            * @param  RCC_HSE: specifies the new state of the HSE.
    264            *   This parameter can be one of the following values:
    265            *     @arg RCC_HSE_OFF: HSE oscillator OFF
    266            *     @arg RCC_HSE_ON: HSE oscillator ON
    267            *     @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
    268            * @retval None
    269            */
    270          void RCC_HSEConfig(uint32_t RCC_HSE)
    271          {
    272            /* Check the parameters */
    273            //assert_param(IS_RCC_HSE(RCC_HSE));
    274            /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
    275            /* Reset HSEON bit */
    276            RCC->CR &= CR_HSEON_Reset;
    277            /* Reset HSEBYP bit */
    278            RCC->CR &= CR_HSEBYP_Reset;
    279            /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
    280            switch(RCC_HSE)
    281            {
    282              case RCC_HSE_ON:
    283                /* Set HSEON bit */
    284                RCC->CR |= CR_HSEON_Set;
    285                break;
    286                
    287              case RCC_HSE_Bypass:
    288                /* Set HSEBYP and HSEON bits */
    289                RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
    290                break;
    291                
    292              default:
    293                break;
    294            }
    295          }
    296          
    297          /**
    298            * @brief  Waits for HSE start-up.
    299            * @param  None
    300            * @retval An ErrorStatus enumuration value:
    301            * - SUCCESS: HSE oscillator is stable and ready to use
    302            * - ERROR: HSE oscillator not yet ready
    303            */
    304          ErrorStatus RCC_WaitForHSEStartUp(void)
    305          {
    306            __IO uint32_t StartUpCounter = 0;
    307            ErrorStatus status = ERROR;
    308            FlagStatus HSEStatus = RESET;
    309            
    310            /* Wait till HSE is ready and if Time out is reached exit */
    311            do
    312            {
    313              HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    314              StartUpCounter++;  
    315            } while((StartUpCounter != HSEStartUp_TimeOut) && (HSEStatus == RESET));
    316            
    317            if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
    318            {
    319              status = SUCCESS;
    320            }
    321            else
    322            {
    323              status = ERROR;
    324            }  
    325            return (status);
    326          }
    327          
    328          /**
    329            * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
    330            * @param  HSICalibrationValue: specifies the calibration trimming value.
    331            *   This parameter must be a number between 0 and 0x1F.
    332            * @retval None
    333            */
    334          void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
    335          {
    336            uint32_t tmpreg = 0;
    337            /* Check the parameters */
    338            //assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
    339            tmpreg = RCC->CR;
    340            /* Clear HSITRIM[4:0] bits */
    341            tmpreg &= CR_HSITRIM_Mask;
    342            /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
    343            tmpreg |= (uint32_t)HSICalibrationValue << 3;
    344            /* Store the new value */
    345            RCC->CR = tmpreg;
    346          }
    347          
    348          /**
    349            * @brief  Enables or disables the Internal High Speed oscillator (HSI).
    350            * @note   HSI can not be stopped if it is used directly or through the PLL as system clock.
    351            * @param  NewState: new state of the HSI. This parameter can be: ENABLE or DISABLE.
    352            * @retval None
    353            */
    354          void RCC_HSICmd(FunctionalState NewState)
    355          {
    356            /* Check the parameters */
    357            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    358            *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
    359          }
    360          
    361          /**
    362            * @brief  Configures the PLL clock source and multiplication factor.
    363            * @note   This function must be used only when the PLL is disabled.
    364            * @param  RCC_PLLSource: specifies the PLL entry clock source.
    365            *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
    366            *   following values:
    367            *     @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock divided by 2 selected as PLL clock entry
    368            *     @arg RCC_PLLSource_PREDIV1: PREDIV1 clock selected as PLL clock entry
    369            *   For @b other_STM32_devices, this parameter can be one of the following values:
    370            *     @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock divided by 2 selected as PLL clock entry
    371            *     @arg RCC_PLLSource_HSE_Div1: HSE oscillator clock selected as PLL clock entry
    372            *     @arg RCC_PLLSource_HSE_Div2: HSE oscillator clock divided by 2 selected as PLL clock entry 
    373            * @param  RCC_PLLMul: specifies the PLL multiplication factor.
    374            *   For @b STM32_Connectivity_line_devices, this parameter can be RCC_PLLMul_x where x:{[4,9], 6_5}
    375            *   For @b other_STM32_devices, this parameter can be RCC_PLLMul_x where x:[2,16]  
    376            * @retval None
    377            */
    378          void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
    379          {
    380            uint32_t tmpreg = 0;
    381          
    382            /* Check the parameters */
    383            //assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
    384            //assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
    385          
    386            tmpreg = RCC->CFGR;
    387            /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
    388            tmpreg &= CFGR_PLL_Mask;
    389            /* Set the PLL configuration bits */
    390            tmpreg |= RCC_PLLSource | RCC_PLLMul;
    391            /* Store the new value */
    392            RCC->CFGR = tmpreg;
    393          }
    394          
    395          /**
    396            * @brief  Enables or disables the PLL.
    397            * @note   The PLL can not be disabled if it is used as system clock.
    398            * @param  NewState: new state of the PLL. This parameter can be: ENABLE or DISABLE.
    399            * @retval None
    400            */
    401          void RCC_PLLCmd(FunctionalState NewState)
    402          {
    403            /* Check the parameters */
    404            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    405          
    406            *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
    407          }
    408          
    409          #ifdef STM32F10X_CL
    410          /**
    411            * @brief  Configures the PREDIV1 division factor.
    412            * @note 
    413            *   - This function must be used only when the PLL is disabled.
    414            *   - This function applies only to STM32 Connectivity line devices.
    415            * @param  RCC_PREDIV1_Source: specifies the PREDIV1 clock source.
    416            *   This parameter can be one of the following values:
    417            *     @arg RCC_PREDIV1_Source_HSE: HSE selected as PREDIV1 clock
    418            *     @arg RCC_PREDIV1_Source_PLL2: PLL2 selected as PREDIV1 clock
    419            * @param  RCC_PREDIV1_Div: specifies the PREDIV1 clock division factor.
    420            *   This parameter can be RCC_PREDIV1_Divx where x:[1,16]
    421            * @retval None
    422            */
    423          void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Source, uint32_t RCC_PREDIV1_Div)
    424          {
    425            uint32_t tmpreg = 0;
    426            
    427            /* Check the parameters */
    428            //assert_param(IS_RCC_PREDIV1_SOURCE(RCC_PREDIV1_Source));
    429            //assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));
    430          
    431            tmpreg = RCC->CFGR2;
    432            /* Clear PREDIV1[3:0] and PREDIV1SRC bits */
    433            tmpreg &= ~(CFGR2_PREDIV1 | CFGR2_PREDIV1SRC);
    434            /* Set the PREDIV1 clock source and division factor */
    435            tmpreg |= RCC_PREDIV1_Source | RCC_PREDIV1_Div ;
    436            /* Store the new value */
    437            RCC->CFGR2 = tmpreg;
    438          }
    439          
    440          
    441          /**
    442            * @brief  Configures the PREDIV2 division factor.
    443            * @note 
    444            *   - This function must be used only when both PLL2 and PLL3 are disabled.
    445            *   - This function applies only to STM32 Connectivity line devices.
    446            * @param  RCC_PREDIV2_Div: specifies the PREDIV2 clock division factor.
    447            *   This parameter can be RCC_PREDIV2_Divx where x:[1,16]
    448            * @retval None
    449            */
    450          void RCC_PREDIV2Config(uint32_t RCC_PREDIV2_Div)
    451          {
    452            uint32_t tmpreg = 0;
    453          
    454            /* Check the parameters */
    455            //assert_param(IS_RCC_PREDIV2(RCC_PREDIV2_Div));
    456          
    457            tmpreg = RCC->CFGR2;
    458            /* Clear PREDIV2[3:0] bits */
    459            tmpreg &= ~CFGR2_PREDIV2;
    460            /* Set the PREDIV2 division factor */
    461            tmpreg |= RCC_PREDIV2_Div;
    462            /* Store the new value */
    463            RCC->CFGR2 = tmpreg;
    464          }
    465          
    466          /**
    467            * @brief  Configures the PLL2 multiplication factor.
    468            * @note
    469            *   - This function must be used only when the PLL2 is disabled.
    470            *   - This function applies only to STM32 Connectivity line devices.
    471            * @param  RCC_PLL2Mul: specifies the PLL2 multiplication factor.
    472            *   This parameter can be RCC_PLL2Mul_x where x:{[8,14], 16, 20}
    473            * @retval None
    474            */
    475          void RCC_PLL2Config(uint32_t RCC_PLL2Mul)
    476          {
    477            uint32_t tmpreg = 0;
    478          
    479            /* Check the parameters */
    480            //assert_param(IS_RCC_PLL2_MUL(RCC_PLL2Mul));
    481          
    482            tmpreg = RCC->CFGR2;
    483            /* Clear PLL2Mul[3:0] bits */
    484            tmpreg &= ~CFGR2_PLL2MUL;
    485            /* Set the PLL2 configuration bits */
    486            tmpreg |= RCC_PLL2Mul;
    487            /* Store the new value */
    488            RCC->CFGR2 = tmpreg;
    489          }
    490          
    491          
    492          /**
    493            * @brief  Enables or disables the PLL2.
    494            * @note 
    495            *   - The PLL2 can not be disabled if it is used indirectly as system clock
    496            *     (i.e. it is used as PLL clock entry that is used as System clock).
    497            *   - This function applies only to STM32 Connectivity line devices.
    498            * @param  NewState: new state of the PLL2. This parameter can be: ENABLE or DISABLE.
    499            * @retval None
    500            */
    501          void RCC_PLL2Cmd(FunctionalState NewState)
    502          {
    503            /* Check the parameters */
    504            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    505          
    506            *(__IO uint32_t *) CR_PLL2ON_BB = (uint32_t)NewState;
    507          }
    508          
    509          
    510          /**
    511            * @brief  Configures the PLL3 multiplication factor.
    512            * @note 
    513            *   - This function must be used only when the PLL3 is disabled.
    514            *   - This function applies only to STM32 Connectivity line devices.
    515            * @param  RCC_PLL3Mul: specifies the PLL3 multiplication factor.
    516            *   This parameter can be RCC_PLL3Mul_x where x:{[8,14], 16, 20}
    517            * @retval None
    518            */
    519          void RCC_PLL3Config(uint32_t RCC_PLL3Mul)
    520          {
    521            uint32_t tmpreg = 0;
    522          
    523            /* Check the parameters */
    524            //assert_param(IS_RCC_PLL3_MUL(RCC_PLL3Mul));
    525          
    526            tmpreg = RCC->CFGR2;
    527            /* Clear PLL3Mul[3:0] bits */
    528            tmpreg &= ~CFGR2_PLL3MUL;
    529            /* Set the PLL3 configuration bits */
    530            tmpreg |= RCC_PLL3Mul;
    531            /* Store the new value */
    532            RCC->CFGR2 = tmpreg;
    533          }
    534          
    535          
    536          /**
    537            * @brief  Enables or disables the PLL3.
    538            * @note   This function applies only to STM32 Connectivity line devices.
    539            * @param  NewState: new state of the PLL3. This parameter can be: ENABLE or DISABLE.
    540            * @retval None
    541            */
    542          void RCC_PLL3Cmd(FunctionalState NewState)
    543          {
    544            /* Check the parameters */
    545          
    546            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    547            *(__IO uint32_t *) CR_PLL3ON_BB = (uint32_t)NewState;
    548          }
    549          #endif /* STM32F10X_CL */
    550          
    551          /**
    552            * @brief  Configures the system clock (SYSCLK).
    553            * @param  RCC_SYSCLKSource: specifies the clock source used as system clock.
    554            *   This parameter can be one of the following values:
    555            *     @arg RCC_SYSCLKSource_HSI: HSI selected as system clock
    556            *     @arg RCC_SYSCLKSource_HSE: HSE selected as system clock
    557            *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock
    558            * @retval None
    559            */
    560          void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
    561          {
    562            uint32_t tmpreg = 0;
    563            /* Check the parameters */
    564            //assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
    565            tmpreg = RCC->CFGR;
    566            /* Clear SW[1:0] bits */
    567            tmpreg &= CFGR_SW_Mask;
    568            /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
    569            tmpreg |= RCC_SYSCLKSource;
    570            /* Store the new value */
    571            RCC->CFGR = tmpreg;
    572          }
    573          
    574          /**
    575            * @brief  Returns the clock source used as system clock.
    576            * @param  None
    577            * @retval The clock source used as system clock. The returned value can
    578            *   be one of the following:
    579            *     - 0x00: HSI used as system clock
    580            *     - 0x04: HSE used as system clock
    581            *     - 0x08: PLL used as system clock
    582            */
    583          uint8_t RCC_GetSYSCLKSource(void)
    584          {
    585            return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
    586          }
    587          
    588          /**
    589            * @brief  Configures the AHB clock (HCLK).
    590            * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from 
    591            *   the system clock (SYSCLK).
    592            *   This parameter can be one of the following values:
    593            *     @arg RCC_SYSCLK_Div1: AHB clock = SYSCLK
    594            *     @arg RCC_SYSCLK_Div2: AHB clock = SYSCLK/2
    595            *     @arg RCC_SYSCLK_Div4: AHB clock = SYSCLK/4
    596            *     @arg RCC_SYSCLK_Div8: AHB clock = SYSCLK/8
    597            *     @arg RCC_SYSCLK_Div16: AHB clock = SYSCLK/16
    598            *     @arg RCC_SYSCLK_Div64: AHB clock = SYSCLK/64
    599            *     @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
    600            *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
    601            *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
    602            * @retval None
    603            */
    604          void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
    605          {
    606            uint32_t tmpreg = 0;
    607            /* Check the parameters */
    608            //assert_param(IS_RCC_HCLK(RCC_SYSCLK));
    609            tmpreg = RCC->CFGR;
    610            /* Clear HPRE[3:0] bits */
    611            tmpreg &= CFGR_HPRE_Reset_Mask;
    612            /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
    613            tmpreg |= RCC_SYSCLK;
    614            /* Store the new value */
    615            RCC->CFGR = tmpreg;
    616          }
    617          
    618          /**
    619            * @brief  Configures the Low Speed APB clock (PCLK1).
    620            * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from 
    621            *   the AHB clock (HCLK).
    622            *   This parameter can be one of the following values:
    623            *     @arg RCC_HCLK_Div1: APB1 clock = HCLK
    624            *     @arg RCC_HCLK_Div2: APB1 clock = HCLK/2
    625            *     @arg RCC_HCLK_Div4: APB1 clock = HCLK/4
    626            *     @arg RCC_HCLK_Div8: APB1 clock = HCLK/8
    627            *     @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
    628            * @retval None
    629            */
    630          void RCC_PCLK1Config(uint32_t RCC_HCLK)
    631          {
    632            uint32_t tmpreg = 0;
    633            /* Check the parameters */
    634            //assert_param(IS_RCC_PCLK(RCC_HCLK));
    635            tmpreg = RCC->CFGR;
    636            /* Clear PPRE1[2:0] bits */
    637            tmpreg &= CFGR_PPRE1_Reset_Mask;
    638            /* Set PPRE1[2:0] bits according to RCC_HCLK value */
    639            tmpreg |= RCC_HCLK;
    640            /* Store the new value */
    641            RCC->CFGR = tmpreg;
    642          }
    643          
    644          /**
    645            * @brief  Configures the High Speed APB clock (PCLK2).
    646            * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from 
    647            *   the AHB clock (HCLK).
    648            *   This parameter can be one of the following values:
    649            *     @arg RCC_HCLK_Div1: APB2 clock = HCLK
    650            *     @arg RCC_HCLK_Div2: APB2 clock = HCLK/2
    651            *     @arg RCC_HCLK_Div4: APB2 clock = HCLK/4
    652            *     @arg RCC_HCLK_Div8: APB2 clock = HCLK/8
    653            *     @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
    654            * @retval None
    655            */
    656          void RCC_PCLK2Config(uint32_t RCC_HCLK)
    657          {
    658            uint32_t tmpreg = 0;
    659            /* Check the parameters */
    660            //assert_param(IS_RCC_PCLK(RCC_HCLK));
    661            tmpreg = RCC->CFGR;
    662            /* Clear PPRE2[2:0] bits */
    663            tmpreg &= CFGR_PPRE2_Reset_Mask;
    664            /* Set PPRE2[2:0] bits according to RCC_HCLK value */
    665            tmpreg |= RCC_HCLK << 3;
    666            /* Store the new value */
    667            RCC->CFGR = tmpreg;
    668          }
    669          
    670          /**
    671            * @brief  Enables or disables the specified RCC interrupts.
    672            * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
    673            * 
    674            *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
    675            *   of the following values        
    676            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
    677            *     @arg RCC_IT_LSERDY: LSE ready interrupt
    678            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
    679            *     @arg RCC_IT_HSERDY: HSE ready interrupt
    680            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
    681            *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt
    682            *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt
    683            * 
    684            *   For @b other_STM32_devices, this parameter can be any combination of the 
    685            *   following values        
    686            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
    687            *     @arg RCC_IT_LSERDY: LSE ready interrupt
    688            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
    689            *     @arg RCC_IT_HSERDY: HSE ready interrupt
    690            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
    691            *       
    692            * @param  NewState: new state of the specified RCC interrupts.
    693            *   This parameter can be: ENABLE or DISABLE.
    694            * @retval None
    695            */
    696          void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
    697          {
    698            /* Check the parameters */
    699            //assert_param(IS_RCC_IT(RCC_IT));
    700            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    701            if (NewState != DISABLE)
    702            {
    703              /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
    704              *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
    705            }
    706            else
    707            {
    708              /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
    709              *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
    710            }
    711          }
    712          
    713          #ifndef STM32F10X_CL
    714          /**
    715            * @brief  Configures the USB clock (USBCLK).
    716            * @param  RCC_USBCLKSource: specifies the USB clock source. This clock is 
    717            *   derived from the PLL output.
    718            *   This parameter can be one of the following values:
    719            *     @arg RCC_USBCLKSource_PLLCLK_1Div5: PLL clock divided by 1,5 selected as USB 
    720            *                                     clock source
    721            *     @arg RCC_USBCLKSource_PLLCLK_Div1: PLL clock selected as USB clock source
    722            * @retval None
    723            */
    724          void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
    725          {
    726            /* Check the parameters */
    727            //assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
    728          
    729            *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
    730          }
    731          #else
    732          /**
    733            * @brief  Configures the USB OTG FS clock (OTGFSCLK).
    734            *   This function applies only to STM32 Connectivity line devices.
    735            * @param  RCC_OTGFSCLKSource: specifies the USB OTG FS clock source.
    736            *   This clock is derived from the PLL output.
    737            *   This parameter can be one of the following values:
    738            *     @arg  RCC_OTGFSCLKSource_PLLVCO_Div3: PLL VCO clock divided by 2 selected as USB OTG FS clock source
    739            *     @arg  RCC_OTGFSCLKSource_PLLVCO_Div2: PLL VCO clock divided by 2 selected as USB OTG FS clock source
    740            * @retval None
    741            */
    742          void RCC_OTGFSCLKConfig(uint32_t RCC_OTGFSCLKSource)
    743          {
    744            /* Check the parameters */
    745            //assert_param(IS_RCC_OTGFSCLK_SOURCE(RCC_OTGFSCLKSource));
    746          
    747            *(__IO uint32_t *) CFGR_OTGFSPRE_BB = RCC_OTGFSCLKSource;
    748          }
    749          #endif /* STM32F10X_CL */ 
    750          
    751          /**
    752            * @brief  Configures the ADC clock (ADCCLK).
    753            * @param  RCC_PCLK2: defines the ADC clock divider. This clock is derived from 
    754            *   the APB2 clock (PCLK2).
    755            *   This parameter can be one of the following values:
    756            *     @arg RCC_PCLK2_Div2: ADC clock = PCLK2/2
    757            *     @arg RCC_PCLK2_Div4: ADC clock = PCLK2/4
    758            *     @arg RCC_PCLK2_Div6: ADC clock = PCLK2/6
    759            *     @arg RCC_PCLK2_Div8: ADC clock = PCLK2/8
    760            * @retval None
    761            */
    762          void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
    763          {
    764            uint32_t tmpreg = 0;
    765            /* Check the parameters */
    766            //assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
    767            tmpreg = RCC->CFGR;
    768            /* Clear ADCPRE[1:0] bits */
    769            tmpreg &= CFGR_ADCPRE_Reset_Mask;
    770            /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
    771            tmpreg |= RCC_PCLK2;
    772            /* Store the new value */
    773            RCC->CFGR = tmpreg;
    774          }
    775          
    776          #ifdef STM32F10X_CL
    777          /**
    778            * @brief  Configures the I2S2 clock source(I2S2CLK).
    779            * @note
    780            *   - This function must be called before enabling I2S2 APB clock.
    781            *   - This function applies only to STM32 Connectivity line devices.
    782            * @param  RCC_I2S2CLKSource: specifies the I2S2 clock source.
    783            *   This parameter can be one of the following values:
    784            *     @arg RCC_I2S2CLKSource_SYSCLK: system clock selected as I2S2 clock entry
    785            *     @arg RCC_I2S2CLKSource_PLL3_VCO: PLL3 VCO clock selected as I2S2 clock entry
    786            * @retval None
    787            */
    788          void RCC_I2S2CLKConfig(uint32_t RCC_I2S2CLKSource)
    789          {
    790            /* Check the parameters */
    791            //assert_param(IS_RCC_I2S2CLK_SOURCE(RCC_I2S2CLKSource));
    792          
    793            *(__IO uint32_t *) CFGR2_I2S2SRC_BB = RCC_I2S2CLKSource;
    794          }
    795          
    796          /**
    797            * @brief  Configures the I2S3 clock source(I2S2CLK).
    798            * @note
    799            *   - This function must be called before enabling I2S3 APB clock.
    800            *   - This function applies only to STM32 Connectivity line devices.
    801            * @param  RCC_I2S3CLKSource: specifies the I2S3 clock source.
    802            *   This parameter can be one of the following values:
    803            *     @arg RCC_I2S3CLKSource_SYSCLK: system clock selected as I2S3 clock entry
    804            *     @arg RCC_I2S3CLKSource_PLL3_VCO: PLL3 VCO clock selected as I2S3 clock entry
    805            * @retval None
    806            */
    807          void RCC_I2S3CLKConfig(uint32_t RCC_I2S3CLKSource)
    808          {
    809            /* Check the parameters */
    810            //assert_param(IS_RCC_I2S3CLK_SOURCE(RCC_I2S3CLKSource));
    811          
    812            *(__IO uint32_t *) CFGR2_I2S3SRC_BB = RCC_I2S3CLKSource;
    813          }
    814          #endif /* STM32F10X_CL */
    815          
    816          /**
    817            * @brief  Configures the External Low Speed oscillator (LSE).
    818            * @param  RCC_LSE: specifies the new state of the LSE.
    819            *   This parameter can be one of the following values:
    820            *     @arg RCC_LSE_OFF: LSE oscillator OFF
    821            *     @arg RCC_LSE_ON: LSE oscillator ON
    822            *     @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
    823            * @retval None
    824            */
    825          void RCC_LSEConfig(uint8_t RCC_LSE)
    826          {
    827            /* Check the parameters */
    828            //assert_param(IS_RCC_LSE(RCC_LSE));
    829            /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
    830            /* Reset LSEON bit */
    831            *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
    832            /* Reset LSEBYP bit */
    833            *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
    834            /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
    835            switch(RCC_LSE)
    836            {
    837              case RCC_LSE_ON:
    838                /* Set LSEON bit */
    839                *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
    840                break;
    841                
    842              case RCC_LSE_Bypass:
    843                /* Set LSEBYP and LSEON bits */
    844                *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
    845                break;            
    846                
    847              default:
    848                break;      
    849            }
    850          }
    851          
    852          /**
    853            * @brief  Enables or disables the Internal Low Speed oscillator (LSI).
    854            * @note   LSI can not be disabled if the IWDG is running.
    855            * @param  NewState: new state of the LSI. This parameter can be: ENABLE or DISABLE.
    856            * @retval None
    857            */
    858          void RCC_LSICmd(FunctionalState NewState)
    859          {
    860            /* Check the parameters */
    861            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    862            *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
    863          }
    864          
    865          /**
    866            * @brief  Configures the RTC clock (RTCCLK).
    867            * @note   Once the RTC clock is selected it cant be changed unless the Backup domain is reset.
    868            * @param  RCC_RTCCLKSource: specifies the RTC clock source.
    869            *   This parameter can be one of the following values:
    870            *     @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
    871            *     @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
    872            *     @arg RCC_RTCCLKSource_HSE_Div128: HSE clock divided by 128 selected as RTC clock
    873            * @retval None
    874            */
    875          void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
    876          {
    877            /* Check the parameters */
    878            //assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
    879            /* Select the RTC clock source */
    880            RCC->BDCR |= RCC_RTCCLKSource;
    881          }
    882          
    883          /**
    884            * @brief  Enables or disables the RTC clock.
    885            * @note   This function must be used only after the RTC clock was selected using the RCC_RTCCLKConfig function.
    886            * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
    887            * @retval None
    888            */
    889          void RCC_RTCCLKCmd(FunctionalState NewState)
    890          {
    891            /* Check the parameters */
    892            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    893            *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
    894          }
    895          //**************以下屏蔽的是3.0的库函数***************
    896          /**
    897            * @brief  Returns the frequencies of different on chip clocks.
    898            * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold
    899            *   the clocks frequencies.
    900            * @retval None
    901            */
    902          void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
    903          {
    904            uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
    905          
    906          #ifdef  STM32F10X_CL
    907            uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
    908          #endif // STM32F10X_CL 
    909              
    910            // Get SYSCLK source -------------------------------------------------------
    911            tmp = RCC->CFGR & CFGR_SWS_Mask;
    912            
    913            switch (tmp)
    914            {
    915              case 0x00:  // HSI used as system clock 
    916                RCC_Clocks->SYSCLK_Frequency = HSI_Value;
    917                break;
    918              case 0x04:  // HSE used as system clock 
    919                RCC_Clocks->SYSCLK_Frequency = HSE_Value;
    920                break;
    921              case 0x08:  // PLL used as system clock 
    922          
    923                // Get PLL clock source and multiplication factor ----------------------
    924                pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
    925                pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
    926                
    927          #ifndef STM32F10X_CL      
    928                pllmull = ( pllmull >> 18) + 2;
    929                
    930                if (pllsource == 0x00)
    931                {// HSI oscillator clock divided by 2 selected as PLL clock entry 
    932                  RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
    933                }
    934                else
    935                {// HSE selected as PLL clock entry 
    936                  if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
    937                  {// HSE oscillator clock divided by 2 
    938                    RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
    939                  }
    940                  else
    941                  {
    942                    RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
    943                  }
    944                }
    945          #else
    946                pllmull = pllmull >> 18;
    947                
    948                if (pllmull != 0x0D)
    949                {
    950                   pllmull += 2;
    951                }
    952                else
    953                { // PLL multiplication factor = PLL input clock * 6.5 
    954                  pllmull = 13 / 2; 
    955                }
    956                      
    957                if (pllsource == 0x00)
    958                {// HSI oscillator clock divided by 2 selected as PLL clock entry
    959                  RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
    960                }
    961                else
    962                {// PREDIV1 selected as PLL clock entry 
    963                  
    964                  // Get PREDIV1 clock source and division factor 
    965                  prediv1source = RCC->CFGR2 & CFGR2_PREDIV1SRC;
    966                  prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
    967                  
    968                  if (prediv1source == 0)
    969                  { // HSE oscillator clock selected as PREDIV1 clock entry 
    970                    RCC_Clocks->SYSCLK_Frequency = (HSE_Value / prediv1factor) * pllmull;          
    971                  }
    972                  else
    973                  {// PLL2 clock selected as PREDIV1 clock entry 
    974                    
    975                    // Get PREDIV2 division factor and PLL2 multiplication factor 
    976                    prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
    977                    pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
    978                    RCC_Clocks->SYSCLK_Frequency = (((HSE_Value / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
    979                  }
    980                }
    981          #endif // STM32F10X_CL 
    982                break;
    983          
    984              default:
    985                RCC_Clocks->SYSCLK_Frequency = HSI_Value;
    986                break;
    987            }
    988          
    989            // Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ---------------
    990            // Get HCLK prescaler 
    991            tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
    992            tmp = tmp >> 4;
    993            presc = APBAHBPrescTable[tmp];
    994            // HCLK clock frequency 
    995            RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
    996            // Get PCLK1 prescaler 
    997            tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
    998            tmp = tmp >> 8;
    999            presc = APBAHBPrescTable[tmp];
   1000            // PCLK1 clock frequency 
   1001            RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   1002            // Get PCLK2 prescaler 
   1003            tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
   1004            tmp = tmp >> 11;
   1005            presc = APBAHBPrescTable[tmp];
   1006            // PCLK2 clock frequency 
   1007            RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   1008            // Get ADCCLK prescaler 
   1009            tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
   1010            tmp = tmp >> 14;
   1011            presc = ADCPrescTable[tmp];
   1012            // ADCCLK clock frequency 
   1013            RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
   1014          }
   1015          
   1016          //***************以下是2.0的库函数****************
   1017          /*******************************************************************************
   1018          * Function Name  : RCC_GetClocksFreq
   1019          * Description    : Returns the frequencies of different on chip clocks.
   1020          * Input          : - RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which
   1021          *                    will hold the clocks frequencies.
   1022          * Output         : None
   1023          * Return         : None
   1024          *******************************************************************************/
   1025          /*
   1026          void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
   1027          {
   1028            u32 tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
   1029          
   1030            //Get SYSCLK source -------------------------------------------------------
   1031            tmp = RCC->CFGR & CFGR_SWS_Mask;
   1032          
   1033            switch (tmp)
   1034            {
   1035              case 0x00:  // HSI used as system clock 
   1036                RCC_Clocks->SYSCLK_Frequency = HSI_Value;
   1037                break;
   1038          
   1039              case 0x04:  // HSE used as system clock 
   1040                RCC_Clocks->SYSCLK_Frequency = HSE_Value;
   1041                break;
   1042          
   1043              case 0x08:  // PLL used as system clock 
   1044                // Get PLL clock source and multiplication factor ----------------------
   1045                pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
   1046                pllmull = ( pllmull >> 18) + 2;
   1047          
   1048                pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
   1049          
   1050                if (pllsource == 0x00)
   1051                {// HSI oscillator clock divided by 2 selected as PLL clock entry 
   1052                  RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
   1053                }
   1054                else
   1055                {// HSE selected as PLL clock entry 
   1056          
   1057                  if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (u32)RESET)
   1058                  {// HSE oscillator clock divided by 2 
   1059          
   1060                    RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
   1061                  }
   1062                  else
   1063                  {
   1064                    RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
   1065                  }
   1066                }
   1067                break;
   1068          
   1069              default:
   1070                RCC_Clocks->SYSCLK_Frequency = HSI_Value;
   1071                break;
   1072            }
   1073          
   1074            // Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------
   1075            // Get HCLK prescaler 
   1076            tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
   1077            tmp = tmp >> 4;
   1078            presc = APBAHBPrescTable[tmp];
   1079          
   1080            // HCLK clock frequency 
   1081            RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
   1082          
   1083            // Get PCLK1 prescaler 
   1084            tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
   1085            tmp = tmp >> 8;
   1086            presc = APBAHBPrescTable[tmp];
   1087          
   1088            // PCLK1 clock frequency 
   1089            RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   1090          
   1091            // Get PCLK2 prescaler 
   1092            tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
   1093            tmp = tmp >> 11;
   1094            presc = APBAHBPrescTable[tmp];
   1095          
   1096            // PCLK2 clock frequency 
   1097            RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   1098          
   1099            // Get ADCCLK prescaler 
   1100            tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
   1101            tmp = tmp >> 14;
   1102            presc = ADCPrescTable[tmp];
   1103          
   1104            // ADCCLK clock frequency 
   1105            RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
   1106          }
   1107          */
   1108          /**
   1109            * @brief  Enables or disables the AHB peripheral clock.
   1110            * @param  RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.
   1111            *   
   1112            *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
   1113            *   of the following values:        
   1114            *     @arg RCC_AHBPeriph_DMA1
   1115            *     @arg RCC_AHBPeriph_DMA2
   1116            *     @arg RCC_AHBPeriph_SRAM
   1117            *     @arg RCC_AHBPeriph_FLITF
   1118            *     @arg RCC_AHBPeriph_CRC
   1119            *     @arg RCC_AHBPeriph_OTG_FS    
   1120            *     @arg RCC_AHBPeriph_ETH_MAC   
   1121            *     @arg RCC_AHBPeriph_ETH_MAC_Tx
   1122            *     @arg RCC_AHBPeriph_ETH_MAC_Rx
   1123            * 
   1124            *   For @b other_STM32_devices, this parameter can be any combination of the 
   1125            *   following values:        
   1126            *     @arg RCC_AHBPeriph_DMA1
   1127            *     @arg RCC_AHBPeriph_DMA2
   1128            *     @arg RCC_AHBPeriph_SRAM
   1129            *     @arg RCC_AHBPeriph_FLITF
   1130            *     @arg RCC_AHBPeriph_CRC
   1131            *     @arg RCC_AHBPeriph_FSMC
   1132            *     @arg RCC_AHBPeriph_SDIO
   1133            *   
   1134            * @note SRAM and FLITF clock can be disabled only during sleep mode.
   1135            * @param  NewState: new state of the specified peripheral clock.
   1136            *   This parameter can be: ENABLE or DISABLE.
   1137            * @retval None
   1138            */
   1139          void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
   1140          {
   1141            /* Check the parameters */
   1142            //assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
   1143            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1144          
   1145            if (NewState != DISABLE)
   1146            {
   1147              RCC->AHBENR |= RCC_AHBPeriph;
   1148            }
   1149            else
   1150            {
   1151              RCC->AHBENR &= ~RCC_AHBPeriph;
   1152            }
   1153          }
   1154          
   1155          /**
   1156            * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
   1157            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
   1158            *   This parameter can be any combination of the following values:
   1159            *     @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
   1160            *          RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
   1161            *          RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
   1162            *          RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
   1163            *          RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3
   1164            * @param  NewState: new state of the specified peripheral clock.
   1165            *   This parameter can be: ENABLE or DISABLE.
   1166            * @retval None
   1167            */
   1168          void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1169          {
   1170            /* Check the parameters */
   1171            //assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   1172            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1173            if (NewState != DISABLE)
   1174            {
   1175              RCC->APB2ENR |= RCC_APB2Periph;
   1176            }
   1177            else
   1178            {
   1179              RCC->APB2ENR &= ~RCC_APB2Periph;
   1180            }
   1181          }
   1182          
   1183          /**
   1184            * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
   1185            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
   1186            *   This parameter can be any combination of the following values:
   1187            *     @arg RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
   1188            *          RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
   1189            *          RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
   1190            *          RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4, 
   1191            *          RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
   1192            *          RCC_APB1Periph_USB, RCC_APB1Periph_CAN1, RCC_APB1Periph_BKP,
   1193            *          RCC_APB1Periph_PWR, RCC_APB1Periph_DAC
   1194            * @param  NewState: new state of the specified peripheral clock.
   1195            *   This parameter can be: ENABLE or DISABLE.
   1196            * @retval None
   1197            */
   1198          void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1199          {
   1200            /* Check the parameters */
   1201            //assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   1202            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1203            if (NewState != DISABLE)
   1204            {
   1205              RCC->APB1ENR |= RCC_APB1Periph;
   1206            }
   1207            else
   1208            {
   1209              RCC->APB1ENR &= ~RCC_APB1Periph;
   1210            }
   1211          }
   1212          
   1213          #ifdef STM32F10X_CL
   1214          /**
   1215            * @brief  Forces or releases AHB peripheral reset.
   1216            * @note   This function applies only to STM32 Connectivity line devices.
   1217            * @param  RCC_AHBPeriph: specifies the AHB peripheral to reset.
   1218            *   This parameter can be any combination of the following values:
   1219            *     @arg RCC_AHBPeriph_OTG_FS 
   1220            *     @arg RCC_AHBPeriph_ETH_MAC
   1221            * @param  NewState: new state of the specified peripheral reset.
   1222            *   This parameter can be: ENABLE or DISABLE.
   1223            * @retval None
   1224            */
   1225          void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
   1226          {
   1227            /* Check the parameters */
   1228            //assert_param(IS_RCC_AHB_PERIPH_RESET(RCC_AHBPeriph));
   1229            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1230          
   1231            if (NewState != DISABLE)
   1232            {
   1233              RCC->AHBRSTR |= RCC_AHBPeriph;
   1234            }
   1235            else
   1236            {
   1237              RCC->AHBRSTR &= ~RCC_AHBPeriph;
   1238            }
   1239          }
   1240          #endif /* STM32F10X_CL */ 
   1241          
   1242          /**
   1243            * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
   1244            * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
   1245            *   This parameter can be any combination of the following values:
   1246            *     @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,
   1247            *          RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,
   1248            *          RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,
   1249            *          RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,
   1250            *          RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3
   1251            * @param  NewState: new state of the specified peripheral reset.
   1252            *   This parameter can be: ENABLE or DISABLE.
   1253            * @retval None
   1254            */
   1255          void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1256          {
   1257            /* Check the parameters */
   1258            //assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   1259            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1260            if (NewState != DISABLE)
   1261            {
   1262              RCC->APB2RSTR |= RCC_APB2Periph;
   1263            }
   1264            else
   1265            {
   1266              RCC->APB2RSTR &= ~RCC_APB2Periph;
   1267            }
   1268          }
   1269          
   1270          /**
   1271            * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
   1272            * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
   1273            *   This parameter can be any combination of the following values:
   1274            *     @arg RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,
   1275            *          RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,
   1276            *          RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,
   1277            *          RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4, 
   1278            *          RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,
   1279            *          RCC_APB1Periph_USB, RCC_APB1Periph_CAN1, RCC_APB1Periph_BKP,
   1280            *          RCC_APB1Periph_PWR, RCC_APB1Periph_DAC
   1281            * @param  NewState: new state of the specified peripheral clock.
   1282            *   This parameter can be: ENABLE or DISABLE.
   1283            * @retval None
   1284            */
   1285          void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1286          {
   1287            /* Check the parameters */
   1288            //assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   1289            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1290            if (NewState != DISABLE)
   1291            {
   1292              RCC->APB1RSTR |= RCC_APB1Periph;
   1293            }
   1294            else
   1295            {
   1296              RCC->APB1RSTR &= ~RCC_APB1Periph;
   1297            }
   1298          }
   1299          
   1300          /**
   1301            * @brief  Forces or releases the Backup domain reset.
   1302            * @param  NewState: new state of the Backup domain reset.
   1303            *   This parameter can be: ENABLE or DISABLE.
   1304            * @retval None
   1305            */
   1306          void RCC_BackupResetCmd(FunctionalState NewState)
   1307          {
   1308            /* Check the parameters */
   1309            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1310            *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
   1311          }
   1312          
   1313          /**
   1314            * @brief  Enables or disables the Clock Security System.
   1315            * @param  NewState: new state of the Clock Security System..
   1316            *   This parameter can be: ENABLE or DISABLE.
   1317            * @retval None
   1318            */
   1319          void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
   1320          {
   1321            /* Check the parameters */
   1322            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1323            *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
   1324          }
   1325          
   1326          /**
   1327            * @brief  Selects the clock source to output on MCO pin.
   1328            * @param  RCC_MCO: specifies the clock source to output.
   1329            *   
   1330            *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
   1331            *   following values:       
   1332            *     @arg RCC_MCO_NoClock: No clock selected
   1333            *     @arg RCC_MCO_SYSCLK: System clock selected
   1334            *     @arg RCC_MCO_HSI: HSI oscillator clock selected
   1335            *     @arg RCC_MCO_HSE: HSE oscillator clock selected
   1336            *     @arg RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
   1337            *     @arg RCC_MCO_PLL2CLK: PLL2 clock selected                     
   1338            *     @arg RCC_MCO_PLL3CLK_Div2: PLL3 clock divided by 2 selected   
   1339            *     @arg RCC_MCO_XT1: External 3-25 MHz oscillator clock selected  
   1340            *     @arg RCC_MCO_PLL3CLK: PLL3 clock selected 
   1341            * 
   1342            *   For  @b other_STM32_devices, this parameter can be one of the following values:        
   1343            *     @arg RCC_MCO_NoClock: No clock selected
   1344            *     @arg RCC_MCO_SYSCLK: System clock selected
   1345            *     @arg RCC_MCO_HSI: HSI oscillator clock selected
   1346            *     @arg RCC_MCO_HSE: HSE oscillator clock selected
   1347            *     @arg RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
   1348            *   
   1349            * @retval None
   1350            */
   1351          void RCC_MCOConfig(uint8_t RCC_MCO)
   1352          {
   1353            /* Check the parameters */
   1354            //assert_param(IS_RCC_MCO(RCC_MCO));
   1355          
   1356            /* Perform Byte access to MCO bits to select the MCO source */
   1357            *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
   1358          }
   1359          
   1360          /**
   1361            * @brief  Checks whether the specified RCC flag is set or not.
   1362            * @param  RCC_FLAG: specifies the flag to check.
   1363            *   
   1364            *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
   1365            *   following values:
   1366            *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
   1367            *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
   1368            *     @arg RCC_FLAG_PLLRDY: PLL clock ready
   1369            *     @arg RCC_FLAG_PLL2RDY: PLL2 clock ready      
   1370            *     @arg RCC_FLAG_PLL3RDY: PLL3 clock ready                           
   1371            *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
   1372            *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
   1373            *     @arg RCC_FLAG_PINRST: Pin reset
   1374            *     @arg RCC_FLAG_PORRST: POR/PDR reset
   1375            *     @arg RCC_FLAG_SFTRST: Software reset
   1376            *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
   1377            *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset
   1378            *     @arg RCC_FLAG_LPWRRST: Low Power reset
   1379            * 
   1380            *   For @b other_STM32_devices, this parameter can be one of the following values:        
   1381            *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
   1382            *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
   1383            *     @arg RCC_FLAG_PLLRDY: PLL clock ready
   1384            *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
   1385            *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
   1386            *     @arg RCC_FLAG_PINRST: Pin reset
   1387            *     @arg RCC_FLAG_PORRST: POR/PDR reset
   1388            *     @arg RCC_FLAG_SFTRST: Software reset
   1389            *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
   1390            *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset
   1391            *     @arg RCC_FLAG_LPWRRST: Low Power reset
   1392            *   
   1393            * @retval The new state of RCC_FLAG (SET or RESET).
   1394            */
   1395          FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
   1396          {
   1397            uint32_t tmp = 0;
   1398            uint32_t statusreg = 0;
   1399            FlagStatus bitstatus = RESET;
   1400            /* Check the parameters */
   1401            //assert_param(IS_RCC_FLAG(RCC_FLAG));
   1402          
   1403            /* Get the RCC register index */
   1404            tmp = RCC_FLAG >> 5;
   1405            if (tmp == 1)               /* The flag to check is in CR register */
   1406            {
   1407              statusreg = RCC->CR;
   1408            }
   1409            else if (tmp == 2)          /* The flag to check is in BDCR register */
   1410            {
   1411              statusreg = RCC->BDCR;
   1412            }
   1413            else                       /* The flag to check is in CSR register */
   1414            {
   1415              statusreg = RCC->CSR;
   1416            }
   1417          
   1418            /* Get the flag position */
   1419            tmp = RCC_FLAG & FLAG_Mask;
   1420            if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
   1421            {
   1422              bitstatus = SET;
   1423            }
   1424            else
   1425            {
   1426              bitstatus = RESET;
   1427            }
   1428          
   1429            /* Return the flag status */
   1430            return bitstatus;
   1431          }
   1432          
   1433          /**
   1434            * @brief  Clears the RCC reset flags.
   1435            * @note   The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST, RCC_FLAG_SFTRST,
   1436            *   RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
   1437            * @param  None
   1438            * @retval None
   1439            */
   1440          void RCC_ClearFlag(void)
   1441          {
   1442            /* Set RMVF bit to clear the reset flags */
   1443            RCC->CSR |= CSR_RMVF_Set;
   1444          }
   1445          
   1446          /**
   1447            * @brief  Checks whether the specified RCC interrupt has occurred or not.
   1448            * @param  RCC_IT: specifies the RCC interrupt source to check.
   1449            *   
   1450            *   For @b STM32_Connectivity_line_devices, this parameter can be one of the
   1451            *   following values:
   1452            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
   1453            *     @arg RCC_IT_LSERDY: LSE ready interrupt
   1454            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
   1455            *     @arg RCC_IT_HSERDY: HSE ready interrupt
   1456            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
   1457            *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt 
   1458            *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt                      
   1459            *     @arg RCC_IT_CSS: Clock Security System interrupt
   1460            * 
   1461            *   For @b other_STM32_devices, this parameter can be one of the following values:        
   1462            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
   1463            *     @arg RCC_IT_LSERDY: LSE ready interrupt
   1464            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
   1465            *     @arg RCC_IT_HSERDY: HSE ready interrupt
   1466            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
   1467            *     @arg RCC_IT_CSS: Clock Security System interrupt
   1468            *   
   1469            * @retval The new state of RCC_IT (SET or RESET).
   1470            */
   1471          ITStatus RCC_GetITStatus(uint8_t RCC_IT)
   1472          {
   1473            ITStatus bitstatus = RESET;
   1474            /* Check the parameters */
   1475            //assert_param(IS_RCC_GET_IT(RCC_IT));
   1476          
   1477            /* Check the status of the specified RCC interrupt */
   1478            if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
   1479            {
   1480              bitstatus = SET;
   1481            }
   1482            else
   1483            {
   1484              bitstatus = RESET;
   1485            }
   1486          
   1487            /* Return the RCC_IT status */
   1488            return  bitstatus;
   1489          }
   1490          
   1491          /**
   1492            * @brief  Clears the RCCs interrupt pending bits.
   1493            * @param  RCC_IT: specifies the interrupt pending bit to clear.
   1494            *   
   1495            *   For @b STM32_Connectivity_line_devices, this parameter can be any combination
   1496            *   of the following values:
   1497            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
   1498            *     @arg RCC_IT_LSERDY: LSE ready interrupt
   1499            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
   1500            *     @arg RCC_IT_HSERDY: HSE ready interrupt
   1501            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
   1502            *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt 
   1503            *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt                      
   1504            *     @arg RCC_IT_CSS: Clock Security System interrupt
   1505            * 
   1506            *   For @b other_STM32_devices, this parameter can be any combination of the
   1507            *   following values:        
   1508            *     @arg RCC_IT_LSIRDY: LSI ready interrupt
   1509            *     @arg RCC_IT_LSERDY: LSE ready interrupt
   1510            *     @arg RCC_IT_HSIRDY: HSI ready interrupt
   1511            *     @arg RCC_IT_HSERDY: HSE ready interrupt
   1512            *     @arg RCC_IT_PLLRDY: PLL ready interrupt
   1513            *   
   1514            *     @arg RCC_IT_CSS: Clock Security System interrupt
   1515            * @retval None
   1516            */
   1517          void RCC_ClearITPendingBit(uint8_t RCC_IT)
   1518          {
   1519            /* Check the parameters */
   1520            //assert_param(IS_RCC_CLEAR_IT(RCC_IT));
   1521          
   1522            /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
   1523               pending bits */
   1524            *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
   1525          }
   1526          
   1527          /**
   1528            * @}
   1529            */
   1530          
   1531          /**
   1532            * @}
   1533            */
   1534          
   1535          /**
   1536            * @}
   1537            */
   1538          
   1539          /******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                      .cstack
     --------                      -------
     RCC_ADCCLKConfig                   0
     RCC_AHBPeriphClockCmd              0
     RCC_AHBPeriphResetCmd              0
     RCC_APB1PeriphClockCmd             0
     RCC_APB1PeriphResetCmd             0
     RCC_APB2PeriphClockCmd             0
     RCC_APB2PeriphResetCmd             0
     RCC_AdjustHSICalibrationValue      0
     RCC_BackupResetCmd                 0
     RCC_ClearFlag                      0
     RCC_ClearITPendingBit              0
     RCC_ClockSecuritySystemCmd         0
     RCC_DeInit                         0
     RCC_GetClocksFreq                 12
     RCC_GetFlagStatus                  0
     RCC_GetITStatus                    0
     RCC_GetSYSCLKSource                0
     RCC_HCLKConfig                     0
     RCC_HSEConfig                      0
     RCC_HSICmd                         0
     RCC_I2S2CLKConfig                  0
     RCC_I2S3CLKConfig                  0
     RCC_ITConfig                       0
     RCC_LSEConfig                      0
     RCC_LSICmd                         0
     RCC_MCOConfig                      0
     RCC_OTGFSCLKConfig                 0
     RCC_PCLK1Config                    0
     RCC_PCLK2Config                    0
     RCC_PLL2Cmd                        0
     RCC_PLL2Config                     0
     RCC_PLL3Cmd                        0
     RCC_PLL3Config                     0
     RCC_PLLCmd                         0
     RCC_PLLConfig                      0
     RCC_PREDIV1Config                  4
     RCC_PREDIV2Config                  0
     RCC_RTCCLKCmd                      0
     RCC_RTCCLKConfig                   0
     RCC_SYSCLKConfig                   0
     RCC_WaitForHSEStartUp              8


   Section sizes:

     Function/Label                Bytes
     --------------                -----
     APBAHBPrescTable                20
     ADCPrescTable
     RCC_DeInit                      62
     RCC_HSEConfig                   50
     RCC_WaitForHSEStartUp           46
     RCC_AdjustHSICalibrationValue   10
     ?Subroutine3                     8
     RCC_HSICmd                       6
     RCC_PLLConfig                   10
     ?Subroutine1                     8
     RCC_PLLCmd                       6
     RCC_PREDIV1Config               12
     RCC_PREDIV2Config                4
     ?Subroutine0                    12
     RCC_PLL2Config                  10
     RCC_PLL2Cmd                      6
     RCC_PLL3Config                  10
     RCC_PLL3Cmd                      6
     RCC_SYSCLKConfig                14
     RCC_GetSYSCLKSource             10
     RCC_HCLKConfig                   2
     RCC_PCLK1Config                 10
     RCC_PCLK2Config                  8
     RCC_ITConfig                    18
     RCC_OTGFSCLKConfig               6
     RCC_ADCCLKConfig                10
     RCC_I2S2CLKConfig                6
     RCC_I2S3CLKConfig                6
     RCC_LSEConfig                   22
     RCC_LSICmd                       6
     RCC_RTCCLKConfig                 6
     RCC_RTCCLKCmd                    6
     RCC_GetClocksFreq              170
     RCC_AHBPeriphClockCmd           18
     RCC_APB2PeriphClockCmd          18
     RCC_APB1PeriphClockCmd          18
     RCC_AHBPeriphResetCmd           18
     RCC_APB2PeriphResetCmd          18
     RCC_APB1PeriphResetCmd          18
     RCC_BackupResetCmd               6
     RCC_ClockSecuritySystemCmd       6
     RCC_MCOConfig                    6
     RCC_GetFlagStatus               36
     ?Subroutine2                     8
     RCC_ClearFlag                   12
     RCC_GetITStatus                  8
     RCC_ClearITPendingBit            6
     ??DataTable35                    4
     ??DataTable35_1                  4
     ??DataTable35_2                  4
     ??DataTable35_3                  4
     ??DataTable35_4                  4
     ??DataTable35_5                  4
     ??DataTable35_6                  4
     ??DataTable35_7                  4
     ??DataTable35_8                  4
     ??DataTable35_9                  4
     ??DataTable35_10                 4
     ??DataTable35_11                 4
     ??DataTable35_12                 4
     ??DataTable35_13                 4
     ??DataTable35_14                 4
     ??DataTable35_15                 4
     ??DataTable35_16                 4
     ??DataTable35_17                 4
     ??DataTable35_18                 4
     ??DataTable35_19                 4
     ??DataTable35_20                 4
     ??DataTable35_21                 4
     ??DataTable35_22                 4
     ??DataTable35_23                 4
     ??DataTable35_24                 4
     ??DataTable35_25                 4
     ??DataTable35_26                 4
     ??DataTable35_27                 4
     ??DataTable35_28                 4
     ??DataTable35_29                 4
     ??DataTable35_30                 4
     ??DataTable35_31                 4

 
  20 bytes in section .data
 890 bytes in section .text
 
 890 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: none
