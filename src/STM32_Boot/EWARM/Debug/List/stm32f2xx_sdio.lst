###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     04/Dec/2013  10:58:13 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\STM32F2xx_StdPeriph_Driver\src\stm32f2xx #
#                    _sdio.c                                                  #
#    Command line =  D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\STM32F2xx_StdPeriph_Driver\src\stm32f2xx #
#                    _sdio.c -D STM32F10X_CL -D USE_STDPERIPH_DRIVER -lcN     #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\List\ -lb                    #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\List\ -o                     #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\Obj\ --no_cse --no_unroll    #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --warnings_are_errors --fpu=None --dlib_config        #
#                    E:\SoftwareInstall\arm\INC\c\DLib_Config_Normal.h -I     #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\..\inc\ -I                         #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\..\CMSIS\CM3\CoreSupport\ -I       #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\..\STM32F2xx_StdPeriph_Driver\inc\ #
#                     -I D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\ #
#                    改进型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_13081 #
#                    5_IAR6.1\STM32_Boot\EWARM\..\CMSIS\CM3\DeviceSupport\ST\ #
#                    STM32F2xx\ -On --use_c++_inline                          #
#    List file    =  D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\List\stm32f2xx_sdio.lst      #
#    Object file  =  D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\Obj\stm32f2xx_sdio.o         #
#                                                                             #
#                                                                             #
###############################################################################

D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IAR6.1\STM32_Boot\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_sdio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_sdio.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    18-April-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Secure digital input/output interface (SDIO) 
      9            *          peripheral:
     10            *           - Initialization and Configuration
     11            *           - Command path state machine (CPSM) management
     12            *           - Data path state machine (DPSM) management
     13            *           - SDIO IO Cards mode management
     14            *           - CE-ATA mode management
     15            *           - DMA transfers management
     16            *           - Interrupts and flags management
     17            *
     18            *  @verbatim
     19            *
     20            *
     21            *          ===================================================================
     22            *                                 How to use this driver
     23            *          ===================================================================
     24            *          1. The SDIO clock (SDIOCLK = 48 MHz) is coming from a specific output
     25            *             of PLL (PLL48CLK). Before to start working with SDIO peripheral
     26            *             make sure that the PLL is well configured.
     27            *          The SDIO peripheral uses two clock signals:
     28            *              - SDIO adapter clock (SDIOCLK = 48 MHz)
     29            *              - APB2 bus clock (PCLK2)
     30            *          PCLK2 and SDIO_CK clock frequencies must respect the following condition:
     31            *                   Frequenc(PCLK2) >= (3 / 8 x Frequency(SDIO_CK))
     32            *
     33            *          2. Enable peripheral clock using RCC_APB2PeriphClockCmd(RCC_APB2Periph_SDIO, ENABLE).
     34            *
     35            *          3.  According to the SDIO mode, enable the GPIO clocks using 
     36            *              RCC_AHB1PeriphClockCmd() function. 
     37            *              The I/O can be one of the following configurations:
     38            *                 - 1-bit data length: SDIO_CMD, SDIO_CK and D0.
     39            *                 - 4-bit data length: SDIO_CMD, SDIO_CK and D[3:0].
     40            *                 - 8-bit data length: SDIO_CMD, SDIO_CK and D[7:0].      
     41            *
     42            *          4. Peripheral's alternate function: 
     43            *                 - Connect the pin to the desired peripherals' Alternate 
     44            *                   Function (AF) using GPIO_PinAFConfig() function
     45            *                 - Configure the desired pin in alternate function by:
     46            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     47            *                 - Select the type, pull-up/pull-down and output speed via 
     48            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     49            *                 - Call GPIO_Init() function
     50            *
     51            *          5. Program the Clock Edge, Clock Bypass, Clock Power Save, Bus Wide, 
     52            *             hardware, flow control and the Clock Divider using the SDIO_Init()
     53            *             function.
     54            *
     55            *          6. Enable the Power ON State using the SDIO_SetPowerState(SDIO_PowerState_ON) 
     56            *             function.
     57            *              
     58            *          7. Enable the clock using the SDIO_ClockCmd() function.
     59            *
     60            *          8. Enable the NVIC and the corresponding interrupt using the function 
     61            *             SDIO_ITConfig() if you need to use interrupt mode. 
     62            *
     63            *          9. When using the DMA mode 
     64            *                   - Configure the DMA using DMA_Init() function
     65            *                   - Active the needed channel Request using SDIO_DMACmd() function
     66            *
     67            *          10. Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
     68            *
     69            *          11. To control the CPSM (Command Path State Machine) and send 
     70            *              commands to the card use the SDIO_SendCommand(), 
     71            *              SDIO_GetCommandResponse() and SDIO_GetResponse() functions.     
     72            *              First, user has to fill the command structure (pointer to
     73            *              SDIO_CmdInitTypeDef) according to the selected command to be sent.
     74            *                 The parameters that should be filled are:
     75            *                   - Command Argument
     76            *                   - Command Index
     77            *                   - Command Response type
     78            *                   - Command Wait
     79            *                   - CPSM Status (Enable or Disable)
     80            *
     81            *              To check if the command is well received, read the SDIO_CMDRESP
     82            *              register using the SDIO_GetCommandResponse().
     83            *              The SDIO responses registers (SDIO_RESP1 to SDIO_RESP2), use the
     84            *              SDIO_GetResponse() function.
     85            *
     86            *          12. To control the DPSM (Data Path State Machine) and send/receive 
     87            *              data to/from the card use the SDIO_DataConfig(), SDIO_GetDataCounter(), 
     88            *              SDIO_ReadData(), SDIO_WriteData() and SDIO_GetFIFOCount() functions.
     89            *
     90            *              Read Operations
     91            *              ---------------
     92            *              a) First, user has to fill the data structure (pointer to
     93            *                 SDIO_DataInitTypeDef) according to the selected data type to
     94            *                 be received.
     95            *                 The parameters that should be filled are:
     96            *                   - Data TimeOut
     97            *                   - Data Length
     98            *                   - Data Block size
     99            *                   - Data Transfer direction: should be from card (To SDIO)
    100            *                   - Data Transfer mode
    101            *                   - DPSM Status (Enable or Disable)
    102            *                                   
    103            *              b) Configure the SDIO resources to receive the data from the card
    104            *                 according to selected transfer mode (Refer to Step 8, 9 and 10).
    105            *
    106            *              c) Send the selected Read command (refer to step 11).
    107            *                  
    108            *              d) Use the SDIO flags/interrupts to check the transfer status.
    109            *
    110            *              Write Operations
    111            *              ---------------
    112            *              a) First, user has to fill the data structure (pointer to
    113            *                 SDIO_DataInitTypeDef) according to the selected data type to
    114            *                 be received.
    115            *                 The parameters that should be filled are:
    116            *                   - Data TimeOut
    117            *                   - Data Length
    118            *                   - Data Block size
    119            *                   - Data Transfer direction:  should be to card (To CARD)
    120            *                   - Data Transfer mode
    121            *                   - DPSM Status (Enable or Disable)
    122            *
    123            *              b) Configure the SDIO resources to send the data to the card
    124            *                 according to selected transfer mode (Refer to Step 8, 9 and 10).
    125            *                   
    126            *              c) Send the selected Write command (refer to step 11).
    127            *                  
    128            *              d) Use the SDIO flags/interrupts to check the transfer status.
    129            *
    130            *
    131            *  @endverbatim
    132            *
    133            *
    134            ******************************************************************************
    135            * @attention
    136            *
    137            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
    138            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
    139            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
    140            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
    141            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
    142            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
    143            *
    144            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
    145            ******************************************************************************
    146            */
    147          
    148          /* Includes ------------------------------------------------------------------*/
    149          #include "stm32f2xx_sdio.h"
    150          #include "stm32f2xx_rcc.h"
    151          #include "assert.h"
    152          /** @addtogroup STM32F2xx_StdPeriph_Driver
    153            * @{
    154            */
    155          
    156          /** @defgroup SDIO 
    157            * @brief SDIO driver modules
    158            * @{
    159            */ 
    160          
    161          /* Private typedef -----------------------------------------------------------*/
    162          /* Private define ------------------------------------------------------------*/
    163          
    164          /* ------------ SDIO registers bit address in the alias region ----------- */
    165          #define SDIO_OFFSET                (SDIO_BASE - PERIPH_BASE)
    166          
    167          /* --- CLKCR Register ---*/
    168          /* Alias word address of CLKEN bit */
    169          #define CLKCR_OFFSET              (SDIO_OFFSET + 0x04)
    170          #define CLKEN_BitNumber           0x08
    171          #define CLKCR_CLKEN_BB            (PERIPH_BB_BASE + (CLKCR_OFFSET * 32) + (CLKEN_BitNumber * 4))
    172          
    173          /* --- CMD Register ---*/
    174          /* Alias word address of SDIOSUSPEND bit */
    175          #define CMD_OFFSET                (SDIO_OFFSET + 0x0C)
    176          #define SDIOSUSPEND_BitNumber     0x0B
    177          #define CMD_SDIOSUSPEND_BB        (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (SDIOSUSPEND_BitNumber * 4))
    178          
    179          /* Alias word address of ENCMDCOMPL bit */
    180          #define ENCMDCOMPL_BitNumber      0x0C
    181          #define CMD_ENCMDCOMPL_BB         (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ENCMDCOMPL_BitNumber * 4))
    182          
    183          /* Alias word address of NIEN bit */
    184          #define NIEN_BitNumber            0x0D
    185          #define CMD_NIEN_BB               (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (NIEN_BitNumber * 4))
    186          
    187          /* Alias word address of ATACMD bit */
    188          #define ATACMD_BitNumber          0x0E
    189          #define CMD_ATACMD_BB             (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ATACMD_BitNumber * 4))
    190          
    191          /* --- DCTRL Register ---*/
    192          /* Alias word address of DMAEN bit */
    193          #define DCTRL_OFFSET              (SDIO_OFFSET + 0x2C)
    194          #define DMAEN_BitNumber           0x03
    195          #define DCTRL_DMAEN_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (DMAEN_BitNumber * 4))
    196          
    197          /* Alias word address of RWSTART bit */
    198          #define RWSTART_BitNumber         0x08
    199          #define DCTRL_RWSTART_BB          (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTART_BitNumber * 4))
    200          
    201          /* Alias word address of RWSTOP bit */
    202          #define RWSTOP_BitNumber          0x09
    203          #define DCTRL_RWSTOP_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTOP_BitNumber * 4))
    204          
    205          /* Alias word address of RWMOD bit */
    206          #define RWMOD_BitNumber           0x0A
    207          #define DCTRL_RWMOD_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWMOD_BitNumber * 4))
    208          
    209          /* Alias word address of SDIOEN bit */
    210          #define SDIOEN_BitNumber          0x0B
    211          #define DCTRL_SDIOEN_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (SDIOEN_BitNumber * 4))
    212          
    213          /* ---------------------- SDIO registers bit mask ------------------------ */
    214          /* --- CLKCR Register ---*/
    215          /* CLKCR register clear mask */
    216          #define CLKCR_CLEAR_MASK         ((uint32_t)0xFFFF8100) 
    217          
    218          /* --- PWRCTRL Register ---*/
    219          /* SDIO PWRCTRL Mask */
    220          #define PWR_PWRCTRL_MASK         ((uint32_t)0xFFFFFFFC)
    221          
    222          /* --- DCTRL Register ---*/
    223          /* SDIO DCTRL Clear Mask */
    224          #define DCTRL_CLEAR_MASK         ((uint32_t)0xFFFFFF08)
    225          
    226          /* --- CMD Register ---*/
    227          /* CMD Register clear mask */
    228          #define CMD_CLEAR_MASK           ((uint32_t)0xFFFFF800)
    229          
    230          /* SDIO RESP Registers Address */
    231          #define SDIO_RESP_ADDR           ((uint32_t)(SDIO_BASE + 0x14))
    232          
    233          /* Private macro -------------------------------------------------------------*/
    234          /* Private variables ---------------------------------------------------------*/
    235          /* Private function prototypes -----------------------------------------------*/
    236          /* Private functions ---------------------------------------------------------*/
    237          
    238          /** @defgroup SDIO_Private_Functions
    239            * @{
    240            */
    241          
    242          /** @defgroup SDIO_Group1 Initialization and Configuration functions
    243           *  @brief   Initialization and Configuration functions 
    244           *
    245          @verbatim   
    246           ===============================================================================
    247                           Initialization and Configuration functions
    248           ===============================================================================
    249          
    250          @endverbatim
    251            * @{
    252            */
    253          
    254          /**
    255            * @brief  Deinitializes the SDIO peripheral registers to their default reset values.
    256            * @param  None
    257            * @retval None
    258            */
    259          void SDIO_DeInit(void)
    260          {
    261            RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, ENABLE);
    262            RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, DISABLE);
    263          }
    264          
    265          /**
    266            * @brief  Initializes the SDIO peripheral according to the specified 
    267            *         parameters in the SDIO_InitStruct.
    268            * @param  SDIO_InitStruct : pointer to a SDIO_InitTypeDef structure 
    269            *         that contains the configuration information for the SDIO peripheral.
    270            * @retval None
    271            */
    272          void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct)
    273          {
    274            uint32_t tmpreg = 0;
    275              
    276            /* Check the parameters */
    277            assert(IS_SDIO_CLOCK_EDGE(SDIO_InitStruct->SDIO_ClockEdge));
    278            assert(IS_SDIO_CLOCK_BYPASS(SDIO_InitStruct->SDIO_ClockBypass));
    279            assert(IS_SDIO_CLOCK_POWER_SAVE(SDIO_InitStruct->SDIO_ClockPowerSave));
    280            assert(IS_SDIO_BUS_WIDE(SDIO_InitStruct->SDIO_BusWide));
    281            assert(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct->SDIO_HardwareFlowControl)); 
    282             
    283          /*---------------------------- SDIO CLKCR Configuration ------------------------*/  
    284            /* Get the SDIO CLKCR value */
    285            tmpreg = SDIO->CLKCR;
    286            
    287            /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */
    288            tmpreg &= CLKCR_CLEAR_MASK;
    289            
    290            /* Set CLKDIV bits according to SDIO_ClockDiv value */
    291            /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
    292            /* Set BYPASS bit according to SDIO_ClockBypass value */
    293            /* Set WIDBUS bits according to SDIO_BusWide value */
    294            /* Set NEGEDGE bits according to SDIO_ClockEdge value */
    295            /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
    296            tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
    297                       SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
    298                       SDIO_InitStruct->SDIO_ClockEdge | SDIO_InitStruct->SDIO_HardwareFlowControl); 
    299            
    300            /* Write to SDIO CLKCR */
    301            SDIO->CLKCR = tmpreg;
    302          }
    303          
    304          /**
    305            * @brief  Fills each SDIO_InitStruct member with its default value.
    306            * @param  SDIO_InitStruct: pointer to an SDIO_InitTypeDef structure which 
    307            *         will be initialized.
    308            * @retval None
    309            */
    310          void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct)
    311          {
    312            /* SDIO_InitStruct members default value */
    313            SDIO_InitStruct->SDIO_ClockDiv = 0x00;
    314            SDIO_InitStruct->SDIO_ClockEdge = SDIO_ClockEdge_Rising;
    315            SDIO_InitStruct->SDIO_ClockBypass = SDIO_ClockBypass_Disable;
    316            SDIO_InitStruct->SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
    317            SDIO_InitStruct->SDIO_BusWide = SDIO_BusWide_1b;
    318            SDIO_InitStruct->SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
    319          }
    320          
    321          /**
    322            * @brief  Enables or disables the SDIO Clock.
    323            * @param  NewState: new state of the SDIO Clock. 
    324            *         This parameter can be: ENABLE or DISABLE.
    325            * @retval None
    326            */
    327          void SDIO_ClockCmd(FunctionalState NewState)
    328          {
    329            /* Check the parameters */
    330            assert(IS_FUNCTIONAL_STATE(NewState));
    331            
    332            *(__IO uint32_t *) CLKCR_CLKEN_BB = (uint32_t)NewState;
    333          }
    334          
    335          /**
    336            * @brief  Sets the power status of the controller.
    337            * @param  SDIO_PowerState: new state of the Power state. 
    338            *          This parameter can be one of the following values:
    339            *            @arg SDIO_PowerState_OFF: SDIO Power OFF
    340            *            @arg SDIO_PowerState_ON: SDIO Power ON
    341            * @retval None
    342            */
    343          void SDIO_SetPowerState(uint32_t SDIO_PowerState)
    344          {
    345            /* Check the parameters */
    346            assert(IS_SDIO_POWER_STATE(SDIO_PowerState));
    347            
    348            SDIO->POWER &= PWR_PWRCTRL_MASK;
    349            SDIO->POWER |= SDIO_PowerState;
    350          }
    351          
    352          /**
    353            * @brief  Gets the power status of the controller.
    354            * @param  None
    355            * @retval Power status of the controller. The returned value can be one of the 
    356            *         following values:
    357            *            - 0x00: Power OFF
    358            *            - 0x02: Power UP
    359            *            - 0x03: Power ON 
    360            */
    361          uint32_t SDIO_GetPowerState(void)
    362          {
    363            return (SDIO->POWER & (~PWR_PWRCTRL_MASK));
    364          }
    365          
    366          /**
    367            * @}
    368            */
    369          
    370          /** @defgroup SDIO_Group2 Command path state machine (CPSM) management functions
    371           *  @brief   Command path state machine (CPSM) management functions 
    372           *
    373          @verbatim   
    374           ===============================================================================
    375                        Command path state machine (CPSM) management functions
    376           ===============================================================================  
    377          
    378            This section provide functions allowing to program and read the Command path 
    379            state machine (CPSM).
    380          
    381          @endverbatim
    382            * @{
    383            */
    384          
    385          /**
    386            * @brief  Initializes the SDIO Command according to the specified 
    387            *         parameters in the SDIO_CmdInitStruct and send the command.
    388            * @param  SDIO_CmdInitStruct : pointer to a SDIO_CmdInitTypeDef 
    389            *         structure that contains the configuration information for the SDIO 
    390            *         command.
    391            * @retval None
    392            */
    393          void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
    394          {
    395            uint32_t tmpreg = 0;
    396            
    397            /* Check the parameters */
    398            assert(IS_SDIO_CMD_INDEX(SDIO_CmdInitStruct->SDIO_CmdIndex));
    399            assert(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->SDIO_Response));
    400            assert(IS_SDIO_WAIT(SDIO_CmdInitStruct->SDIO_Wait));
    401            assert(IS_SDIO_CPSM(SDIO_CmdInitStruct->SDIO_CPSM));
    402            
    403          /*---------------------------- SDIO ARG Configuration ------------------------*/
    404            /* Set the SDIO Argument value */
    405            SDIO->ARG = SDIO_CmdInitStruct->SDIO_Argument;
    406            
    407          /*---------------------------- SDIO CMD Configuration ------------------------*/  
    408            /* Get the SDIO CMD value */
    409            tmpreg = SDIO->CMD;
    410            /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */
    411            tmpreg &= CMD_CLEAR_MASK;
    412            /* Set CMDINDEX bits according to SDIO_CmdIndex value */
    413            /* Set WAITRESP bits according to SDIO_Response value */
    414            /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
    415            /* Set CPSMEN bits according to SDIO_CPSM value */
    416            tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
    417                     | SDIO_CmdInitStruct->SDIO_Wait | SDIO_CmdInitStruct->SDIO_CPSM;
    418            
    419            /* Write to SDIO CMD */
    420            SDIO->CMD = tmpreg;
    421          }
    422          
    423          /**
    424            * @brief  Fills each SDIO_CmdInitStruct member with its default value.
    425            * @param  SDIO_CmdInitStruct: pointer to an SDIO_CmdInitTypeDef 
    426            *         structure which will be initialized.
    427            * @retval None
    428            */
    429          void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct)
    430          {
    431            /* SDIO_CmdInitStruct members default value */
    432            SDIO_CmdInitStruct->SDIO_Argument = 0x00;
    433            SDIO_CmdInitStruct->SDIO_CmdIndex = 0x00;
    434            SDIO_CmdInitStruct->SDIO_Response = SDIO_Response_No;
    435            SDIO_CmdInitStruct->SDIO_Wait = SDIO_Wait_No;
    436            SDIO_CmdInitStruct->SDIO_CPSM = SDIO_CPSM_Disable;
    437          }
    438          
    439          /**
    440            * @brief  Returns command index of last command for which response received.
    441            * @param  None
    442            * @retval Returns the command index of the last command response received.
    443            */
    444          uint8_t SDIO_GetCommandResponse(void)
    445          {
    446            return (uint8_t)(SDIO->RESPCMD);
    447          }
    448          
    449          /**
    450            * @brief  Returns response received from the card for the last command.
    451            * @param  SDIO_RESP: Specifies the SDIO response register. 
    452            *          This parameter can be one of the following values:
    453            *            @arg SDIO_RESP1: Response Register 1
    454            *            @arg SDIO_RESP2: Response Register 2
    455            *            @arg SDIO_RESP3: Response Register 3
    456            *            @arg SDIO_RESP4: Response Register 4
    457            * @retval The Corresponding response register value.
    458            */
    459          uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
    460          {
    461            __IO uint32_t tmp = 0;
    462          
    463            /* Check the parameters */
    464            assert(IS_SDIO_RESP(SDIO_RESP));
    465          
    466            tmp = SDIO_RESP_ADDR + SDIO_RESP;
    467            
    468            return (*(__IO uint32_t *) tmp); 
    469          }
    470          
    471          /**
    472            * @}
    473            */
    474          
    475          /** @defgroup SDIO_Group3 Data path state machine (DPSM) management functions
    476           *  @brief   Data path state machine (DPSM) management functions
    477           *
    478          @verbatim   
    479           ===============================================================================
    480                        Data path state machine (DPSM) management functions
    481           ===============================================================================  
    482          
    483            This section provide functions allowing to program and read the Data path 
    484            state machine (DPSM).
    485          
    486          @endverbatim
    487            * @{
    488            */
    489          
    490          /**
    491            * @brief  Initializes the SDIO data path according to the specified 
    492            *         parameters in the SDIO_DataInitStruct.
    493            * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure 
    494            *         that contains the configuration information for the SDIO command.
    495            * @retval None
    496            */
    497          void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
    498          {
    499            uint32_t tmpreg = 0;
    500            
    501            /* Check the parameters */
    502            assert(IS_SDIO_DATA_LENGTH(SDIO_DataInitStruct->SDIO_DataLength));
    503            assert(IS_SDIO_BLOCK_SIZE(SDIO_DataInitStruct->SDIO_DataBlockSize));
    504            assert(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->SDIO_TransferDir));
    505            assert(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->SDIO_TransferMode));
    506            assert(IS_SDIO_DPSM(SDIO_DataInitStruct->SDIO_DPSM));
    507          
    508          /*---------------------------- SDIO DTIMER Configuration ---------------------*/
    509            /* Set the SDIO Data TimeOut value */
    510            SDIO->DTIMER = SDIO_DataInitStruct->SDIO_DataTimeOut;
    511          
    512          /*---------------------------- SDIO DLEN Configuration -----------------------*/
    513            /* Set the SDIO DataLength value */
    514            SDIO->DLEN = SDIO_DataInitStruct->SDIO_DataLength;
    515          
    516          /*---------------------------- SDIO DCTRL Configuration ----------------------*/  
    517            /* Get the SDIO DCTRL value */
    518            tmpreg = SDIO->DCTRL;
    519            /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */
    520            tmpreg &= DCTRL_CLEAR_MASK;
    521            /* Set DEN bit according to SDIO_DPSM value */
    522            /* Set DTMODE bit according to SDIO_TransferMode value */
    523            /* Set DTDIR bit according to SDIO_TransferDir value */
    524            /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
    525            tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir
    526                     | SDIO_DataInitStruct->SDIO_TransferMode | SDIO_DataInitStruct->SDIO_DPSM;
    527          
    528            /* Write to SDIO DCTRL */
    529            SDIO->DCTRL = tmpreg;
    530          }
    531          
    532          /**
    533            * @brief  Fills each SDIO_DataInitStruct member with its default value.
    534            * @param  SDIO_DataInitStruct: pointer to an SDIO_DataInitTypeDef structure 
    535            *         which will be initialized.
    536            * @retval None
    537            */
    538          void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
    539          {
    540            /* SDIO_DataInitStruct members default value */
    541            SDIO_DataInitStruct->SDIO_DataTimeOut = 0xFFFFFFFF;
    542            SDIO_DataInitStruct->SDIO_DataLength = 0x00;
    543            SDIO_DataInitStruct->SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
    544            SDIO_DataInitStruct->SDIO_TransferDir = SDIO_TransferDir_ToCard;
    545            SDIO_DataInitStruct->SDIO_TransferMode = SDIO_TransferMode_Block;  
    546            SDIO_DataInitStruct->SDIO_DPSM = SDIO_DPSM_Disable;
    547          }
    548          
    549          /**
    550            * @brief  Returns number of remaining data bytes to be transferred.
    551            * @param  None
    552            * @retval Number of remaining data bytes to be transferred
    553            */
    554          uint32_t SDIO_GetDataCounter(void)
    555          { 
    556            return SDIO->DCOUNT;
    557          }
    558          
    559          /**
    560            * @brief  Read one data word from Rx FIFO.
    561            * @param  None
    562            * @retval Data received
    563            */
    564          uint32_t SDIO_ReadData(void)
    565          { 
    566            return SDIO->FIFO;
    567          }
    568          
    569          /**
    570            * @brief  Write one data word to Tx FIFO.
    571            * @param  Data: 32-bit data word to write.
    572            * @retval None
    573            */
    574          void SDIO_WriteData(uint32_t Data)
    575          { 
    576            SDIO->FIFO = Data;
    577          }
    578          
    579          /**
    580            * @brief  Returns the number of words left to be written to or read from FIFO.	
    581            * @param  None
    582            * @retval Remaining number of words.
    583            */
    584          uint32_t SDIO_GetFIFOCount(void)
    585          { 
    586            return SDIO->FIFOCNT;
    587          }
    588          
    589          /**
    590            * @}
    591            */
    592          
    593          /** @defgroup SDIO_Group4 SDIO IO Cards mode management functions
    594           *  @brief   SDIO IO Cards mode management functions
    595           *
    596          @verbatim   
    597           ===============================================================================
    598                        SDIO IO Cards mode management functions
    599           ===============================================================================  
    600          
    601            This section provide functions allowing to program and read the SDIO IO Cards.
    602          
    603          @endverbatim
    604            * @{
    605            */
    606          
    607          /**
    608            * @brief  Starts the SD I/O Read Wait operation.	
    609            * @param  NewState: new state of the Start SDIO Read Wait operation. 
    610            *         This parameter can be: ENABLE or DISABLE.
    611            * @retval None
    612            */
    613          void SDIO_StartSDIOReadWait(FunctionalState NewState)
    614          { 
    615            /* Check the parameters */
    616            assert(IS_FUNCTIONAL_STATE(NewState));
    617            
    618            *(__IO uint32_t *) DCTRL_RWSTART_BB = (uint32_t) NewState;
    619          }
    620          
    621          /**
    622            * @brief  Stops the SD I/O Read Wait operation.	
    623            * @param  NewState: new state of the Stop SDIO Read Wait operation. 
    624            *         This parameter can be: ENABLE or DISABLE.
    625            * @retval None
    626            */
    627          void SDIO_StopSDIOReadWait(FunctionalState NewState)
    628          { 
    629            /* Check the parameters */
    630            assert(IS_FUNCTIONAL_STATE(NewState));
    631            
    632            *(__IO uint32_t *) DCTRL_RWSTOP_BB = (uint32_t) NewState;
    633          }
    634          
    635          /**
    636            * @brief  Sets one of the two options of inserting read wait interval.
    637            * @param  SDIO_ReadWaitMode: SD I/O Read Wait operation mode.
    638            *          This parameter can be:
    639            *            @arg SDIO_ReadWaitMode_CLK: Read Wait control by stopping SDIOCLK
    640            *            @arg SDIO_ReadWaitMode_DATA2: Read Wait control using SDIO_DATA2
    641            * @retval None
    642            */
    643          void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode)
    644          {
    645            /* Check the parameters */
    646            assert(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
    647            
    648            *(__IO uint32_t *) DCTRL_RWMOD_BB = SDIO_ReadWaitMode;
    649          }
    650          
    651          /**
    652            * @brief  Enables or disables the SD I/O Mode Operation.
    653            * @param  NewState: new state of SDIO specific operation. 
    654            *         This parameter can be: ENABLE or DISABLE.
    655            * @retval None
    656            */
    657          void SDIO_SetSDIOOperation(FunctionalState NewState)
    658          { 
    659            /* Check the parameters */
    660            assert(IS_FUNCTIONAL_STATE(NewState));
    661            
    662            *(__IO uint32_t *) DCTRL_SDIOEN_BB = (uint32_t)NewState;
    663          }
    664          
    665          /**
    666            * @brief  Enables or disables the SD I/O Mode suspend command sending.
    667            * @param  NewState: new state of the SD I/O Mode suspend command.
    668            *         This parameter can be: ENABLE or DISABLE.
    669            * @retval None
    670            */
    671          void SDIO_SendSDIOSuspendCmd(FunctionalState NewState)
    672          { 
    673            /* Check the parameters */
    674            assert(IS_FUNCTIONAL_STATE(NewState));
    675            
    676            *(__IO uint32_t *) CMD_SDIOSUSPEND_BB = (uint32_t)NewState;
    677          }
    678          
    679          /**
    680            * @}
    681            */
    682          
    683          /** @defgroup SDIO_Group5 CE-ATA mode management functions
    684           *  @brief   CE-ATA mode management functions
    685           *
    686          @verbatim   
    687           ===============================================================================
    688                        CE-ATA mode management functions
    689           ===============================================================================  
    690          
    691            This section provide functions allowing to program and read the CE-ATA card.
    692          
    693          @endverbatim
    694            * @{
    695            */
    696          
    697          /**
    698            * @brief  Enables or disables the command completion signal.
    699            * @param  NewState: new state of command completion signal. 
    700            *         This parameter can be: ENABLE or DISABLE.
    701            * @retval None
    702            */
    703          void SDIO_CommandCompletionCmd(FunctionalState NewState)
    704          { 
    705            /* Check the parameters */
    706            assert(IS_FUNCTIONAL_STATE(NewState));
    707            
    708            *(__IO uint32_t *) CMD_ENCMDCOMPL_BB = (uint32_t)NewState;
    709          }
    710          
    711          /**
    712            * @brief  Enables or disables the CE-ATA interrupt.
    713            * @param  NewState: new state of CE-ATA interrupt. 
    714            *         This parameter can be: ENABLE or DISABLE.
    715            * @retval None
    716            */
    717          void SDIO_CEATAITCmd(FunctionalState NewState)
    718          { 
    719            /* Check the parameters */
    720            assert(IS_FUNCTIONAL_STATE(NewState));
    721            
    722            *(__IO uint32_t *) CMD_NIEN_BB = (uint32_t)((~((uint32_t)NewState)) & ((uint32_t)0x1));
    723          }
    724          
    725          /**
    726            * @brief  Sends CE-ATA command (CMD61).
    727            * @param  NewState: new state of CE-ATA command. 
    728            *         This parameter can be: ENABLE or DISABLE.
    729            * @retval None
    730            */
    731          void SDIO_SendCEATACmd(FunctionalState NewState)
    732          { 
    733            /* Check the parameters */
    734            assert(IS_FUNCTIONAL_STATE(NewState));
    735            
    736            *(__IO uint32_t *) CMD_ATACMD_BB = (uint32_t)NewState;
    737          }
    738          
    739          /**
    740            * @}
    741            */
    742          
    743          /** @defgroup SDIO_Group6 DMA transfers management functions
    744           *  @brief   DMA transfers management functions
    745           *
    746          @verbatim   
    747           ===============================================================================
    748                        DMA transfers management functions
    749           ===============================================================================  
    750          
    751            This section provide functions allowing to program SDIO DMA transfer.
    752          
    753          @endverbatim
    754            * @{
    755            */
    756          
    757          /**
    758            * @brief  Enables or disables the SDIO DMA request.
    759            * @param  NewState: new state of the selected SDIO DMA request.
    760            *          This parameter can be: ENABLE or DISABLE.
    761            * @retval None
    762            */
    763          void SDIO_DMACmd(FunctionalState NewState)
    764          {
    765            /* Check the parameters */
    766            assert(IS_FUNCTIONAL_STATE(NewState));
    767            
    768            *(__IO uint32_t *) DCTRL_DMAEN_BB = (uint32_t)NewState;
    769          }
    770          
    771          /**
    772            * @}
    773            */
    774          
    775          /** @defgroup SDIO_Group7 Interrupts and flags management functions
    776           *  @brief   Interrupts and flags management functions  
    777           *
    778          @verbatim   
    779           ===============================================================================
    780                                 Interrupts and flags management functions
    781           ===============================================================================  
    782          
    783          
    784          @endverbatim
    785            * @{
    786            */
    787          
    788          /**
    789            * @brief  Enables or disables the SDIO interrupts.
    790            * @param  SDIO_IT: specifies the SDIO interrupt sources to be enabled or disabled.
    791            *          This parameter can be one or a combination of the following values:
    792            *            @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
    793            *            @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
    794            *            @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
    795            *            @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
    796            *            @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
    797            *            @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
    798            *            @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
    799            *            @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
    800            *            @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
    801            *            @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
    802            *                                   bus mode interrupt
    803            *            @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
    804            *            @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt
    805            *            @arg SDIO_IT_TXACT:    Data transmit in progress interrupt
    806            *            @arg SDIO_IT_RXACT:    Data receive in progress interrupt
    807            *            @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
    808            *            @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt
    809            *            @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt
    810            *            @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt
    811            *            @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt
    812            *            @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt
    813            *            @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt
    814            *            @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt
    815            *            @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
    816            *            @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt
    817            * @param  NewState: new state of the specified SDIO interrupts.
    818            *          This parameter can be: ENABLE or DISABLE.
    819            * @retval None 
    820            */
    821          void SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState)
    822          {
    823            /* Check the parameters */
    824            assert(IS_SDIO_IT(SDIO_IT));
    825            assert(IS_FUNCTIONAL_STATE(NewState));
    826            
    827            if (NewState != DISABLE)
    828            {
    829              /* Enable the SDIO interrupts */
    830              SDIO->MASK |= SDIO_IT;
    831            }
    832            else
    833            {
    834              /* Disable the SDIO interrupts */
    835              SDIO->MASK &= ~SDIO_IT;
    836            } 
    837          }
    838          
    839          /**
    840            * @brief  Checks whether the specified SDIO flag is set or not.
    841            * @param  SDIO_FLAG: specifies the flag to check. 
    842            *          This parameter can be one of the following values:
    843            *            @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed)
    844            *            @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
    845            *            @arg SDIO_FLAG_CTIMEOUT: Command response timeout
    846            *            @arg SDIO_FLAG_DTIMEOUT: Data timeout
    847            *            @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error
    848            *            @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error
    849            *            @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed)
    850            *            @arg SDIO_FLAG_CMDSENT:  Command sent (no response required)
    851            *            @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
    852            *            @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide bus mode.
    853            *            @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
    854            *            @arg SDIO_FLAG_CMDACT:   Command transfer in progress
    855            *            @arg SDIO_FLAG_TXACT:    Data transmit in progress
    856            *            @arg SDIO_FLAG_RXACT:    Data receive in progress
    857            *            @arg SDIO_FLAG_TXFIFOHE: Transmit FIFO Half Empty
    858            *            @arg SDIO_FLAG_RXFIFOHF: Receive FIFO Half Full
    859            *            @arg SDIO_FLAG_TXFIFOF:  Transmit FIFO full
    860            *            @arg SDIO_FLAG_RXFIFOF:  Receive FIFO full
    861            *            @arg SDIO_FLAG_TXFIFOE:  Transmit FIFO empty
    862            *            @arg SDIO_FLAG_RXFIFOE:  Receive FIFO empty
    863            *            @arg SDIO_FLAG_TXDAVL:   Data available in transmit FIFO
    864            *            @arg SDIO_FLAG_RXDAVL:   Data available in receive FIFO
    865            *            @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received
    866            *            @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61
    867            * @retval The new state of SDIO_FLAG (SET or RESET).
    868            */
    869          FlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG)
    870          { 
    871            FlagStatus bitstatus = RESET;
    872            
    873            /* Check the parameters */
    874            assert(IS_SDIO_FLAG(SDIO_FLAG));
    875            
    876            if ((SDIO->STA & SDIO_FLAG) != (uint32_t)RESET)
    877            {
    878              bitstatus = SET;
    879            }
    880            else
    881            {
    882              bitstatus = RESET;
    883            }
    884            return bitstatus;
    885          }
    886          
    887          /**
    888            * @brief  Clears the SDIO's pending flags.
    889            * @param  SDIO_FLAG: specifies the flag to clear.  
    890            *          This parameter can be one or a combination of the following values:
    891            *            @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed)
    892            *            @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)
    893            *            @arg SDIO_FLAG_CTIMEOUT: Command response timeout
    894            *            @arg SDIO_FLAG_DTIMEOUT: Data timeout
    895            *            @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error
    896            *            @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error
    897            *            @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed)
    898            *            @arg SDIO_FLAG_CMDSENT:  Command sent (no response required)
    899            *            @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)
    900            *            @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide bus mode
    901            *            @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed)
    902            *            @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received
    903            *            @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61
    904            * @retval None
    905            */
    906          void SDIO_ClearFlag(uint32_t SDIO_FLAG)
    907          { 
    908            /* Check the parameters */
    909            assert(IS_SDIO_CLEAR_FLAG(SDIO_FLAG));
    910             
    911            SDIO->ICR = SDIO_FLAG;
    912          }
    913          
    914          /**
    915            * @brief  Checks whether the specified SDIO interrupt has occurred or not.
    916            * @param  SDIO_IT: specifies the SDIO interrupt source to check. 
    917            *          This parameter can be one of the following values:
    918            *            @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
    919            *            @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
    920            *            @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
    921            *            @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
    922            *            @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
    923            *            @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
    924            *            @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
    925            *            @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
    926            *            @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt
    927            *            @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
    928            *                                   bus mode interrupt
    929            *            @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt
    930            *            @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt
    931            *            @arg SDIO_IT_TXACT:    Data transmit in progress interrupt
    932            *            @arg SDIO_IT_RXACT:    Data receive in progress interrupt
    933            *            @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt
    934            *            @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt
    935            *            @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt
    936            *            @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt
    937            *            @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt
    938            *            @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt
    939            *            @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt
    940            *            @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt
    941            *            @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
    942            *            @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt
    943            * @retval The new state of SDIO_IT (SET or RESET).
    944            */
    945          ITStatus SDIO_GetITStatus(uint32_t SDIO_IT)
    946          { 
    947            ITStatus bitstatus = RESET;
    948            
    949            /* Check the parameters */
    950            assert(IS_SDIO_GET_IT(SDIO_IT));
    951            if ((SDIO->STA & SDIO_IT) != (uint32_t)RESET)  
    952            {
    953              bitstatus = SET;
    954            }
    955            else
    956            {
    957              bitstatus = RESET;
    958            }
    959            return bitstatus;
    960          }
    961          
    962          /**
    963            * @brief  Clears the SDIO's interrupt pending bits.
    964            * @param  SDIO_IT: specifies the interrupt pending bit to clear. 
    965            *          This parameter can be one or a combination of the following values:
    966            *            @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt
    967            *            @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt
    968            *            @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt
    969            *            @arg SDIO_IT_DTIMEOUT: Data timeout interrupt
    970            *            @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt
    971            *            @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt
    972            *            @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt
    973            *            @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt
    974            *            @arg SDIO_IT_DATAEND:  Data end (data counter, SDIO_DCOUNT, is zero) interrupt
    975            *            @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide 
    976            *                                   bus mode interrupt
    977            *            @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt
    978            *            @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61
    979            * @retval None
    980            */
    981          void SDIO_ClearITPendingBit(uint32_t SDIO_IT)
    982          { 
    983            /* Check the parameters */
    984            assert(IS_SDIO_CLEAR_IT(SDIO_IT));
    985             
    986            SDIO->ICR = SDIO_IT;
    987          }
    988          
    989          /**
    990            * @}
    991            */
    992          
    993          /**
    994            * @}
    995            */
    996          
    997          /**
    998            * @}
    999            */
   1000          
   1001          /**
   1002            * @}
   1003            */
   1004          
   1005          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                  .cstack
     --------                  -------
     SDIO_CEATAITCmd                8
     SDIO_ClearFlag                 8
     SDIO_ClearITPendingBit         8
     SDIO_ClockCmd                  8
     SDIO_CmdStructInit             0
     SDIO_CommandCompletionCmd      8
     SDIO_DMACmd                    8
     SDIO_DataConfig               16
     SDIO_DataStructInit            0
     SDIO_DeInit                    8
     SDIO_GetCommandResponse        0
     SDIO_GetDataCounter            0
     SDIO_GetFIFOCount              0
     SDIO_GetFlagStatus            16
     SDIO_GetITStatus              16
     SDIO_GetPowerState             0
     SDIO_GetResponse              16
     SDIO_ITConfig                 16
     SDIO_Init                     16
     SDIO_ReadData                  0
     SDIO_SendCEATACmd              8
     SDIO_SendCommand              16
     SDIO_SendSDIOSuspendCmd        8
     SDIO_SetPowerState             8
     SDIO_SetSDIOOperation          8
     SDIO_SetSDIOReadWaitMode       8
     SDIO_StartSDIOReadWait         8
     SDIO_StopSDIOReadWait          8
     SDIO_StructInit                0
     SDIO_WriteData                 0


   Section sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     SDIO_DeInit                                      24
     SDIO_Init                                       232
     SDIO_StructInit                                  26
     SDIO_ClockCmd                                    46
     SDIO_SetPowerState                               64
     SDIO_GetPowerState                               12
     SDIO_SendCommand                                194
     SDIO_CmdStructInit                               22
     SDIO_GetCommandResponse                          10
     SDIO_GetResponse                                 60
     SDIO_DataConfig                                 292
     SDIO_DataStructInit                              28
     SDIO_GetDataCounter                               8
     SDIO_ReadData                                     8
     SDIO_WriteData                                    8
     SDIO_GetFIFOCount                                 8
     SDIO_StartSDIOReadWait                           46
     SDIO_StopSDIOReadWait                            46
     SDIO_SetSDIOReadWaitMode                         40
     SDIO_SetSDIOOperation                            46
     SDIO_SendSDIOSuspendCmd                          44
     SDIO_CommandCompletionCmd                        44
     SDIO_CEATAITCmd                                  50
     SDIO_SendCEATACmd                                44
     SDIO_DMACmd                                      44
     SDIO_ITConfig                                    98
     SDIO_GetFlagStatus                              182
     SDIO_ClearFlag                                   40
     SDIO_GetITStatus                                182
     SDIO_ClearITPendingBit                           40
     ??DataTable49                                     4
     ??DataTable49_1                                   4
     ??DataTable49_2                                   4
     ??DataTable49_3                                   4
     ??DataTable49_4                                   4
     ??DataTable49_5                                   4
     ??DataTable49_6                                   4
     ??DataTable49_7                                   4
     ??DataTable49_8                                   4
     ??DataTable49_9                                   4
     ??DataTable49_10                                  4
     ??DataTable49_11                                  4
     ??DataTable49_12                                  4
     ??DataTable49_13                                  4
     ??DataTable49_14                                  4
     ??DataTable49_15                                  4
     ??DataTable49_16                                  4
     ??DataTable49_17                                  4
     ??DataTable49_18                                  4
     ??DataTable49_19                                  4
     ??DataTable49_20                                  4
     ??DataTable49_21                                  4
     ??DataTable49_22                                  4
     ??DataTable49_23                                  4
     ??DataTable49_24                                  4
     ??DataTable49_25                                  4
     ??DataTable49_26                                  4
     ?<Constant "IS_SDIO_CLOCK_EDGE(SD...">           52
     ?<Constant "D:\\work\\\320\320\261\352\262\372  176
     ?<Constant "IS_SDIO_CLOCK_BYPASS(...">           56
     ?<Constant "IS_SDIO_CLOCK_POWER_S...">           64
     ?<Constant "IS_SDIO_BUS_WIDE(SDIO...">           48
     ?<Constant "IS_SDIO_HARDWARE_FLOW...">           76
     ?<Constant "IS_FUNCTIONAL_STATE(N...">           32
     ?<Constant "IS_SDIO_POWER_STATE(S...">           40
     ?<Constant "IS_SDIO_CMD_INDEX(SDI...">           56
     ?<Constant "IS_SDIO_RESPONSE(SDIO...">           52
     ?<Constant "IS_SDIO_WAIT(SDIO_Cmd...">           44
     ?<Constant "IS_SDIO_CPSM(SDIO_Cmd...">           44
     ?<Constant "IS_SDIO_RESP(SDIO_RESP)">            24
     ?<Constant "IS_SDIO_DATA_LENGTH(S...">           60
     ?<Constant "IS_SDIO_BLOCK_SIZE(SD...">           60
     ?<Constant "IS_SDIO_TRANSFER_DIR(...">           60
     ?<Constant "IS_SDIO_TRANSFER_MODE...">           64
     ?<Constant "IS_SDIO_DPSM(SDIO_Dat...">           48
     ?<Constant "IS_SDIO_READWAIT_MODE...">           44
     ?<Constant "IS_SDIO_IT(SDIO_IT)">                20
     ?<Constant "IS_SDIO_FLAG(SDIO_FLAG)">            24
     ?<Constant "IS_SDIO_CLEAR_FLAG(SD...">           32
     ?<Constant "IS_SDIO_GET_IT(SDIO_IT)">            24
     ?<Constant "IS_SDIO_CLEAR_IT(SDIO...">           28

 
 3 324 bytes in section .text
 
 3 324 bytes of CODE memory

Errors: none
Warnings: none
