###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     04/Dec/2013  10:58:07 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\STM32F2xx_StdPeriph_Driver\src\stm32f2xx #
#                    _can.c                                                   #
#    Command line =  D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\STM32F2xx_StdPeriph_Driver\src\stm32f2xx #
#                    _can.c -D STM32F10X_CL -D USE_STDPERIPH_DRIVER -lcN      #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\List\ -lb                    #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\List\ -o                     #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\Obj\ --no_cse --no_unroll    #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --warnings_are_errors --fpu=None --dlib_config        #
#                    E:\SoftwareInstall\arm\INC\c\DLib_Config_Normal.h -I     #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\..\inc\ -I                         #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\..\CMSIS\CM3\CoreSupport\ -I       #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\..\STM32F2xx_StdPeriph_Driver\inc\ #
#                     -I D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\ #
#                    改进型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_13081 #
#                    5_IAR6.1\STM32_Boot\EWARM\..\CMSIS\CM3\DeviceSupport\ST\ #
#                    STM32F2xx\ -On --use_c++_inline                          #
#    List file    =  D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\List\stm32f2xx_can.lst       #
#    Object file  =  D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\Obj\stm32f2xx_can.o          #
#                                                                             #
#                                                                             #
###############################################################################

D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IAR6.1\STM32_Boot\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_can.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_can.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    18-April-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Controller area network (CAN) peripheral:           
      9            *           - Initialization and Configuration 
     10            *           - CAN Frames Transmission 
     11            *           - CAN Frames Reception    
     12            *           - Operation modes switch  
     13            *           - Error management          
     14            *           - Interrupts and flags        
     15            *         
     16            *  @verbatim
     17            *                               
     18            *          ===================================================================      
     19            *                                   How to use this driver
     20            *          ===================================================================
     21                          
     22            *          1.  Enable the CAN controller interface clock using 
     23            *                  RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE); for CAN1 
     24            *              and RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2, ENABLE); for CAN2
     25            *  @note   In case you are using CAN2 only, you have to enable the CAN1 clock.
     26            *     
     27            *          2. CAN pins configuration
     28            *               - Enable the clock for the CAN GPIOs using the following function:
     29            *                   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);   
     30            *               - Connect the involved CAN pins to AF9 using the following function 
     31            *                   GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_CANx); 
     32            *                - Configure these CAN pins in alternate function mode by calling
     33            *                  the function  GPIO_Init();
     34            *    
     35            *          3.  Initialise and configure the CAN using CAN_Init() and 
     36            *               CAN_FilterInit() functions.   
     37            *               
     38            *          4.  Transmit the desired CAN frame using CAN_Transmit() function.
     39            *         
     40            *          5.  Check the transmission of a CAN frame using CAN_TransmitStatus()
     41            *              function.
     42            *               
     43            *          6.  Cancel the transmission of a CAN frame using CAN_CancelTransmit()
     44            *              function.  
     45            *            
     46            *          7.  Receive a CAN frame using CAN_Recieve() function.
     47            *         
     48            *          8.  Release the receive FIFOs using CAN_FIFORelease() function.
     49            *               
     50            *          9. Return the number of pending received frames using 
     51            *              CAN_MessagePending() function.            
     52            *                   
     53            *          10. To control CAN events you can use one of the following two methods:
     54            *               - Check on CAN flags using the CAN_GetFlagStatus() function.  
     55            *               - Use CAN interrupts through the function CAN_ITConfig() at 
     56            *                 initialization phase and CAN_GetITStatus() function into 
     57            *                 interrupt routines to check if the event has occurred or not.
     58            *             After checking on a flag you should clear it using CAN_ClearFlag()
     59            *             function. And after checking on an interrupt event you should 
     60            *             clear it using CAN_ClearITPendingBit() function.            
     61            *               
     62            *              
     63            *  @endverbatim
     64            *         
     65            ******************************************************************************
     66            * @attention
     67            *
     68            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     69            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     70            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     71            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     72            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     73            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     74            *
     75            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     76            ******************************************************************************  
     77            */
     78          
     79          /* Includes ------------------------------------------------------------------*/
     80          #include "stm32f2xx_can.h"
     81          #include "stm32f2xx_rcc.h"
     82          #include "assert.h"
     83          /** @addtogroup STM32F2xx_StdPeriph_Driver
     84            * @{
     85            */
     86          
     87          /** @defgroup CAN 
     88            * @brief CAN driver modules
     89            * @{
     90            */ 
     91          /* Private typedef -----------------------------------------------------------*/
     92          /* Private define ------------------------------------------------------------*/
     93          
     94          /* CAN Master Control Register bits */
     95          #define MCR_DBF           ((uint32_t)0x00010000) /* software master reset */
     96          
     97          /* CAN Mailbox Transmit Request */
     98          #define TMIDxR_TXRQ       ((uint32_t)0x00000001) /* Transmit mailbox request */
     99          
    100          /* CAN Filter Master Register bits */
    101          #define FMR_FINIT         ((uint32_t)0x00000001) /* Filter init mode */
    102          
    103          /* Time out for INAK bit */
    104          #define INAK_TIMEOUT      ((uint32_t)0x0000FFFF)
    105          /* Time out for SLAK bit */
    106          #define SLAK_TIMEOUT      ((uint32_t)0x0000FFFF)
    107          
    108          /* Flags in TSR register */
    109          #define CAN_FLAGS_TSR     ((uint32_t)0x08000000) 
    110          /* Flags in RF1R register */
    111          #define CAN_FLAGS_RF1R    ((uint32_t)0x04000000) 
    112          /* Flags in RF0R register */
    113          #define CAN_FLAGS_RF0R    ((uint32_t)0x02000000) 
    114          /* Flags in MSR register */
    115          #define CAN_FLAGS_MSR     ((uint32_t)0x01000000) 
    116          /* Flags in ESR register */
    117          #define CAN_FLAGS_ESR     ((uint32_t)0x00F00000) 
    118          
    119          /* Mailboxes definition */
    120          #define CAN_TXMAILBOX_0   ((uint8_t)0x00)
    121          #define CAN_TXMAILBOX_1   ((uint8_t)0x01)
    122          #define CAN_TXMAILBOX_2   ((uint8_t)0x02) 
    123          
    124          #define CAN_MODE_MASK     ((uint32_t) 0x00000003)
    125          
    126          /* Private macro -------------------------------------------------------------*/
    127          /* Private variables ---------------------------------------------------------*/
    128          /* Private function prototypes -----------------------------------------------*/
    129          /* Private functions ---------------------------------------------------------*/
    130          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
    131          
    132          /** @defgroup CAN_Private_Functions
    133            * @{
    134            */
    135          
    136          /** @defgroup CAN_Group1 Initialization and Configuration functions
    137           *  @brief    Initialization and Configuration functions 
    138           *
    139          @verbatim    
    140           ===============================================================================
    141                                Initialization and Configuration functions
    142           ===============================================================================  
    143            This section provides functions allowing to 
    144             - Initialize the CAN peripherals : Prescaler, operating mode, the maximum number 
    145               of time quanta to perform resynchronization, the number of time quanta in
    146               Bit Segment 1 and 2 and many other modes. 
    147               Refer to  @ref CAN_InitTypeDef  for more details.
    148             - Configures the CAN reception filter.                                      
    149             - Select the start bank filter for slave CAN.
    150             - Enables or disables the Debug Freeze mode for CAN
    151             - Enables or disables the CAN Time Trigger Operation communication mode
    152             
    153          @endverbatim
    154            * @{
    155            */
    156            
    157          /**
    158            * @brief  Deinitializes the CAN peripheral registers to their default reset values.
    159            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    160            * @retval None.
    161            */
    162          void CAN_DeInit(CAN_TypeDef* CANx)
    163          {
    164            /* Check the parameters */
    165            //assert_param(IS_CAN_ALL_PERIPH(CANx));
    166           
    167            if (CANx == CAN1)
    168            {
    169              /* Enable CAN1 reset state */
    170              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
    171              /* Release CAN1 from reset state */
    172              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
    173            }
    174            else
    175            {  
    176              /* Enable CAN2 reset state */
    177              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
    178              /* Release CAN2 from reset state */
    179              RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
    180            }
    181          }
    182          
    183          /**
    184            * @brief  Initializes the CAN peripheral according to the specified
    185            *         parameters in the CAN_InitStruct.
    186            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    187            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that contains
    188            *         the configuration information for the CAN peripheral.
    189            * @retval Constant indicates initialization succeed which will be 
    190            *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
    191            */
    192          uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
    193          {
    194            uint8_t InitStatus = CAN_InitStatus_Failed;
    195            uint32_t wait_ack = 0x00000000;
    196            /* Check the parameters */
    197            /*
    198            assert_param(IS_CAN_ALL_PERIPH(CANx));
    199            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
    200            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
    201            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
    202            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
    203            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
    204            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
    205            assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
    206            assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
    207            assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
    208            assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
    209            assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
    210          */
    211            /* Exit from sleep mode */
    212            CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
    213          
    214            /* Request initialisation */
    215            CANx->MCR |= CAN_MCR_INRQ ;
    216          
    217            /* Wait the acknowledge */
    218            while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    219            {
    220              wait_ack++;
    221            }
    222          
    223            /* Check acknowledge */
    224            if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
    225            {
    226              InitStatus = CAN_InitStatus_Failed;
    227            }
    228            else 
    229            {
    230              /* Set the time triggered communication mode */
    231              if (CAN_InitStruct->CAN_TTCM == ENABLE)
    232              {
    233                CANx->MCR |= CAN_MCR_TTCM;
    234              }
    235              else
    236              {
    237                CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
    238              }
    239          
    240              /* Set the automatic bus-off management */
    241              if (CAN_InitStruct->CAN_ABOM == ENABLE)
    242              {
    243                CANx->MCR |= CAN_MCR_ABOM;
    244              }
    245              else
    246              {
    247                CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
    248              }
    249          
    250              /* Set the automatic wake-up mode */
    251              if (CAN_InitStruct->CAN_AWUM == ENABLE)
    252              {
    253                CANx->MCR |= CAN_MCR_AWUM;
    254              }
    255              else
    256              {
    257                CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
    258              }
    259          
    260              /* Set the no automatic retransmission */
    261              if (CAN_InitStruct->CAN_NART == ENABLE)
    262              {
    263                CANx->MCR |= CAN_MCR_NART;
    264              }
    265              else
    266              {
    267                CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
    268              }
    269          
    270              /* Set the receive FIFO locked mode */
    271              if (CAN_InitStruct->CAN_RFLM == ENABLE)
    272              {
    273                CANx->MCR |= CAN_MCR_RFLM;
    274              }
    275              else
    276              {
    277                CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
    278              }
    279          
    280              /* Set the transmit FIFO priority */
    281              if (CAN_InitStruct->CAN_TXFP == ENABLE)
    282              {
    283                CANx->MCR |= CAN_MCR_TXFP;
    284              }
    285              else
    286              {
    287                CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    288              }
    289          
    290              /* Set the bit timing register */
    291              CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
    292                          ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
    293                          ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
    294                          ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
    295                         ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
    296          
    297              /* Request leave initialisation */
    298              CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
    299          
    300             /* Wait the acknowledge */
    301             wait_ack = 0;
    302          
    303             while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    304             {
    305               wait_ack++;
    306             }
    307          
    308              /* ...and check acknowledged */
    309              if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
    310              {
    311                InitStatus = CAN_InitStatus_Failed;
    312              }
    313              else
    314              {
    315                InitStatus = CAN_InitStatus_Success ;
    316              }
    317            }
    318          
    319            /* At this step, return the status of initialization */
    320            return InitStatus;
    321          }
    322          
    323          /**
    324            * @brief  Configures the CAN reception filter according to the specified
    325            *         parameters in the CAN_FilterInitStruct.
    326            * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef structure that
    327            *         contains the configuration information.
    328            * @retval None
    329            */
    330          void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
    331          {
    332            uint32_t filter_number_bit_pos = 0;
    333            /* Check the parameters */
    334            /*
    335            assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
    336            assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
    337            assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
    338            assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
    339            assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
    340          */
    341            filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
    342          
    343            /* Initialisation mode for the filter */
    344            CAN1->FMR |= FMR_FINIT;
    345          
    346            /* Filter Deactivation */
    347            CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
    348          
    349            /* Filter Scale */
    350            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
    351            {
    352              /* 16-bit scale for the filter */
    353              CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
    354          
    355              /* First 16-bit identifier and First 16-bit mask */
    356              /* Or First 16-bit identifier and Second 16-bit identifier */
    357              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    358                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
    359                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
    360          
    361              /* Second 16-bit identifier and Second 16-bit mask */
    362              /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    363              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    364                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    365                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
    366            }
    367          
    368            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
    369            {
    370              /* 32-bit scale for the filter */
    371              CAN1->FS1R |= filter_number_bit_pos;
    372              /* 32-bit identifier or First 32-bit identifier */
    373              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    374                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
    375                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
    376              /* 32-bit mask or Second 32-bit identifier */
    377              CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    378                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    379                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
    380            }
    381          
    382            /* Filter Mode */
    383            if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
    384            {
    385              /*Id/Mask mode for the filter*/
    386              CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
    387            }
    388            else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    389            {
    390              /*Identifier list mode for the filter*/
    391              CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
    392            }
    393          
    394            /* Filter FIFO assignment */
    395            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
    396            {
    397              /* FIFO 0 assignation for the filter */
    398              CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
    399            }
    400          
    401            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
    402            {
    403              /* FIFO 1 assignation for the filter */
    404              CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
    405            }
    406            
    407            /* Filter activation */
    408            if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
    409            {
    410              CAN1->FA1R |= filter_number_bit_pos;
    411            }
    412          
    413            /* Leave the initialisation mode for the filter */
    414            CAN1->FMR &= ~FMR_FINIT;
    415          }
    416          
    417          /**
    418            * @brief  Fills each CAN_InitStruct member with its default value.
    419            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which ill be initialized.
    420            * @retval None
    421            */
    422          void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
    423          {
    424            /* Reset CAN init structure parameters values */
    425            
    426            /* Initialize the time triggered communication mode */
    427            CAN_InitStruct->CAN_TTCM = DISABLE;
    428            
    429            /* Initialize the automatic bus-off management */
    430            CAN_InitStruct->CAN_ABOM = DISABLE;
    431            
    432            /* Initialize the automatic wake-up mode */
    433            CAN_InitStruct->CAN_AWUM = DISABLE;
    434            
    435            /* Initialize the no automatic retransmission */
    436            CAN_InitStruct->CAN_NART = DISABLE;
    437            
    438            /* Initialize the receive FIFO locked mode */
    439            CAN_InitStruct->CAN_RFLM = DISABLE;
    440            
    441            /* Initialize the transmit FIFO priority */
    442            CAN_InitStruct->CAN_TXFP = DISABLE;
    443            
    444            /* Initialize the CAN_Mode member */
    445            CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
    446            
    447            /* Initialize the CAN_SJW member */
    448            CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
    449            
    450            /* Initialize the CAN_BS1 member */
    451            CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
    452            
    453            /* Initialize the CAN_BS2 member */
    454            CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
    455            
    456            /* Initialize the CAN_Prescaler member */
    457            CAN_InitStruct->CAN_Prescaler = 1;
    458          }
    459          
    460          /**
    461            * @brief  Select the start bank filter for slave CAN.
    462            * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
    463            * @retval None
    464            */
    465          void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
    466          {
    467            /* Check the parameters */
    468            //assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
    469            
    470            /* Enter Initialisation mode for the filter */
    471            CAN1->FMR |= FMR_FINIT;
    472            
    473            /* Select the start slave bank */
    474            CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
    475            CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
    476            
    477            /* Leave Initialisation mode for the filter */
    478            CAN1->FMR &= ~FMR_FINIT;
    479          }
    480          
    481          /**
    482            * @brief  Enables or disables the DBG Freeze for CAN.
    483            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    484            * @param  NewState: new state of the CAN peripheral. 
    485            *          This parameter can be: ENABLE (CAN reception/transmission is frozen
    486            *          during debug. Reception FIFOs can still be accessed/controlled normally) 
    487            *          or DISABLE (CAN is working during debug).
    488            * @retval None
    489            */
    490          void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
    491          {
    492            /* Check the parameters */
    493            //assert_param(IS_CAN_ALL_PERIPH(CANx));
    494            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    495            
    496            if (NewState != DISABLE)
    497            {
    498              /* Enable Debug Freeze  */
    499              CANx->MCR |= MCR_DBF;
    500            }
    501            else
    502            {
    503              /* Disable Debug Freeze */
    504              CANx->MCR &= ~MCR_DBF;
    505            }
    506          }
    507          
    508          
    509          /**
    510            * @brief  Enables or disables the CAN Time TriggerOperation communication mode.
    511            * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be 
    512            *         sent over the CAN bus.  
    513            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    514            * @param  NewState: Mode new state. This parameter can be: ENABLE or DISABLE.
    515            *         When enabled, Time stamp (TIME[15:0]) value is  sent in the last two
    516            *         data bytes of the 8-byte message: TIME[7:0] in data byte 6 and TIME[15:8] 
    517            *         in data byte 7. 
    518            * @retval None
    519            */
    520          void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
    521          {
    522            /* Check the parameters */
    523            //assert_param(IS_CAN_ALL_PERIPH(CANx));
    524           // assert_param(IS_FUNCTIONAL_STATE(NewState));
    525            if (NewState != DISABLE)
    526            {
    527              /* Enable the TTCM mode */
    528              CANx->MCR |= CAN_MCR_TTCM;
    529          
    530              /* Set TGT bits */
    531              CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
    532              CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
    533              CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
    534            }
    535            else
    536            {
    537              /* Disable the TTCM mode */
    538              CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
    539          
    540              /* Reset TGT bits */
    541              CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
    542              CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
    543              CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
    544            }
    545          }
    546          /**
    547            * @}
    548            */
    549          
    550          
    551          /** @defgroup CAN_Group2 CAN Frames Transmission functions
    552           *  @brief    CAN Frames Transmission functions 
    553           *
    554          @verbatim    
    555           ===============================================================================
    556                                CAN Frames Transmission functions
    557           ===============================================================================  
    558            This section provides functions allowing to 
    559             - Initiate and transmit a CAN frame message (if there is an empty mailbox).
    560             - Check the transmission status of a CAN Frame
    561             - Cancel a transmit request
    562             
    563          @endverbatim
    564            * @{
    565            */
    566          
    567          /**
    568            * @brief  Initiates and transmits a CAN frame message.
    569            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    570            * @param  TxMessage: pointer to a structure which contains CAN Id, CAN DLC and CAN data.
    571            * @retval The number of the mailbox that is used for transmission or
    572            *         CAN_TxStatus_NoMailBox if there is no empty mailbox.
    573            */
    574          uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
    575          {
    576            uint8_t transmit_mailbox = 0;
    577            /* Check the parameters */
    578            /*
    579            assert_param(IS_CAN_ALL_PERIPH(CANx));
    580            assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
    581            assert_param(IS_CAN_RTR(TxMessage->RTR));
    582            assert_param(IS_CAN_DLC(TxMessage->DLC));
    583          */
    584            /* Select one empty transmit mailbox */
    585            if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
    586            {
    587              transmit_mailbox = 0;
    588            }
    589            else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
    590            {
    591              transmit_mailbox = 1;
    592            }
    593            else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
    594            {
    595              transmit_mailbox = 2;
    596            }
    597            else
    598            {
    599              transmit_mailbox = CAN_TxStatus_NoMailBox;
    600            }
    601          
    602            if (transmit_mailbox != CAN_TxStatus_NoMailBox)
    603            {
    604              /* Set up the Id */
    605              CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
    606              if (TxMessage->IDE == CAN_Id_Standard)
    607              {
    608                //assert_param(IS_CAN_STDID(TxMessage->StdId));  
    609                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
    610                                                            TxMessage->RTR);
    611              }
    612              else
    613              {
    614                //assert_param(IS_CAN_EXTID(TxMessage->ExtId));
    615                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
    616                                                            TxMessage->IDE | \
    617                                                            TxMessage->RTR);
    618              }
    619              
    620              /* Set up the DLC */
    621              TxMessage->DLC &= (uint8_t)0x0000000F;
    622              CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    623              CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
    624          
    625              /* Set up the data field */
    626              CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
    627                                                       ((uint32_t)TxMessage->Data[2] << 16) |
    628                                                       ((uint32_t)TxMessage->Data[1] << 8) | 
    629                                                       ((uint32_t)TxMessage->Data[0]));
    630              CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
    631                                                       ((uint32_t)TxMessage->Data[6] << 16) |
    632                                                       ((uint32_t)TxMessage->Data[5] << 8) |
    633                                                       ((uint32_t)TxMessage->Data[4]));
    634              /* Request transmission */
    635              CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
    636            }
    637            return transmit_mailbox;
    638          }
    639          
    640          /**
    641            * @brief  Checks the transmission status of a CAN Frame.
    642            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    643            * @param  TransmitMailbox: the number of the mailbox that is used for transmission.
    644            * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, 
    645            *         CAN_TxStatus_Failed in an other case.
    646            */
    647          uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
    648          {
    649            uint32_t state = 0;
    650          
    651            /* Check the parameters */
    652            //assert_param(IS_CAN_ALL_PERIPH(CANx));
    653            //assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
    654           
    655            switch (TransmitMailbox)
    656            {
    657              case (CAN_TXMAILBOX_0): 
    658                state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
    659                break;
    660              case (CAN_TXMAILBOX_1): 
    661                state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
    662                break;
    663              case (CAN_TXMAILBOX_2): 
    664                state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
    665                break;
    666              default:
    667                state = CAN_TxStatus_Failed;
    668                break;
    669            }
    670            switch (state)
    671            {
    672                /* transmit pending  */
    673              case (0x0): state = CAN_TxStatus_Pending;
    674                break;
    675                /* transmit failed  */
    676               case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
    677                break;
    678               case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
    679                break;
    680               case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
    681                break;
    682                /* transmit succeeded  */
    683              case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
    684                break;
    685              case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
    686                break;
    687              case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
    688                break;
    689              default: state = CAN_TxStatus_Failed;
    690                break;
    691            }
    692            return (uint8_t) state;
    693          }
    694          
    695          /**
    696            * @brief  Cancels a transmit request.
    697            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    698            * @param  Mailbox: Mailbox number.
    699            * @retval None
    700            */
    701          void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
    702          {
    703            /* Check the parameters */
    704            //assert_param(IS_CAN_ALL_PERIPH(CANx));
    705            //assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
    706            /* abort transmission */
    707            switch (Mailbox)
    708            {
    709              case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
    710                break;
    711              case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
    712                break;
    713              case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
    714                break;
    715              default:
    716                break;
    717            }
    718          }
    719          /**
    720            * @}
    721            */
    722          
    723          
    724          /** @defgroup CAN_Group3 CAN Frames Reception functions
    725           *  @brief    CAN Frames Reception functions 
    726           *
    727          @verbatim    
    728           ===============================================================================
    729                                CAN Frames Reception functions
    730           ===============================================================================  
    731            This section provides functions allowing to 
    732             -  Receive a correct CAN frame
    733             -  Release a specified receive FIFO (2 FIFOs are available)
    734             -  Return the number of the pending received CAN frames
    735             
    736          @endverbatim
    737            * @{
    738            */
    739          
    740          /**
    741            * @brief  Receives a correct CAN frame.
    742            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    743            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    744            * @param  RxMessage: pointer to a structure receive frame which contains CAN Id,
    745            *         CAN DLC, CAN data and FMI number.
    746            * @retval None
    747            */
    748          void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
    749          {
    750            /* Check the parameters */
    751            //assert_param(IS_CAN_ALL_PERIPH(CANx));
    752            //assert_param(IS_CAN_FIFO(FIFONumber));
    753            /* Get the Id */
    754            RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
    755            if (RxMessage->IDE == CAN_Id_Standard)
    756            {
    757              RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
    758            }
    759            else
    760            {
    761              RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
    762            }
    763            
    764            RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
    765            /* Get the DLC */
    766            RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
    767            /* Get the FMI */
    768            RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
    769            /* Get the data field */
    770            RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
    771            RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
    772            RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
    773            RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
    774            RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
    775            RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
    776            RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
    777            RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
    778            /* Release the FIFO */
    779            /* Release FIFO0 */
    780            if (FIFONumber == CAN_FIFO0)
    781            {
    782              CANx->RF0R |= CAN_RF0R_RFOM0;
    783            }
    784            /* Release FIFO1 */
    785            else /* FIFONumber == CAN_FIFO1 */
    786            {
    787              CANx->RF1R |= CAN_RF1R_RFOM1;
    788            }
    789          }
    790          
    791          /**
    792            * @brief  Releases the specified receive FIFO.
    793            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    794            * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
    795            * @retval None
    796            */
    797          void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
    798          {
    799            /* Check the parameters */
    800            //assert_param(IS_CAN_ALL_PERIPH(CANx));
    801            //assert_param(IS_CAN_FIFO(FIFONumber));
    802            /* Release FIFO0 */
    803            if (FIFONumber == CAN_FIFO0)
    804            {
    805              CANx->RF0R |= CAN_RF0R_RFOM0;
    806            }
    807            /* Release FIFO1 */
    808            else /* FIFONumber == CAN_FIFO1 */
    809            {
    810              CANx->RF1R |= CAN_RF1R_RFOM1;
    811            }
    812          }
    813          
    814          /**
    815            * @brief  Returns the number of pending received messages.
    816            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    817            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    818            * @retval NbMessage : which is the number of pending message.
    819            */
    820          uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
    821          {
    822            uint8_t message_pending=0;
    823            /* Check the parameters */
    824            //assert_param(IS_CAN_ALL_PERIPH(CANx));
    825            //assert_param(IS_CAN_FIFO(FIFONumber));
    826            if (FIFONumber == CAN_FIFO0)
    827            {
    828              message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
    829            }
    830            else if (FIFONumber == CAN_FIFO1)
    831            {
    832              message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
    833            }
    834            else
    835            {
    836              message_pending = 0;
    837            }
    838            return message_pending;
    839          }
    840          /**
    841            * @}
    842            */
    843          
    844          
    845          /** @defgroup CAN_Group4 CAN Operation modes functions
    846           *  @brief    CAN Operation modes functions 
    847           *
    848          @verbatim    
    849           ===============================================================================
    850                                CAN Operation modes functions
    851           ===============================================================================  
    852            This section provides functions allowing to select the CAN Operation modes
    853            - sleep mode
    854            - normal mode 
    855            - initialization mode
    856             
    857          @endverbatim
    858            * @{
    859            */
    860            
    861            
    862          /**
    863            * @brief  Selects the CAN Operation mode.
    864            * @param  CAN_OperatingMode: CAN Operating Mode.
    865            *         This parameter can be one of @ref CAN_OperatingMode_TypeDef enumeration.
    866            * @retval status of the requested mode which can be 
    867            *         - CAN_ModeStatus_Failed:  CAN failed entering the specific mode 
    868            *         - CAN_ModeStatus_Success: CAN Succeed entering the specific mode 
    869            */
    870          uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
    871          {
    872            uint8_t status = CAN_ModeStatus_Failed;
    873            
    874            /* Timeout for INAK or also for SLAK bits*/
    875            uint32_t timeout = INAK_TIMEOUT; 
    876          
    877            /* Check the parameters */
    878            //assert_param(IS_CAN_ALL_PERIPH(CANx));
    879            //assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
    880          
    881            if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
    882            {
    883              /* Request initialisation */
    884              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
    885          
    886              /* Wait the acknowledge */
    887              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
    888              {
    889                timeout--;
    890              }
    891              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
    892              {
    893                status = CAN_ModeStatus_Failed;
    894              }
    895              else
    896              {
    897                status = CAN_ModeStatus_Success;
    898              }
    899            }
    900            else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
    901            {
    902              /* Request leave initialisation and sleep mode  and enter Normal mode */
    903              CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
    904          
    905              /* Wait the acknowledge */
    906              while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
    907              {
    908                timeout--;
    909              }
    910              if ((CANx->MSR & CAN_MODE_MASK) != 0)
    911              {
    912                status = CAN_ModeStatus_Failed;
    913              }
    914              else
    915              {
    916                status = CAN_ModeStatus_Success;
    917              }
    918            }
    919            else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
    920            {
    921              /* Request Sleep mode */
    922              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
    923          
    924              /* Wait the acknowledge */
    925              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
    926              {
    927                timeout--;
    928              }
    929              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
    930              {
    931                status = CAN_ModeStatus_Failed;
    932              }
    933              else
    934              {
    935                status = CAN_ModeStatus_Success;
    936              }
    937            }
    938            else
    939            {
    940              status = CAN_ModeStatus_Failed;
    941            }
    942          
    943            return  (uint8_t) status;
    944          }
    945          
    946          /**
    947            * @brief  Enters the Sleep (low power) mode.
    948            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    949            * @retval CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed otherwise.
    950            */
    951          uint8_t CAN_Sleep(CAN_TypeDef* CANx)
    952          {
    953            uint8_t sleepstatus = CAN_Sleep_Failed;
    954            
    955            /* Check the parameters */
    956            //assert_param(IS_CAN_ALL_PERIPH(CANx));
    957              
    958            /* Request Sleep mode */
    959             CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
    960             
    961            /* Sleep mode status */
    962            if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
    963            {
    964              /* Sleep mode not entered */
    965              sleepstatus =  CAN_Sleep_Ok;
    966            }
    967            /* return sleep mode status */
    968             return (uint8_t)sleepstatus;
    969          }
    970          
    971          /**
    972            * @brief  Wakes up the CAN peripheral from sleep mode .
    973            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
    974            * @retval CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed otherwise.
    975            */
    976          uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
    977          {
    978            uint32_t wait_slak = SLAK_TIMEOUT;
    979            uint8_t wakeupstatus = CAN_WakeUp_Failed;
    980            
    981            /* Check the parameters */
    982            //assert_param(IS_CAN_ALL_PERIPH(CANx));
    983              
    984            /* Wake up request */
    985            CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
    986              
    987            /* Sleep mode status */
    988            while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
    989            {
    990             wait_slak--;
    991            }
    992            if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
    993            {
    994             /* wake up done : Sleep mode exited */
    995              wakeupstatus = CAN_WakeUp_Ok;
    996            }
    997            /* return wakeup status */
    998            return (uint8_t)wakeupstatus;
    999          }
   1000          /**
   1001            * @}
   1002            */
   1003          
   1004          
   1005          /** @defgroup CAN_Group5 CAN Bus Error management functions
   1006           *  @brief    CAN Bus Error management functions 
   1007           *
   1008          @verbatim    
   1009           ===============================================================================
   1010                                CAN Bus Error management functions
   1011           ===============================================================================  
   1012            This section provides functions allowing to 
   1013             -  Return the CANx's last error code (LEC)
   1014             -  Return the CANx Receive Error Counter (REC)
   1015             -  Return the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1016             
   1017             @note If TEC is greater than 255, The CAN is in bus-off state.
   1018             @note if REC or TEC are greater than 96, an Error warning flag occurs.
   1019             @note if REC or TEC are greater than 127, an Error Passive Flag occurs.
   1020                                  
   1021          @endverbatim
   1022            * @{
   1023            */
   1024            
   1025          /**
   1026            * @brief  Returns the CANx's last error code (LEC).
   1027            * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.
   1028            * @retval Error code: 
   1029            *          - CAN_ERRORCODE_NoErr: No Error  
   1030            *          - CAN_ERRORCODE_StuffErr: Stuff Error
   1031            *          - CAN_ERRORCODE_FormErr: Form Error
   1032            *          - CAN_ERRORCODE_ACKErr : Acknowledgment Error
   1033            *          - CAN_ERRORCODE_BitRecessiveErr: Bit Recessive Error
   1034            *          - CAN_ERRORCODE_BitDominantErr: Bit Dominant Error
   1035            *          - CAN_ERRORCODE_CRCErr: CRC Error
   1036            *          - CAN_ERRORCODE_SoftwareSetErr: Software Set Error  
   1037            */
   1038          uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
   1039          {
   1040            uint8_t errorcode=0;
   1041            
   1042            /* Check the parameters */
   1043            //assert_param(IS_CAN_ALL_PERIPH(CANx));
   1044            
   1045            /* Get the error code*/
   1046            errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
   1047            
   1048            /* Return the error code*/
   1049            return errorcode;
   1050          }
   1051          
   1052          /**
   1053            * @brief  Returns the CANx Receive Error Counter (REC).
   1054            * @note   In case of an error during reception, this counter is incremented 
   1055            *         by 1 or by 8 depending on the error condition as defined by the CAN 
   1056            *         standard. After every successful reception, the counter is 
   1057            *         decremented by 1 or reset to 120 if its value was higher than 128. 
   1058            *         When the counter value exceeds 127, the CAN controller enters the 
   1059            *         error passive state.  
   1060            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.  
   1061            * @retval CAN Receive Error Counter. 
   1062            */
   1063          uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
   1064          {
   1065            uint8_t counter=0;
   1066            
   1067            /* Check the parameters */
   1068            //assert_param(IS_CAN_ALL_PERIPH(CANx));
   1069            
   1070            /* Get the Receive Error Counter*/
   1071            counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
   1072            
   1073            /* Return the Receive Error Counter*/
   1074            return counter;
   1075          }
   1076          
   1077          
   1078          /**
   1079            * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1080            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1081            * @retval LSB of the 9-bit CAN Transmit Error Counter. 
   1082            */
   1083          uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
   1084          {
   1085            uint8_t counter=0;
   1086            
   1087            /* Check the parameters */
   1088            ///assert_param(IS_CAN_ALL_PERIPH(CANx));
   1089            
   1090            /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1091            counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
   1092            
   1093            /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1094            return counter;
   1095          }
   1096          /**
   1097            * @}
   1098            */
   1099          
   1100          /** @defgroup CAN_Group6 Interrupts and flags management functions
   1101           *  @brief   Interrupts and flags management functions
   1102           *
   1103          @verbatim   
   1104           ===============================================================================
   1105                             Interrupts and flags management functions
   1106           ===============================================================================  
   1107          
   1108            This section provides functions allowing to configure the CAN Interrupts and 
   1109            to get the status and clear flags and Interrupts pending bits.
   1110            
   1111            The CAN provides 14 Interrupts sources and 15 Flags:
   1112          
   1113            ===============  
   1114                Flags :
   1115            ===============
   1116            The 15 flags can be divided on 4 groups: 
   1117          
   1118             A. Transmit Flags
   1119            -----------------------
   1120                  CAN_FLAG_RQCP0, 
   1121                  CAN_FLAG_RQCP1, 
   1122                  CAN_FLAG_RQCP2  : Request completed MailBoxes 0, 1 and 2  Flags
   1123                                    Set when when the last request (transmit or abort) has 
   1124                                    been performed. 
   1125          
   1126            B. Receive Flags
   1127            -----------------------
   1128          
   1129                  CAN_FLAG_FMP0,
   1130                  CAN_FLAG_FMP1   : FIFO 0 and 1 Message Pending Flags 
   1131                                    set to signal that messages are pending in the receive 
   1132                                    FIFO.
   1133                                    These Flags are cleared only by hardware. 
   1134          
   1135                  CAN_FLAG_FF0,
   1136                  CAN_FLAG_FF1    : FIFO 0 and 1 Full Flags
   1137                                    set when three messages are stored in the selected 
   1138                                    FIFO.                        
   1139          
   1140                  CAN_FLAG_FOV0              
   1141                  CAN_FLAG_FOV1   : FIFO 0 and 1 Overrun Flags
   1142                                    set when a new message has been received and passed 
   1143                                    the filter while the FIFO was full.         
   1144          
   1145            C. Operating Mode Flags
   1146            ----------------------- 
   1147                  CAN_FLAG_WKU    : Wake up Flag
   1148                                    set to signal that a SOF bit has been detected while 
   1149                                    the CAN hardware was in Sleep mode. 
   1150                  
   1151                  CAN_FLAG_SLAK   : Sleep acknowledge Flag
   1152                                    Set to signal that the CAN has entered Sleep Mode. 
   1153              
   1154            D. Error Flags
   1155            ----------------------- 
   1156                  CAN_FLAG_EWG    : Error Warning Flag
   1157                                    Set when the warning limit has been reached (Receive 
   1158                                    Error Counter or Transmit Error Counter greater than 96). 
   1159                                    This Flag is cleared only by hardware.
   1160                                      
   1161                  CAN_FLAG_EPV    : Error Passive Flag
   1162                                    Set when the Error Passive limit has been reached 
   1163                                    (Receive Error Counter or Transmit Error Counter 
   1164                                    greater than 127).
   1165                                    This Flag is cleared only by hardware.
   1166                                       
   1167                  CAN_FLAG_BOF    : Bus-Off Flag
   1168                                    set when CAN enters the bus-off state. The bus-off 
   1169                                    state is entered on TEC overflow, greater than 255.
   1170                                    This Flag is cleared only by hardware.
   1171                                             
   1172                  CAN_FLAG_LEC    : Last error code Flag
   1173                                    set If a message has been transferred (reception or
   1174                                    transmission) with error, and the error code is hold.              
   1175                                    
   1176            ===============  
   1177             Interrupts :
   1178            ===============
   1179            The 14 interrupts can be divided on 4 groups: 
   1180            
   1181             A. Transmit interrupt
   1182            -----------------------   
   1183                    CAN_IT_TME   :  Transmit mailbox empty Interrupt
   1184                                    if enabled, this interrupt source is pending when 
   1185                                    no transmit request are pending for Tx mailboxes.      
   1186          
   1187             B. Receive Interrupts
   1188            -----------------------          
   1189                  CAN_IT_FMP0,
   1190                  CAN_IT_FMP1    :  FIFO 0 and FIFO1 message pending Interrupts
   1191                                    if enabled, these interrupt sources are pending when 
   1192                                    messages are pending in the receive FIFO.
   1193                                    The corresponding interrupt pending bits are cleared 
   1194                                    only by hardware.
   1195                          
   1196                  CAN_IT_FF0,              
   1197                  CAN_IT_FF1     :  FIFO 0 and FIFO1 full Interrupts
   1198                                    if enabled, these interrupt sources are pending when
   1199                                    three messages are stored in the selected FIFO.
   1200                  
   1201                  CAN_IT_FOV0,        
   1202                  CAN_IT_FOV1    :  FIFO 0 and FIFO1 overrun Interrupts        
   1203                                    if enabled, these interrupt sources are pending when
   1204                                    a new message has been received and passed the filter
   1205                                    while the FIFO was full.
   1206          
   1207             C. Operating Mode Interrupts
   1208            -------------------------------          
   1209                  CAN_IT_WKU     :  Wake-up Interrupt
   1210                                    if enabled, this interrupt source is pending when 
   1211                                    a SOF bit has been detected while the CAN hardware was 
   1212                                    in Sleep mode.
   1213                                            
   1214                  CAN_IT_SLK     :  Sleep acknowledge Interrupt
   1215                                    if enabled, this interrupt source is pending when 
   1216                                    the CAN has entered Sleep Mode.       
   1217          
   1218             D. Error Interrupts 
   1219            -----------------------         
   1220                  CAN_IT_EWG     :  Error warning Interrupt 
   1221                                    if enabled, this interrupt source is pending when
   1222                                    the warning limit has been reached (Receive Error 
   1223                                    Counter or Transmit Error Counter=96). 
   1224                                         
   1225                  CAN_IT_EPV     :  Error passive Interrupt        
   1226                                    if enabled, this interrupt source is pending when
   1227                                    the Error Passive limit has been reached (Receive 
   1228                                    Error Counter or Transmit Error Counter>127).
   1229                                    
   1230                  CAN_IT_BOF     :  Bus-off Interrupt
   1231                                    if enabled, this interrupt source is pending when
   1232                                    CAN enters the bus-off state. The bus-off state is 
   1233                                    entered on TEC overflow, greater than 255.
   1234                                    This Flag is cleared only by hardware.
   1235                                            
   1236                  CAN_IT_LEC     :  Last error code Interrupt        
   1237                                    if enabled, this interrupt source is pending  when
   1238                                    a message has been transferred (reception or
   1239                                    transmission) with error, and the error code is hold.
   1240                                    
   1241                  CAN_IT_ERR     :  Error Interrupt
   1242                                    if enabled, this interrupt source is pending when 
   1243                                    an error condition is pending.      
   1244                                
   1245          
   1246            Managing the CAN controller events :
   1247            ------------------------------------ 
   1248            The user should identify which mode will be used in his application to manage 
   1249            the CAN controller events: Polling mode or Interrupt mode.
   1250            
   1251            1.  In the Polling Mode it is advised to use the following functions:
   1252                - CAN_GetFlagStatus() : to check if flags events occur. 
   1253                - CAN_ClearFlag()     : to clear the flags events.
   1254            
   1255          
   1256            
   1257            2.  In the Interrupt Mode it is advised to use the following functions:
   1258                - CAN_ITConfig()       : to enable or disable the interrupt source.
   1259                - CAN_GetITStatus()    : to check if Interrupt occurs.
   1260                - CAN_ClearITPendingBit() : to clear the Interrupt pending Bit (corresponding Flag).
   1261                @note  This function has no impact on CAN_IT_FMP0 and CAN_IT_FMP1 Interrupts 
   1262                       pending bits since there are cleared only by hardware. 
   1263            
   1264          @endverbatim
   1265            * @{
   1266            */ 
   1267          /**
   1268            * @brief  Enables or disables the specified CANx interrupts.
   1269            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1270            * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
   1271            *          This parameter can be: 
   1272            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1273            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1274            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1275            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1276            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1277            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1278            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1279            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1280            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1281            *            @arg CAN_IT_EWG: Error warning Interrupt
   1282            *            @arg CAN_IT_EPV: Error passive Interrupt
   1283            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1284            *            @arg CAN_IT_LEC: Last error code Interrupt
   1285            *            @arg CAN_IT_ERR: Error Interrupt
   1286            * @param  NewState: new state of the CAN interrupts.
   1287            *          This parameter can be: ENABLE or DISABLE.
   1288            * @retval None
   1289            */
   1290          void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
   1291          {
   1292            /* Check the parameters */
   1293            //assert_param(IS_CAN_ALL_PERIPH(CANx));
   1294            //assert_param(IS_CAN_IT(CAN_IT));
   1295            //assert_param(IS_FUNCTIONAL_STATE(NewState));
   1296          
   1297            if (NewState != DISABLE)
   1298            {
   1299              /* Enable the selected CANx interrupt */
   1300              CANx->IER |= CAN_IT;
   1301            }
   1302            else
   1303            {
   1304              /* Disable the selected CANx interrupt */
   1305              CANx->IER &= ~CAN_IT;
   1306            }
   1307          }
   1308          /**
   1309            * @brief  Checks whether the specified CAN flag is set or not.
   1310            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1311            * @param  CAN_FLAG: specifies the flag to check.
   1312            *          This parameter can be one of the following values:
   1313            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1314            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1315            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag
   1316            *            @arg CAN_FLAG_FMP0: FIFO 0 Message Pending Flag   
   1317            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1318            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag 
   1319            *            @arg CAN_FLAG_FMP1: FIFO 1 Message Pending Flag   
   1320            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1321            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1322            *            @arg CAN_FLAG_WKU: Wake up Flag
   1323            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag 
   1324            *            @arg CAN_FLAG_EWG: Error Warning Flag
   1325            *            @arg CAN_FLAG_EPV: Error Passive Flag  
   1326            *            @arg CAN_FLAG_BOF: Bus-Off Flag    
   1327            *            @arg CAN_FLAG_LEC: Last error code Flag      
   1328            * @retval The new state of CAN_FLAG (SET or RESET).
   1329            */
   1330          FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1331          {
   1332            FlagStatus bitstatus = RESET;
   1333            
   1334            /* Check the parameters */
   1335            //assert_param(IS_CAN_ALL_PERIPH(CANx));
   1336            //assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
   1337            
   1338          
   1339            if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
   1340            { 
   1341              /* Check the status of the specified CAN flag */
   1342              if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1343              { 
   1344                /* CAN_FLAG is set */
   1345                bitstatus = SET;
   1346              }
   1347              else
   1348              { 
   1349                /* CAN_FLAG is reset */
   1350                bitstatus = RESET;
   1351              }
   1352            }
   1353            else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
   1354            { 
   1355              /* Check the status of the specified CAN flag */
   1356              if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1357              { 
   1358                /* CAN_FLAG is set */
   1359                bitstatus = SET;
   1360              }
   1361              else
   1362              { 
   1363                /* CAN_FLAG is reset */
   1364                bitstatus = RESET;
   1365              }
   1366            }
   1367            else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
   1368            { 
   1369              /* Check the status of the specified CAN flag */
   1370              if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1371              { 
   1372                /* CAN_FLAG is set */
   1373                bitstatus = SET;
   1374              }
   1375              else
   1376              { 
   1377                /* CAN_FLAG is reset */
   1378                bitstatus = RESET;
   1379              }
   1380            }
   1381            else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
   1382            { 
   1383              /* Check the status of the specified CAN flag */
   1384              if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1385              { 
   1386                /* CAN_FLAG is set */
   1387                bitstatus = SET;
   1388              }
   1389              else
   1390              { 
   1391                /* CAN_FLAG is reset */
   1392                bitstatus = RESET;
   1393              }
   1394            }
   1395            else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
   1396            { 
   1397              /* Check the status of the specified CAN flag */
   1398              if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1399              { 
   1400                /* CAN_FLAG is set */
   1401                bitstatus = SET;
   1402              }
   1403              else
   1404              { 
   1405                /* CAN_FLAG is reset */
   1406                bitstatus = RESET;
   1407              }
   1408            }
   1409            /* Return the CAN_FLAG status */
   1410            return  bitstatus;
   1411          }
   1412          
   1413          /**
   1414            * @brief  Clears the CAN's pending flags.
   1415            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1416            * @param  CAN_FLAG: specifies the flag to clear.
   1417            *          This parameter can be one of the following values:
   1418            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1419            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1420            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag 
   1421            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1422            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag  
   1423            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1424            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1425            *            @arg CAN_FLAG_WKU: Wake up Flag
   1426            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag    
   1427            *            @arg CAN_FLAG_LEC: Last error code Flag        
   1428            * @retval None
   1429            */
   1430          void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1431          {
   1432            uint32_t flagtmp=0;
   1433            /* Check the parameters */
   1434            //assert_param(IS_CAN_ALL_PERIPH(CANx));
   1435            //assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
   1436            
   1437            if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
   1438            {
   1439              /* Clear the selected CAN flags */
   1440              CANx->ESR = (uint32_t)RESET;
   1441            }
   1442            else /* MSR or TSR or RF0R or RF1R */
   1443            {
   1444              flagtmp = CAN_FLAG & 0x000FFFFF;
   1445          
   1446              if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
   1447              {
   1448                /* Receive Flags */
   1449                CANx->RF0R = (uint32_t)(flagtmp);
   1450              }
   1451              else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
   1452              {
   1453                /* Receive Flags */
   1454                CANx->RF1R = (uint32_t)(flagtmp);
   1455              }
   1456              else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
   1457              {
   1458                /* Transmit Flags */
   1459                CANx->TSR = (uint32_t)(flagtmp);
   1460              }
   1461              else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
   1462              {
   1463                /* Operating mode Flags */
   1464                CANx->MSR = (uint32_t)(flagtmp);
   1465              }
   1466            }
   1467          }
   1468          
   1469          /**
   1470            * @brief  Checks whether the specified CANx interrupt has occurred or not.
   1471            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1472            * @param  CAN_IT: specifies the CAN interrupt source to check.
   1473            *          This parameter can be one of the following values:
   1474            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1475            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1476            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1477            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1478            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1479            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1480            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1481            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1482            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1483            *            @arg CAN_IT_EWG: Error warning Interrupt
   1484            *            @arg CAN_IT_EPV: Error passive Interrupt
   1485            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1486            *            @arg CAN_IT_LEC: Last error code Interrupt
   1487            *            @arg CAN_IT_ERR: Error Interrupt
   1488            * @retval The current state of CAN_IT (SET or RESET).
   1489            */
   1490          ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1491          {
   1492            ITStatus itstatus = RESET;
   1493            /* Check the parameters */
   1494            //assert_param(IS_CAN_ALL_PERIPH(CANx));
   1495            //assert_param(IS_CAN_IT(CAN_IT));
   1496            
   1497            /* check the interrupt enable bit */
   1498           if((CANx->IER & CAN_IT) != RESET)
   1499           {
   1500             /* in case the Interrupt is enabled, .... */
   1501              switch (CAN_IT)
   1502              {
   1503                case CAN_IT_TME:
   1504                  /* Check CAN_TSR_RQCPx bits */
   1505                  itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
   1506                  break;
   1507                case CAN_IT_FMP0:
   1508                  /* Check CAN_RF0R_FMP0 bit */
   1509                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
   1510                  break;
   1511                case CAN_IT_FF0:
   1512                  /* Check CAN_RF0R_FULL0 bit */
   1513                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
   1514                  break;
   1515                case CAN_IT_FOV0:
   1516                  /* Check CAN_RF0R_FOVR0 bit */
   1517                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
   1518                  break;
   1519                case CAN_IT_FMP1:
   1520                  /* Check CAN_RF1R_FMP1 bit */
   1521                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
   1522                  break;
   1523                case CAN_IT_FF1:
   1524                  /* Check CAN_RF1R_FULL1 bit */
   1525                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
   1526                  break;
   1527                case CAN_IT_FOV1:
   1528                  /* Check CAN_RF1R_FOVR1 bit */
   1529                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
   1530                  break;
   1531                case CAN_IT_WKU:
   1532                  /* Check CAN_MSR_WKUI bit */
   1533                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
   1534                  break;
   1535                case CAN_IT_SLK:
   1536                  /* Check CAN_MSR_SLAKI bit */
   1537                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
   1538                  break;
   1539                case CAN_IT_EWG:
   1540                  /* Check CAN_ESR_EWGF bit */
   1541                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
   1542                  break;
   1543                case CAN_IT_EPV:
   1544                  /* Check CAN_ESR_EPVF bit */
   1545                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
   1546                  break;
   1547                case CAN_IT_BOF:
   1548                  /* Check CAN_ESR_BOFF bit */
   1549                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
   1550                  break;
   1551                case CAN_IT_LEC:
   1552                  /* Check CAN_ESR_LEC bit */
   1553                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
   1554                  break;
   1555                case CAN_IT_ERR:
   1556                  /* Check CAN_MSR_ERRI bit */ 
   1557                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
   1558                  break;
   1559                default:
   1560                  /* in case of error, return RESET */
   1561                  itstatus = RESET;
   1562                  break;
   1563              }
   1564            }
   1565            else
   1566            {
   1567             /* in case the Interrupt is not enabled, return RESET */
   1568              itstatus  = RESET;
   1569            }
   1570            
   1571            /* Return the CAN_IT status */
   1572            return  itstatus;
   1573          }
   1574          
   1575          /**
   1576            * @brief  Clears the CANx's interrupt pending bits.
   1577            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1578            * @param  CAN_IT: specifies the interrupt pending bit to clear.
   1579            *          This parameter can be one of the following values:
   1580            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt
   1581            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1582            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1583            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1584            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1585            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1586            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1587            *            @arg CAN_IT_EWG: Error warning Interrupt
   1588            *            @arg CAN_IT_EPV: Error passive Interrupt
   1589            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1590            *            @arg CAN_IT_LEC: Last error code Interrupt
   1591            *            @arg CAN_IT_ERR: Error Interrupt 
   1592            * @retval None
   1593            */
   1594          void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1595          {
   1596            /* Check the parameters */
   1597            ///assert_param(IS_CAN_ALL_PERIPH(CANx));
   1598            //assert_param(IS_CAN_CLEAR_IT(CAN_IT));
   1599          
   1600            switch (CAN_IT)
   1601            {
   1602              case CAN_IT_TME:
   1603                /* Clear CAN_TSR_RQCPx (rc_w1)*/
   1604                CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
   1605                break;
   1606              case CAN_IT_FF0:
   1607                /* Clear CAN_RF0R_FULL0 (rc_w1)*/
   1608                CANx->RF0R = CAN_RF0R_FULL0; 
   1609                break;
   1610              case CAN_IT_FOV0:
   1611                /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
   1612                CANx->RF0R = CAN_RF0R_FOVR0; 
   1613                break;
   1614              case CAN_IT_FF1:
   1615                /* Clear CAN_RF1R_FULL1 (rc_w1)*/
   1616                CANx->RF1R = CAN_RF1R_FULL1;  
   1617                break;
   1618              case CAN_IT_FOV1:
   1619                /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
   1620                CANx->RF1R = CAN_RF1R_FOVR1; 
   1621                break;
   1622              case CAN_IT_WKU:
   1623                /* Clear CAN_MSR_WKUI (rc_w1)*/
   1624                CANx->MSR = CAN_MSR_WKUI;  
   1625                break;
   1626              case CAN_IT_SLK:
   1627                /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
   1628                CANx->MSR = CAN_MSR_SLAKI;   
   1629                break;
   1630              case CAN_IT_EWG:
   1631                /* Clear CAN_MSR_ERRI (rc_w1) */
   1632                CANx->MSR = CAN_MSR_ERRI;
   1633                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
   1634                break;
   1635              case CAN_IT_EPV:
   1636                /* Clear CAN_MSR_ERRI (rc_w1) */
   1637                CANx->MSR = CAN_MSR_ERRI; 
   1638                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1639                break;
   1640              case CAN_IT_BOF:
   1641                /* Clear CAN_MSR_ERRI (rc_w1) */ 
   1642                CANx->MSR = CAN_MSR_ERRI; 
   1643                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1644                 break;
   1645              case CAN_IT_LEC:
   1646                /*  Clear LEC bits */
   1647                CANx->ESR = RESET; 
   1648                /* Clear CAN_MSR_ERRI (rc_w1) */
   1649                CANx->MSR = CAN_MSR_ERRI; 
   1650                break;
   1651              case CAN_IT_ERR:
   1652                /*Clear LEC bits */
   1653                CANx->ESR = RESET; 
   1654                /* Clear CAN_MSR_ERRI (rc_w1) */
   1655                CANx->MSR = CAN_MSR_ERRI; 
   1656                 /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
   1657                 break;
   1658              default:
   1659                 break;
   1660             }
   1661          }
   1662           /**
   1663            * @}
   1664            */
   1665          
   1666          /**
   1667            * @brief  Checks whether the CAN interrupt has occurred or not.
   1668            * @param  CAN_Reg: specifies the CAN interrupt register to check.
   1669            * @param  It_Bit: specifies the interrupt source bit to check.
   1670            * @retval The new state of the CAN Interrupt (SET or RESET).
   1671            */
   1672          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
   1673          {
   1674            ITStatus pendingbitstatus = RESET;
   1675            
   1676            if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
   1677            {
   1678              /* CAN_IT is set */
   1679              pendingbitstatus = SET;
   1680            }
   1681            else
   1682            {
   1683              /* CAN_IT is reset */
   1684              pendingbitstatus = RESET;
   1685            }
   1686            return pendingbitstatus;
   1687          }
   1688          
   1689          /**
   1690            * @}
   1691            */
   1692          
   1693          /**
   1694            * @}
   1695            */
   1696          
   1697          /**
   1698            * @}
   1699            */
   1700          
   1701          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     CAN_CancelTransmit                  0
     CAN_ClearFlag                       0
     CAN_ClearITPendingBit               0
     CAN_DBGFreeze                       0
     CAN_DeInit                          8
     CAN_FIFORelease                     0
     CAN_FilterInit                      4
     CAN_GetFlagStatus                   0
     CAN_GetITStatus                    16
     CAN_GetLSBTransmitErrorCounter      0
     CAN_GetLastErrorCode                0
     CAN_GetReceiveErrorCounter          0
     CAN_ITConfig                        0
     CAN_Init                            8
     CAN_MessagePending                  0
     CAN_OperatingModeRequest            4
     CAN_Receive                         0
     CAN_SlaveStartBank                  0
     CAN_Sleep                           0
     CAN_StructInit                      0
     CAN_TTComModeCmd                    0
     CAN_Transmit                        8
     CAN_TransmitStatus                  4
     CAN_WakeUp                          0
     CheckITStatus                       0


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     CAN_DeInit                       56
     CAN_Init                        280
     CAN_FilterInit                  274
     CAN_StructInit                   46
     CAN_SlaveStartBank               70
     CAN_DBGFreeze                    26
     CAN_TTComModeCmd                104
     CAN_Transmit                    294
     CAN_TransmitStatus              164
     CAN_CancelTransmit               46
     CAN_Receive                     232
     CAN_FIFORelease                  26
     CAN_MessagePending               44
     CAN_OperatingModeRequest        190
     CAN_Sleep                        34
     CAN_WakeUp                       44
     CAN_GetLastErrorCode             16
     CAN_GetReceiveErrorCounter       14
     CAN_GetLSBTransmitErrorCounter   14
     CAN_ITConfig                     22
     CAN_GetFlagStatus               124
     CAN_ClearFlag                    48
     CAN_GetITStatus                 272
     CAN_ClearITPendingBit           148
     CheckITStatus                    22
     ??DataTable6                      4
     ??DataTable6_1                    4
     ??DataTable6_2                    4
     ??DataTable6_3                    4
     ??DataTable6_4                    4
     ??DataTable6_5                    4
     ??DataTable6_6                    4
     ??DataTable6_7                    4
     ??DataTable6_8                    4
     ??DataTable6_9                    4
     ??DataTable6_10                   4
     ??DataTable6_11                   4
     ??DataTable6_12                   4
     ??DataTable6_13                   4
     ??DataTable6_14                   4
     ??DataTable6_15                   4

 
 2 674 bytes in section .text
 
 2 674 bytes of CODE memory

Errors: none
Warnings: none
