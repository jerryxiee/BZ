###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     22/May/2012  09:34:56 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\STM32 #
#                    F10x_StdPeriph_Driver\src\stm32f10x_flash.c              #
#    Command line =  D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\STM32 #
#                    F10x_StdPeriph_Driver\src\stm32f10x_flash.c -D           #
#                    STM32F10X_CL -D USE_STDPERIPH_DRIVER -lcN                #
#                    D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\EWARM #
#                    \Debug\List\ -o D:\work\行标产品\一体机\程序\STM32_Boot\ #
#                    STM32_Boot\EWARM\Debug\Obj\ --debug --endian=little      #
#                    --cpu=Cortex-M3 -e --warnings_are_errors --fpu=None      #
#                    --dlib_config "E:\sofewareinstall\IAR                    #
#                    Systems\arm\INC\c\DLib_Config_Normal.h" -I               #
#                    D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\EWARM #
#                    \..\inc\ -I D:\work\行标产品\一体机\程序\STM32_Boot\STM3 #
#                    2_Boot\EWARM\..\CMSIS\Core\CM3\ -I                       #
#                    D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\EWARM #
#                    \..\STM32F10x_StdPeriph_Driver\inc\ -I                   #
#                    D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\EWARM #
#                    \..\..\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\STM32F10 #
#                    x_StdPeriph_Driver\inc\ -I D:\work\行标产品\一体机\程序\ #
#                    STM32_Boot\STM32_Boot\EWARM\..\..\STM32F10x_StdPeriph_Li #
#                    b_V3.5.0\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\ #
#                     -I D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\E #
#                    WARM\..\..\STM32F10x_StdPeriph_Lib_V3.5.0\Libraries\CMSI #
#                    S\CM3\CoreSupport\ -Oh --use_c++_inline                  #
#    List file    =  D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\EWARM #
#                    \Debug\List\stm32f10x_flash.lst                          #
#    Object file  =  D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\EWARM #
#                    \Debug\Obj\stm32f10x_flash.o                             #
#                                                                             #
#                                                                             #
###############################################################################

D:\work\行标产品\一体机\程序\STM32_Boot\STM32_Boot\STM32F10x_StdPeriph_Driver\src\stm32f10x_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_flash.c
      4            * @author  MCD Application Team
      5            * @version V3.1.0
      6            * @date    06/19/2009
      7            * @brief   This file provides all the FLASH firmware functions.
      8            ******************************************************************************
      9            * @copy
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2009 STMicroelectronics</center></h2>
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm32f10x_flash.h"
     23          
     24          /** @addtogroup STM32F10x_StdPeriph_Driver
     25            * @{
     26            */
     27          
     28          /** @defgroup FLASH 
     29            * @brief FLASH driver modules
     30            * @{
     31            */ 
     32          
     33          /** @defgroup FLASH_Private_TypesDefinitions
     34            * @{
     35            */
     36          
     37          /**
     38            * @}
     39            */ 
     40          
     41          /** @defgroup FLASH_Private_Defines
     42            * @{
     43            */ 
     44          
     45          /* Flash Access Control Register bits */
     46          #define ACR_LATENCY_Mask         ((uint32_t)0x00000038)
     47          #define ACR_HLFCYA_Mask          ((uint32_t)0xFFFFFFF7)
     48          #define ACR_PRFTBE_Mask          ((uint32_t)0xFFFFFFEF)
     49          
     50          /* Flash Access Control Register bits */
     51          #define ACR_PRFTBS_Mask          ((uint32_t)0x00000020) 
     52          
     53          /* Flash Control Register bits */
     54          #define CR_PG_Set                ((uint32_t)0x00000001)
     55          #define CR_PG_Reset              ((uint32_t)0x00001FFE) 
     56          #define CR_PER_Set               ((uint32_t)0x00000002)
     57          #define CR_PER_Reset             ((uint32_t)0x00001FFD)
     58          #define CR_MER_Set               ((uint32_t)0x00000004)
     59          #define CR_MER_Reset             ((uint32_t)0x00001FFB)
     60          #define CR_OPTPG_Set             ((uint32_t)0x00000010)
     61          #define CR_OPTPG_Reset           ((uint32_t)0x00001FEF)
     62          #define CR_OPTER_Set             ((uint32_t)0x00000020)
     63          #define CR_OPTER_Reset           ((uint32_t)0x00001FDF)
     64          #define CR_STRT_Set              ((uint32_t)0x00000040)
     65          #define CR_LOCK_Set              ((uint32_t)0x00000080)
     66          
     67          /* FLASH Mask */
     68          #define RDPRT_Mask               ((uint32_t)0x00000002)
     69          #define WRP0_Mask                ((uint32_t)0x000000FF)
     70          #define WRP1_Mask                ((uint32_t)0x0000FF00)
     71          #define WRP2_Mask                ((uint32_t)0x00FF0000)
     72          #define WRP3_Mask                ((uint32_t)0xFF000000)
     73          
     74          /* FLASH Keys */
     75          #define RDP_Key                  ((uint16_t)0x00A5)
     76          #define FLASH_KEY1               ((uint32_t)0x45670123)
     77          #define FLASH_KEY2               ((uint32_t)0xCDEF89AB)
     78          
     79          /* Delay definition */   
     80          #define EraseTimeout             ((uint32_t)0x00000FFF)
     81          #define ProgramTimeout           ((uint32_t)0x0000000F)
     82          
     83          /**
     84            * @}
     85            */ 
     86          
     87          /** @defgroup FLASH_Private_Macros
     88            * @{
     89            */
     90          
     91          /**
     92            * @}
     93            */ 
     94          
     95          /** @defgroup FLASH_Private_Variables
     96            * @{
     97            */
     98          
     99          /**
    100            * @}
    101            */ 
    102          
    103          /** @defgroup FLASH_Private_FunctionPrototypes
    104            * @{
    105            */
    106          
    107          static void delay(void);
    108          /**
    109            * @}
    110            */
    111          
    112          /** @defgroup FLASH_Private_Functions
    113            * @{
    114            */
    115          
    116          /**
    117            * @brief  Sets the code latency value.
    118            * @param  FLASH_Latency: specifies the FLASH Latency value.
    119            *   This parameter can be one of the following values:
    120            *     @arg FLASH_Latency_0: FLASH Zero Latency cycle
    121            *     @arg FLASH_Latency_1: FLASH One Latency cycle
    122            *     @arg FLASH_Latency_2: FLASH Two Latency cycles
    123            * @retval None
    124            */
    125          void FLASH_SetLatency(uint32_t FLASH_Latency)
    126          {
    127            uint32_t tmpreg = 0;
    128            
    129            /* Check the parameters */
    130            //assert_param(IS_FLASH_LATENCY(FLASH_Latency));
    131            
    132            /* Read the ACR register */
    133            tmpreg = FLASH->ACR;  
    134            
    135            /* Sets the Latency value */
    136            tmpreg &= ACR_LATENCY_Mask;
    137            tmpreg |= FLASH_Latency;
    138            
    139            /* Write the ACR register */
    140            FLASH->ACR = tmpreg;
    141          }
    142          
    143          /**
    144            * @brief  Enables or disables the Half cycle flash access.
    145            * @param  FLASH_HalfCycleAccess: specifies the FLASH Half cycle Access mode.
    146            *   This parameter can be one of the following values:
    147            *     @arg FLASH_HalfCycleAccess_Enable: FLASH Half Cycle Enable
    148            *     @arg FLASH_HalfCycleAccess_Disable: FLASH Half Cycle Disable
    149            * @retval None
    150            */
    151          void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
    152          {
    153            /* Check the parameters */
    154            //assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
    155            
    156            /* Enable or disable the Half cycle access */
    157            FLASH->ACR &= ACR_HLFCYA_Mask;
    158            FLASH->ACR |= FLASH_HalfCycleAccess;
    159          }
    160          
    161          /**
    162            * @brief  Enables or disables the Prefetch Buffer.
    163            * @param  FLASH_PrefetchBuffer: specifies the Prefetch buffer status.
    164            *   This parameter can be one of the following values:
    165            *     @arg FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable
    166            *     @arg FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable
    167            * @retval None
    168            */
    169          void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
    170          {
    171            /* Check the parameters */
    172            //assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
    173            
    174            /* Enable or disable the Prefetch Buffer */
    175            FLASH->ACR &= ACR_PRFTBE_Mask;
    176            FLASH->ACR |= FLASH_PrefetchBuffer;
    177          }
    178          
    179          /**
    180            * @brief  Unlocks the FLASH Program Erase Controller.
    181            * @param  None
    182            * @retval None
    183            */
    184          void FLASH_Unlock(void)
    185          {
    186            /* Authorize the FPEC Access */
    187            FLASH->KEYR = FLASH_KEY1;
    188            FLASH->KEYR = FLASH_KEY2;
    189          }
    190          
    191          /**
    192            * @brief  Locks the FLASH Program Erase Controller.
    193            * @param  None
    194            * @retval None
    195            */
    196          void FLASH_Lock(void)
    197          {
    198            /* Set the Lock Bit to lock the FPEC and the FCR */
    199            FLASH->CR |= CR_LOCK_Set;
    200          }
    201          
    202          /**
    203            * @brief  Erases a specified FLASH page.
    204            * @param  Page_Address: The page address to be erased.
    205            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
    206            *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    207            */
    208          FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
    209          {
    210            FLASH_Status status = FLASH_COMPLETE;
    211            /* Check the parameters */
    212            //assert_param(IS_FLASH_ADDRESS(Page_Address));
    213            /* Wait for last operation to be completed */
    214            status = FLASH_WaitForLastOperation(EraseTimeout);
    215            
    216            if(status == FLASH_COMPLETE)
    217            { 
    218              /* if the previous operation is completed, proceed to erase the page */
    219              FLASH->CR|= CR_PER_Set;
    220              FLASH->AR = Page_Address; 
    221              FLASH->CR|= CR_STRT_Set;
    222              
    223              /* Wait for last operation to be completed */
    224              status = FLASH_WaitForLastOperation(EraseTimeout);
    225              if(status != FLASH_TIMEOUT)
    226              {
    227                /* if the erase operation is completed, disable the PER Bit */
    228                FLASH->CR &= CR_PER_Reset;
    229              }
    230            }
    231            /* Return the Erase Status */
    232            return status;
    233          }
    234          
    235          /**
    236            * @brief  Erases all FLASH pages.
    237            * @param  None
    238            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    239            *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    240            */
    241          FLASH_Status FLASH_EraseAllPages(void)
    242          {
    243            FLASH_Status status = FLASH_COMPLETE;
    244            /* Wait for last operation to be completed */
    245            status = FLASH_WaitForLastOperation(EraseTimeout);
    246            
    247            if(status == FLASH_COMPLETE)
    248            {
    249              /* if the previous operation is completed, proceed to erase all pages */
    250               FLASH->CR |= CR_MER_Set;
    251               FLASH->CR |= CR_STRT_Set;
    252              
    253              /* Wait for last operation to be completed */
    254              status = FLASH_WaitForLastOperation(EraseTimeout);
    255              if(status != FLASH_TIMEOUT)
    256              {
    257                /* if the erase operation is completed, disable the MER Bit */
    258                FLASH->CR &= CR_MER_Reset;
    259              }
    260            }	   
    261            /* Return the Erase Status */
    262            return status;
    263          }
    264          
    265          /**
    266            * @brief  Erases the FLASH option bytes.
    267            * @param  None
    268            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    269            *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    270            */
    271          FLASH_Status FLASH_EraseOptionBytes(void)
    272          {
    273            FLASH_Status status = FLASH_COMPLETE;
    274            
    275            /* Wait for last operation to be completed */
    276            status = FLASH_WaitForLastOperation(EraseTimeout);
    277            if(status == FLASH_COMPLETE)
    278            {
    279              /* Authorize the small information block programming */
    280              FLASH->OPTKEYR = FLASH_KEY1;
    281              FLASH->OPTKEYR = FLASH_KEY2;
    282              
    283              /* if the previous operation is completed, proceed to erase the option bytes */
    284              FLASH->CR |= CR_OPTER_Set;
    285              FLASH->CR |= CR_STRT_Set;
    286              /* Wait for last operation to be completed */
    287              status = FLASH_WaitForLastOperation(EraseTimeout);
    288              
    289              if(status == FLASH_COMPLETE)
    290              {
    291                /* if the erase operation is completed, disable the OPTER Bit */
    292                FLASH->CR &= CR_OPTER_Reset;
    293                 
    294                /* Enable the Option Bytes Programming operation */
    295                FLASH->CR |= CR_OPTPG_Set;
    296                /* Enable the readout access */
    297                OB->RDP= RDP_Key; 
    298                /* Wait for last operation to be completed */
    299                status = FLASH_WaitForLastOperation(ProgramTimeout);
    300           
    301                if(status != FLASH_TIMEOUT)
    302                {
    303                  /* if the program operation is completed, disable the OPTPG Bit */
    304                  FLASH->CR &= CR_OPTPG_Reset;
    305                }
    306              }
    307              else
    308              {
    309                if (status != FLASH_TIMEOUT)
    310                {
    311                  /* Disable the OPTPG Bit */
    312                  FLASH->CR &= CR_OPTPG_Reset;
    313                }
    314              }  
    315            }
    316            /* Return the erase status */
    317            return status;
    318          }
    319          
    320          /**
    321            * @brief  Programs a word at a specified address.
    322            * @param  Address: specifies the address to be programmed.
    323            * @param  Data: specifies the data to be programmed.
    324            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    325            *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    326            */
    327          FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    328          {
    329            FLASH_Status status = FLASH_COMPLETE;
    330            __IO uint32_t tmp = 0;
    331          
    332            /* Check the parameters */
    333            //assert_param(IS_FLASH_ADDRESS(Address));
    334            /* Wait for last operation to be completed */
    335            status = FLASH_WaitForLastOperation(ProgramTimeout);
    336            
    337            if(status == FLASH_COMPLETE)
    338            {
    339              /* if the previous operation is completed, proceed to program the new first 
    340              half word */
    341              FLASH->CR |= CR_PG_Set;
    342            
    343              *(__IO uint16_t*)Address = (uint16_t)Data;
    344              /* Wait for last operation to be completed */
    345              status = FLASH_WaitForLastOperation(ProgramTimeout);
    346           
    347              if(status == FLASH_COMPLETE)
    348              {
    349                /* if the previous operation is completed, proceed to program the new second 
    350                half word */
    351                tmp = Address + 2;
    352          
    353                *(__IO uint16_t*) tmp = Data >> 16;
    354              
    355                /* Wait for last operation to be completed */
    356                status = FLASH_WaitForLastOperation(ProgramTimeout);
    357                  
    358                if(status != FLASH_TIMEOUT)
    359                {
    360                  /* Disable the PG Bit */
    361                  FLASH->CR &= CR_PG_Reset;
    362                }
    363              }
    364              else
    365              {
    366                if (status != FLASH_TIMEOUT)
    367                {
    368                  /* Disable the PG Bit */
    369                  FLASH->CR &= CR_PG_Reset;
    370                }
    371               }
    372            }
    373            /* Return the Program Status */
    374            return status;
    375          }
    376          
    377          /**
    378            * @brief  Programs a half word at a specified address.
    379            * @param  Address: specifies the address to be programmed.
    380            * @param  Data: specifies the data to be programmed.
    381            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    382            *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    383            */
    384          FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    385          {
    386            FLASH_Status status = FLASH_COMPLETE;
    387            /* Check the parameters */
    388            //assert_param(IS_FLASH_ADDRESS(Address));
    389            /* Wait for last operation to be completed */
    390            status = FLASH_WaitForLastOperation(ProgramTimeout);
    391            
    392            if(status == FLASH_COMPLETE)
    393            {
    394              /* if the previous operation is completed, proceed to program the new data */
    395              FLASH->CR |= CR_PG_Set;
    396            
    397              *(__IO uint16_t*)Address = Data;
    398              /* Wait for last operation to be completed */
    399              status = FLASH_WaitForLastOperation(ProgramTimeout);
    400              if(status != FLASH_TIMEOUT)
    401              {
    402                /* if the program operation is completed, disable the PG Bit */
    403                FLASH->CR &= CR_PG_Reset;
    404              }
    405            } 
    406            /* Return the Program Status */
    407            return status;
    408          }
    409          
    410          /**
    411            * @brief  Programs a half word at a specified Option Byte Data address.
    412            * @param  Address: specifies the address to be programmed.
    413            *   This parameter can be 0x1FFFF804 or 0x1FFFF806. 
    414            * @param  Data: specifies the data to be programmed.
    415            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    416            *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT. 
    417            */
    418          FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
    419          {
    420            FLASH_Status status = FLASH_COMPLETE;
    421            /* Check the parameters */
    422            //assert_param(IS_OB_DATA_ADDRESS(Address));
    423            status = FLASH_WaitForLastOperation(ProgramTimeout);
    424            if(status == FLASH_COMPLETE)
    425            {
    426              /* Authorize the small information block programming */
    427              FLASH->OPTKEYR = FLASH_KEY1;
    428              FLASH->OPTKEYR = FLASH_KEY2;
    429              /* Enables the Option Bytes Programming operation */
    430              FLASH->CR |= CR_OPTPG_Set; 
    431              *(__IO uint16_t*)Address = Data;
    432              
    433              /* Wait for last operation to be completed */
    434              status = FLASH_WaitForLastOperation(ProgramTimeout);
    435              if(status != FLASH_TIMEOUT)
    436              {
    437                /* if the program operation is completed, disable the OPTPG Bit */
    438                FLASH->CR &= CR_OPTPG_Reset;
    439              }
    440            }    
    441            /* Return the Option Byte Data Program Status */
    442            return status;
    443          }
    444          
    445          /**
    446            * @brief  Write protects the desired pages
    447            * @param  FLASH_Pages: specifies the address of the pages to be write protected.
    448            *   This parameter can be:
    449            *     @arg For @b STM32_Low-density_devices: value between FLASH_WRProt_Pages0to3 and FLASH_WRProt_Pages28to31  
    450            *     @arg For @b STM32_Medium-density_devices: value between FLASH_WRProt_Pages0to3
    451            *       and FLASH_WRProt_Pages124to127
    452            *     @arg For @b STM32_High-density_devices: value between FLASH_WRProt_Pages0to1 and
    453            *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to255
    454            *     @arg For @b STM32_Connectivity_line_devices: value between FLASH_WRProt_Pages0to1 and
    455            *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to127    
    456            *     @arg FLASH_WRProt_AllPages
    457            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    458            *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    459            */
    460          FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
    461          {
    462            uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
    463            
    464            FLASH_Status status = FLASH_COMPLETE;
    465            
    466            /* Check the parameters */
    467            //assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
    468            
    469            FLASH_Pages = (uint32_t)(~FLASH_Pages);
    470            WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
    471            WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
    472            WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
    473            WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
    474            
    475            /* Wait for last operation to be completed */
    476            status = FLASH_WaitForLastOperation(ProgramTimeout);
    477            
    478            if(status == FLASH_COMPLETE)
    479            {
    480              /* Authorizes the small information block programming */
    481              FLASH->OPTKEYR = FLASH_KEY1;
    482              FLASH->OPTKEYR = FLASH_KEY2;
    483              FLASH->CR |= CR_OPTPG_Set;
    484              if(WRP0_Data != 0xFF)
    485              {
    486                OB->WRP0 = WRP0_Data;
    487                
    488                /* Wait for last operation to be completed */
    489                status = FLASH_WaitForLastOperation(ProgramTimeout);
    490              }
    491              if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
    492              {
    493                OB->WRP1 = WRP1_Data;
    494                
    495                /* Wait for last operation to be completed */
    496                status = FLASH_WaitForLastOperation(ProgramTimeout);
    497              }
    498              if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
    499              {
    500                OB->WRP2 = WRP2_Data;
    501                
    502                /* Wait for last operation to be completed */
    503                status = FLASH_WaitForLastOperation(ProgramTimeout);
    504              }
    505              
    506              if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
    507              {
    508                OB->WRP3 = WRP3_Data;
    509               
    510                /* Wait for last operation to be completed */
    511                status = FLASH_WaitForLastOperation(ProgramTimeout);
    512              }
    513                    
    514              if(status != FLASH_TIMEOUT)
    515              {
    516                /* if the program operation is completed, disable the OPTPG Bit */
    517                FLASH->CR &= CR_OPTPG_Reset;
    518              }
    519            } 
    520            /* Return the write protection operation Status */
    521            return status;       
    522          }
    523          
    524          /**
    525            * @brief  Enables or disables the read out protection.
    526            * @note   If the user has already programmed the other option bytes before calling 
    527            *   this function, he must re-program them since this function erases all option bytes.
    528            * @param  Newstate: new state of the ReadOut Protection.
    529            *   This parameter can be: ENABLE or DISABLE.
    530            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    531            *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    532            */
    533          FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
    534          {
    535            FLASH_Status status = FLASH_COMPLETE;
    536            /* Check the parameters */
    537            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    538            status = FLASH_WaitForLastOperation(EraseTimeout);
    539            if(status == FLASH_COMPLETE)
    540            {
    541              /* Authorizes the small information block programming */
    542              FLASH->OPTKEYR = FLASH_KEY1;
    543              FLASH->OPTKEYR = FLASH_KEY2;
    544              FLASH->CR |= CR_OPTER_Set;
    545              FLASH->CR |= CR_STRT_Set;
    546              /* Wait for last operation to be completed */
    547              status = FLASH_WaitForLastOperation(EraseTimeout);
    548              if(status == FLASH_COMPLETE)
    549              {
    550                /* if the erase operation is completed, disable the OPTER Bit */
    551                FLASH->CR &= CR_OPTER_Reset;
    552                /* Enable the Option Bytes Programming operation */
    553                FLASH->CR |= CR_OPTPG_Set; 
    554                if(NewState != DISABLE)
    555                {
    556                  OB->RDP = 0x00;
    557                }
    558                else
    559                {
    560                  OB->RDP = RDP_Key;  
    561                }
    562                /* Wait for last operation to be completed */
    563                status = FLASH_WaitForLastOperation(EraseTimeout); 
    564              
    565                if(status != FLASH_TIMEOUT)
    566                {
    567                  /* if the program operation is completed, disable the OPTPG Bit */
    568                  FLASH->CR &= CR_OPTPG_Reset;
    569                }
    570              }
    571              else 
    572              {
    573                if(status != FLASH_TIMEOUT)
    574                {
    575                  /* Disable the OPTER Bit */
    576                  FLASH->CR &= CR_OPTER_Reset;
    577                }
    578              }
    579            }
    580            /* Return the protection operation Status */
    581            return status;      
    582          }
    583          
    584          /**
    585            * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.
    586            * @param  OB_IWDG: Selects the IWDG mode
    587            *   This parameter can be one of the following values:
    588            *     @arg OB_IWDG_SW: Software IWDG selected
    589            *     @arg OB_IWDG_HW: Hardware IWDG selected
    590            * @param  OB_STOP: Reset event when entering STOP mode.
    591            *   This parameter can be one of the following values:
    592            *     @arg OB_STOP_NoRST: No reset generated when entering in STOP
    593            *     @arg OB_STOP_RST: Reset generated when entering in STOP
    594            * @param  OB_STDBY: Reset event when entering Standby mode.
    595            *   This parameter can be one of the following values:
    596            *     @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
    597            *     @arg OB_STDBY_RST: Reset generated when entering in STANDBY
    598            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG, 
    599            * FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    600            */
    601          FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
    602          {
    603            FLASH_Status status = FLASH_COMPLETE; 
    604          
    605            /* Check the parameters */
    606            //assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
    607            //assert_param(IS_OB_STOP_SOURCE(OB_STOP));
    608            //assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
    609          
    610            /* Authorize the small information block programming */
    611            FLASH->OPTKEYR = FLASH_KEY1;
    612            FLASH->OPTKEYR = FLASH_KEY2;
    613            
    614            /* Wait for last operation to be completed */
    615            status = FLASH_WaitForLastOperation(ProgramTimeout);
    616            
    617            if(status == FLASH_COMPLETE)
    618            {  
    619              /* Enable the Option Bytes Programming operation */
    620              FLASH->CR |= CR_OPTPG_Set; 
    621                     
    622              OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
    623            
    624              /* Wait for last operation to be completed */
    625              status = FLASH_WaitForLastOperation(ProgramTimeout);
    626              if(status != FLASH_TIMEOUT)
    627              {
    628                /* if the program operation is completed, disable the OPTPG Bit */
    629                FLASH->CR &= CR_OPTPG_Reset;
    630              }
    631            }    
    632            /* Return the Option Byte program Status */
    633            return status;
    634          }
    635          
    636          /**
    637            * @brief  Returns the FLASH User Option Bytes values.
    638            * @param  None
    639            * @retval The FLASH User Option Bytes values:IWDG_SW(Bit0), RST_STOP(Bit1)
    640            *   and RST_STDBY(Bit2).
    641            */
    642          uint32_t FLASH_GetUserOptionByte(void)
    643          {
    644            /* Return the User Option Byte */
    645            return (uint32_t)(FLASH->OBR >> 2);
    646          }
    647          
    648          /**
    649            * @brief  Returns the FLASH Write Protection Option Bytes Register value.
    650            * @param  None
    651            * @retval The FLASH Write Protection  Option Bytes Register value
    652            */
    653          uint32_t FLASH_GetWriteProtectionOptionByte(void)
    654          {
    655            /* Return the Falsh write protection Register value */
    656            return (uint32_t)(FLASH->WRPR);
    657          }
    658          
    659          /**
    660            * @brief  Checks whether the FLASH Read Out Protection Status is set or not.
    661            * @param  None
    662            * @retval FLASH ReadOut Protection Status(SET or RESET)
    663            */
    664          FlagStatus FLASH_GetReadOutProtectionStatus(void)
    665          {
    666            FlagStatus readoutstatus = RESET;
    667            if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
    668            {
    669              readoutstatus = SET;
    670            }
    671            else
    672            {
    673              readoutstatus = RESET;
    674            }
    675            return readoutstatus;
    676          }
    677          
    678          /**
    679            * @brief  Checks whether the FLASH Prefetch Buffer status is set or not.
    680            * @param  None
    681            * @retval FLASH Prefetch Buffer Status (SET or RESET).
    682            */
    683          FlagStatus FLASH_GetPrefetchBufferStatus(void)
    684          {
    685            FlagStatus bitstatus = RESET;
    686            
    687            if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
    688            {
    689              bitstatus = SET;
    690            }
    691            else
    692            {
    693              bitstatus = RESET;
    694            }
    695            /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
    696            return bitstatus; 
    697          }
    698          
    699          /**
    700            * @brief  Enables or disables the specified FLASH interrupts.
    701            * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or disabled.
    702            *   This parameter can be any combination of the following values:
    703            *     @arg FLASH_IT_ERROR: FLASH Error Interrupt
    704            *     @arg FLASH_IT_EOP: FLASH end of operation Interrupt
    705            * @param  NewState: new state of the specified Flash interrupts.
    706            *   This parameter can be: ENABLE or DISABLE.      
    707            * @retval None 
    708            */
    709          void FLASH_ITConfig(uint16_t FLASH_IT, FunctionalState NewState)
    710          {
    711            /* Check the parameters */
    712            //assert_param(IS_FLASH_IT(FLASH_IT)); 
    713            //assert_param(IS_FUNCTIONAL_STATE(NewState));
    714            if(NewState != DISABLE)
    715            {
    716              /* Enable the interrupt sources */
    717              FLASH->CR |= FLASH_IT;
    718            }
    719            else
    720            {
    721              /* Disable the interrupt sources */
    722              FLASH->CR &= ~(uint32_t)FLASH_IT;
    723            }
    724          }
    725          
    726          /**
    727            * @brief  Checks whether the specified FLASH flag is set or not.
    728            * @param  FLASH_FLAG: specifies the FLASH flag to check.
    729            *   This parameter can be one of the following values:
    730            *     @arg FLASH_FLAG_BSY: FLASH Busy flag           
    731            *     @arg FLASH_FLAG_PGERR: FLASH Program error flag       
    732            *     @arg FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
    733            *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag           
    734            *     @arg FLASH_FLAG_OPTERR:  FLASH Option Byte error flag     
    735            * @retval The new state of FLASH_FLAG (SET or RESET).
    736            */
    737          FlagStatus FLASH_GetFlagStatus(uint16_t FLASH_FLAG)
    738          {
    739            FlagStatus bitstatus = RESET;
    740            /* Check the parameters */
    741            //assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
    742            if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
    743            {
    744              if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
    745              {
    746                bitstatus = SET;
    747              }
    748              else
    749              {
    750                bitstatus = RESET;
    751              }
    752            }
    753            else
    754            {
    755             if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
    756              {
    757                bitstatus = SET;
    758              }
    759              else
    760              {
    761                bitstatus = RESET;
    762              }
    763            }
    764            /* Return the new state of FLASH_FLAG (SET or RESET) */
    765            return bitstatus;
    766          }
    767          
    768          /**
    769            * @brief  Clears the FLASHs pending flags.
    770            * @param  FLASH_FLAG: specifies the FLASH flags to clear.
    771            *   This parameter can be any combination of the following values:         
    772            *     @arg FLASH_FLAG_PGERR: FLASH Program error flag       
    773            *     @arg FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
    774            *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag           
    775            * @retval None
    776            */
    777          void FLASH_ClearFlag(uint16_t FLASH_FLAG)
    778          {
    779            /* Check the parameters */
    780            //assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
    781            
    782            /* Clear the flags */
    783            FLASH->SR = FLASH_FLAG;
    784          }
    785          
    786          /**
    787            * @brief  Returns the FLASH Status.
    788            * @param  None
    789            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
    790            *   FLASH_ERROR_WRP or FLASH_COMPLETE
    791            */
    792          FLASH_Status FLASH_GetStatus(void)
    793          {
    794            FLASH_Status flashstatus = FLASH_COMPLETE;
    795            
    796            if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
    797            {
    798              flashstatus = FLASH_BUSY;
    799            }
    800            else 
    801            {  
    802              if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
    803              { 
    804                flashstatus = FLASH_ERROR_PG;
    805              }
    806              else 
    807              {
    808                if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
    809                {
    810                  flashstatus = FLASH_ERROR_WRP;
    811                }
    812                else
    813                {
    814                  flashstatus = FLASH_COMPLETE;
    815                }
    816              }
    817            }
    818            /* Return the Flash Status */
    819            return flashstatus;
    820          }
    821          
    822          /**
    823            * @brief  Waits for a Flash operation to complete or a TIMEOUT to occur.
    824            * @param  Timeout: FLASH progamming Timeout
    825            * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
    826            *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
    827            */
    828          FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
    829          { 
    830            FLASH_Status status = FLASH_COMPLETE;
    831             
    832            /* Check for the Flash Status */
    833            status = FLASH_GetStatus();
    834            /* Wait for a Flash operation to complete or a TIMEOUT to occur */
    835            while((status == FLASH_BUSY) && (Timeout != 0x00))
    836            {
    837              delay();
    838              status = FLASH_GetStatus();
    839              Timeout--;
    840            }
    841            if(Timeout == 0x00 )
    842            {
    843              status = FLASH_TIMEOUT;
    844            }
    845            /* Return the operation status */
    846            return status;
    847          }
    848          
    849          /**
    850            * @brief  Inserts a time delay.
    851            * @param  None
    852            * @retval None
    853            */
    854          static void delay(void)
    855          {
    856            __IO uint32_t i = 0;
    857            for(i = 0xFF; i != 0; i--)
    858            {
    859            }
    860          }
    861          
    862          /**
    863            * @}
    864            */
    865          
    866          /**
    867            * @}
    868            */
    869          
    870          /**
    871            * @}
    872            */
    873          
    874          /******************* (C) COPYRIGHT 2009 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     FLASH_ClearFlag                     0
     FLASH_EnableWriteProtection        24
     FLASH_EraseAllPages                16
     FLASH_EraseOptionBytes             16
     FLASH_ErasePage                    16
     FLASH_GetFlagStatus                 0
     FLASH_GetPrefetchBufferStatus       0
     FLASH_GetReadOutProtectionStatus
                                         0
     FLASH_GetStatus                     0
     FLASH_GetUserOptionByte             0
     FLASH_GetWriteProtectionOptionByte
                                         0
     FLASH_HalfCycleAccessCmd            0
     FLASH_ITConfig                      0
     FLASH_Lock                          0
     FLASH_PrefetchBufferCmd             0
     FLASH_ProgramHalfWord              16
     FLASH_ProgramOptionByteData        16
     FLASH_ProgramWord                  24
     FLASH_ReadOutProtection            16
     FLASH_SetLatency                    0
     FLASH_Unlock                        0
     FLASH_UserOptionByteConfig         24
     FLASH_WaitForLastOperation         16


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     FLASH_SetLatency                 12
     ?Subroutine0                     10
     FLASH_HalfCycleAccessCmd         12
     FLASH_PrefetchBufferCmd          10
     FLASH_Unlock                     18
     FLASH_Lock                       14
     FLASH_ErasePage                  60
     FLASH_EraseAllPages              56
     FLASH_EraseOptionBytes           98
     FLASH_ProgramWord                76
     FLASH_ProgramHalfWord            50
     FLASH_ProgramOptionByteData      58
     FLASH_EnableWriteProtection     138
     FLASH_ReadOutProtection         118
     FLASH_UserOptionByteConfig       72
     FLASH_GetUserOptionByte           8
     FLASH_GetWriteProtectionOptionByte
                                       6
     FLASH_GetReadOutProtectionStatus
                                      10
     ?Subroutine1                      6
     FLASH_GetPrefetchBufferStatus     8
     FLASH_ITConfig                   18
     FLASH_GetFlagStatus              24
     FLASH_ClearFlag                   6
     FLASH_GetStatus                  36
     FLASH_WaitForLastOperation       50
     ??DataTable19                     4
     ??DataTable19_1                   4
     ??DataTable19_2                   4
     ??DataTable19_3                   4
     ??DataTable19_4                   4
     ??DataTable19_5                   4
     ??DataTable19_6                   4
     ??DataTable19_7                   4
     ??DataTable19_8                   4
     ??DataTable19_9                   4
     ??DataTable19_10                  4
     ??DataTable19_11                  4

 
 1 022 bytes in section .text
 
 1 022 bytes of CODE memory

Errors: none
Warnings: none
