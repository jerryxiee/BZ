###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     04/Dec/2013  10:58:07 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\STM32F2xx_StdPeriph_Driver\src\stm32f2xx #
#                    _adc.c                                                   #
#    Command line =  D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\STM32F2xx_StdPeriph_Driver\src\stm32f2xx #
#                    _adc.c -D STM32F10X_CL -D USE_STDPERIPH_DRIVER -lcN      #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\List\ -lb                    #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\List\ -o                     #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\Obj\ --no_cse --no_unroll    #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --warnings_are_errors --fpu=None --dlib_config        #
#                    E:\SoftwareInstall\arm\INC\c\DLib_Config_Normal.h -I     #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\..\inc\ -I                         #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\..\CMSIS\CM3\CoreSupport\ -I       #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\..\STM32F2xx_StdPeriph_Driver\inc\ #
#                     -I D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\ #
#                    改进型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_13081 #
#                    5_IAR6.1\STM32_Boot\EWARM\..\CMSIS\CM3\DeviceSupport\ST\ #
#                    STM32F2xx\ -On --use_c++_inline                          #
#    List file    =  D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\List\stm32f2xx_adc.lst       #
#    Object file  =  D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\Obj\stm32f2xx_adc.o          #
#                                                                             #
#                                                                             #
###############################################################################

D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IAR6.1\STM32_Boot\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_adc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    18-April-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Analog to Digital Convertor (ADC) peripheral:
      9            *           - Initialization and Configuration (in addition to ADC multi mode 
     10            *             selection)
     11            *           - Analog Watchdog configuration
     12            *           - Temperature Sensor & Vrefint (Voltage Reference internal) & VBAT
     13            *             management 
     14            *           - Regular Channels Configuration
     15            *           - Regular Channels DMA Configuration
     16            *           - Injected channels Configuration
     17            *           - Interrupts and flags management
     18            *         
     19            *  @verbatim
     20            *
     21            *          ===================================================================
     22            *                                   How to use this driver
     23            *          ===================================================================
     24          
     25            *          1.  Enable the ADC interface clock using 
     26            *                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADCx, ENABLE); 
     27            *     
     28            *          2. ADC pins configuration
     29            *               - Enable the clock for the ADC GPIOs using the following function:
     30            *                   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);   
     31            *                - Configure these ADC pins in analog mode using GPIO_Init();  
     32            *
     33            *          3. Configure the ADC Prescaler, conversion resolution and data 
     34            *              alignment using the ADC_Init() function.
     35            *          4. Activate the ADC peripheral using ADC_Cmd() function.
     36            *
     37            *          Regular channels group configuration
     38            *          ====================================    
     39            *            - To configure the ADC regular channels group features, use 
     40            *              ADC_Init() and ADC_RegularChannelConfig() functions.
     41            *            - To activate the continuous mode, use the ADC_continuousModeCmd()
     42            *              function.
     43            *            - To configurate and activate the Discontinuous mode, use the 
     44            *              ADC_DiscModeChannelCountConfig() and ADC_DiscModeCmd() functions.
     45            *            - To read the ADC converted values, use the ADC_GetConversionValue()
     46            *              function.
     47            *
     48            *          Multi mode ADCs Regular channels configuration
     49            *          ===============================================
     50            *            - Refer to "Regular channels group configuration" description to
     51            *              configure the ADC1, ADC2 and ADC3 regular channels.        
     52            *            - Select the Multi mode ADC regular channels features (dual or 
     53            *              triple mode) using ADC_CommonInit() function and configure 
     54            *              the DMA mode using ADC_MultiModeDMARequestAfterLastTransferCmd() 
     55            *              functions.        
     56            *            - Read the ADCs converted values using the 
     57            *              ADC_GetMultiModeConversionValue() function.
     58            *
     59            *          DMA for Regular channels group features configuration
     60            *          ====================================================== 
     61            *           - To enable the DMA mode for regular channels group, use the 
     62            *             ADC_DMACmd() function.
     63            *           - To enable the generation of DMA requests continuously at the end
     64            *             of the last DMA transfer, use the ADC_DMARequestAfterLastTransferCmd() 
     65            *             function.
     66            *
     67            *          Injected channels group configuration
     68            *          =====================================    
     69            *            - To configure the ADC Injected channels group features, use 
     70            *              ADC_InjectedChannelConfig() and  ADC_InjectedSequencerLengthConfig()
     71            *              functions.
     72            *            - To activate the continuous mode, use the ADC_continuousModeCmd()
     73            *              function.
     74            *            - To activate the Injected Discontinuous mode, use the 
     75            *              ADC_InjectedDiscModeCmd() function.  
     76            *            - To activate the AutoInjected mode, use the ADC_AutoInjectedConvCmd() 
     77            *              function.        
     78            *            - To read the ADC converted values, use the ADC_GetInjectedConversionValue() 
     79            *              function.
     80            *
     81            *  @endverbatim
     82            *
     83            ******************************************************************************
     84            * @attention
     85            *
     86            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     87            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     88            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     89            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     90            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     91            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     92            *
     93            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     94            ******************************************************************************  
     95            */ 
     96          
     97          /* Includes ------------------------------------------------------------------*/
     98          #include "stm32f2xx_adc.h"
     99          #include "stm32f2xx_rcc.h"
    100          #include "assert.h"
    101          /** @addtogroup STM32F2xx_StdPeriph_Driver
    102            * @{
    103            */
    104          
    105          /** @defgroup ADC 
    106            * @brief ADC driver modules
    107            * @{
    108            */ 
    109          
    110          /* Private typedef -----------------------------------------------------------*/
    111          /* Private define ------------------------------------------------------------*/ 
    112          
    113          /* ADC DISCNUM mask */
    114          #define CR1_DISCNUM_RESET         ((uint32_t)0xFFFF1FFF)
    115          
    116          /* ADC AWDCH mask */
    117          #define CR1_AWDCH_RESET           ((uint32_t)0xFFFFFFE0)   
    118          
    119          /* ADC Analog watchdog enable mode mask */
    120          #define CR1_AWDMode_RESET         ((uint32_t)0xFF3FFDFF)   
    121          
    122          /* CR1 register Mask */
    123          #define CR1_CLEAR_MASK            ((uint32_t)0xFCFFFEFF)
    124          
    125          /* ADC EXTEN mask */
    126          #define CR2_EXTEN_RESET           ((uint32_t)0xCFFFFFFF)  
    127          
    128          /* ADC JEXTEN mask */
    129          #define CR2_JEXTEN_RESET          ((uint32_t)0xFFCFFFFF)  
    130          
    131          /* ADC JEXTSEL mask */
    132          #define CR2_JEXTSEL_RESET         ((uint32_t)0xFFF0FFFF)  
    133          
    134          /* CR2 register Mask */
    135          #define CR2_CLEAR_MASK            ((uint32_t)0xC0FFF7FD)
    136          
    137          /* ADC SQx mask */
    138          #define SQR3_SQ_SET               ((uint32_t)0x0000001F)  
    139          #define SQR2_SQ_SET               ((uint32_t)0x0000001F)  
    140          #define SQR1_SQ_SET               ((uint32_t)0x0000001F)  
    141          
    142          /* ADC L Mask */
    143          #define SQR1_L_RESET              ((uint32_t)0xFF0FFFFF) 
    144          
    145          /* ADC JSQx mask */
    146          #define JSQR_JSQ_SET              ((uint32_t)0x0000001F) 
    147          
    148          /* ADC JL mask */
    149          #define JSQR_JL_SET               ((uint32_t)0x00300000) 
    150          #define JSQR_JL_RESET             ((uint32_t)0xFFCFFFFF) 
    151          
    152          /* ADC SMPx mask */
    153          #define SMPR1_SMP_SET             ((uint32_t)0x00000007)  
    154          #define SMPR2_SMP_SET             ((uint32_t)0x00000007) 
    155          
    156          /* ADC JDRx registers offset */
    157          #define JDR_OFFSET                ((uint8_t)0x28) 
    158          
    159          /* ADC CDR register base address */
    160          #define CDR_ADDRESS               ((uint32_t)0x40012308)   
    161          
    162          /* ADC CCR register Mask */
    163          #define CR_CLEAR_MASK             ((uint32_t)0xFFFC30E0)  
    164          
    165          /* Private macro -------------------------------------------------------------*/
    166          /* Private variables ---------------------------------------------------------*/
    167          /* Private function prototypes -----------------------------------------------*/
    168          /* Private functions ---------------------------------------------------------*/
    169          
    170          /** @defgroup ADC_Private_Functions
    171            * @{
    172            */ 
    173          
    174          /** @defgroup ADC_Group1 Initialization and Configuration functions
    175           *  @brief    Initialization and Configuration functions 
    176           *
    177          @verbatim    
    178           ===============================================================================
    179                                Initialization and Configuration functions
    180           ===============================================================================  
    181            This section provides functions allowing to:
    182             - Initialize and configure the ADC Prescaler
    183             - ADC Conversion Resolution (12bit..6bit)
    184             - Scan Conversion Mode (multichannels or one channel) for regular group
    185             - ADC Continuous Conversion Mode (Continuous or Single conversion) for 
    186               regular group
    187             - External trigger Edge and source of regular group, 
    188             - Converted data alignment (left or right)
    189             - The number of ADC conversions that will be done using the sequencer for 
    190               regular channel group
    191             - Multi ADC mode selection
    192             - Direct memory access mode selection for multi ADC mode  
    193             - Delay between 2 sampling phases (used in dual or triple interleaved modes)
    194             - Enable or disable the ADC peripheral
    195             
    196          @endverbatim
    197            * @{
    198            */
    199          
    200          /**
    201            * @brief  Deinitializes all ADCs peripherals registers to their default reset 
    202            *         values.
    203            * @param  None
    204            * @retval None
    205            */
    206          void ADC_DeInit(void)
    207          {
    208            /* Enable all ADCs reset state */
    209            RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
    210            
    211            /* Release all ADCs from reset state */
    212            RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
    213          }
    214          
    215          /**
    216            * @brief  Initializes the ADCx peripheral according to the specified parameters 
    217            *         in the ADC_InitStruct.
    218            * @note   This function is used to configure the global features of the ADC ( 
    219            *         Resolution and Data Alignment), however, the rest of the configuration
    220            *         parameters are specific to the regular channels group (scan mode 
    221            *         activation, continuous mode activation, External trigger source and 
    222            *         edge, number of conversion in the regular channels group sequencer).  
    223            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    224            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
    225            *         the configuration information for the specified ADC peripheral.
    226            * @retval None
    227            */
    228          void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
    229          {
    230            uint32_t tmpreg1 = 0;
    231            uint8_t tmpreg2 = 0;
    232            /* Check the parameters */
    233            /*
    234            assert(IS_ADC_ALL_PERIPH(ADCx));
    235            assert(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
    236            assert(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
    237            assert(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
    238            assert(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
    239            assert(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
    240            assert(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
    241            assert(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
    242            */
    243            /*---------------------------- ADCx CR1 Configuration -----------------*/
    244            /* Get the ADCx CR1 value */
    245            tmpreg1 = ADCx->CR1;
    246            
    247            /* Clear RES and SCAN bits */
    248            tmpreg1 &= CR1_CLEAR_MASK;
    249            
    250            /* Configure ADCx: scan conversion mode and resolution */
    251            /* Set SCAN bit according to ADC_ScanConvMode value */
    252            /* Set RES bit according to ADC_Resolution value */ 
    253            tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
    254                                             ADC_InitStruct->ADC_Resolution);
    255            /* Write to ADCx CR1 */
    256            ADCx->CR1 = tmpreg1;
    257            /*---------------------------- ADCx CR2 Configuration -----------------*/
    258            /* Get the ADCx CR2 value */
    259            tmpreg1 = ADCx->CR2;
    260            
    261            /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
    262            tmpreg1 &= CR2_CLEAR_MASK;
    263            
    264            /* Configure ADCx: external trigger event and edge, data alignment and 
    265               continuous conversion mode */
    266            /* Set ALIGN bit according to ADC_DataAlign value */
    267            /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
    268            /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
    269            /* Set CONT bit according to ADC_ContinuousConvMode value */
    270            tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
    271                                  ADC_InitStruct->ADC_ExternalTrigConv | 
    272                                  ADC_InitStruct->ADC_ExternalTrigConvEdge | \
    273                                  ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
    274                                  
    275            /* Write to ADCx CR2 */
    276            ADCx->CR2 = tmpreg1;
    277            /*---------------------------- ADCx SQR1 Configuration -----------------*/
    278            /* Get the ADCx SQR1 value */
    279            tmpreg1 = ADCx->SQR1;
    280            
    281            /* Clear L bits */
    282            tmpreg1 &= SQR1_L_RESET;
    283            
    284            /* Configure ADCx: regular channel sequence length */
    285            /* Set L bits according to ADC_NbrOfConversion value */
    286            tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
    287            tmpreg1 |= ((uint32_t)tmpreg2 << 20);
    288            
    289            /* Write to ADCx SQR1 */
    290            ADCx->SQR1 = tmpreg1;
    291          }
    292          
    293          /**
    294            * @brief  Fills each ADC_InitStruct member with its default value.
    295            * @note   This function is used to initialize the global features of the ADC ( 
    296            *         Resolution and Data Alignment), however, the rest of the configuration
    297            *         parameters are specific to the regular channels group (scan mode 
    298            *         activation, continuous mode activation, External trigger source and 
    299            *         edge, number of conversion in the regular channels group sequencer).  
    300            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure which will 
    301            *         be initialized.
    302            * @retval None
    303            */
    304          void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
    305          {
    306            /* Initialize the ADC_Mode member */
    307            ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
    308          
    309            /* initialize the ADC_ScanConvMode member */
    310            ADC_InitStruct->ADC_ScanConvMode = DISABLE;
    311          
    312            /* Initialize the ADC_ContinuousConvMode member */
    313            ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
    314          
    315            /* Initialize the ADC_ExternalTrigConvEdge member */
    316            ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
    317          
    318            /* Initialize the ADC_ExternalTrigConv member */
    319            ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
    320          
    321            /* Initialize the ADC_DataAlign member */
    322            ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
    323          
    324            /* Initialize the ADC_NbrOfConversion member */
    325            ADC_InitStruct->ADC_NbrOfConversion = 1;
    326          }
    327          
    328          /**
    329            * @brief  Initializes the ADCs peripherals according to the specified parameters 
    330            *         in the ADC_CommonInitStruct.
    331            * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
    332            *         that contains the configuration information for  All ADCs peripherals.
    333            * @retval None
    334            */
    335          void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
    336          {
    337            uint32_t tmpreg1 = 0;
    338            /* Check the parameters */
    339            /*
    340            assert(IS_ADC_MODE(ADC_CommonInitStruct->ADC_Mode));
    341            assert(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
    342            assert(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
    343            assert(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
    344            */
    345            /*---------------------------- ADC CCR Configuration -----------------*/
    346            /* Get the ADC CCR value */
    347            tmpreg1 = ADC->CCR;
    348            
    349            /* Clear MULTI, DELAY, DMA and ADCPRE bits */
    350            tmpreg1 &= CR_CLEAR_MASK;
    351            
    352            /* Configure ADCx: Multi mode, Delay between two sampling time, ADC prescaler,
    353               and DMA access mode for multimode */
    354            /* Set MULTI bits according to ADC_Mode value */
    355            /* Set ADCPRE bits according to ADC_Prescaler value */
    356            /* Set DMA bits according to ADC_DMAAccessMode value */
    357            /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
    358            tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
    359                                  ADC_CommonInitStruct->ADC_Prescaler | 
    360                                  ADC_CommonInitStruct->ADC_DMAAccessMode | 
    361                                  ADC_CommonInitStruct->ADC_TwoSamplingDelay);
    362                                  
    363            /* Write to ADC CCR */
    364            ADC->CCR = tmpreg1;
    365          }
    366          
    367          /**
    368            * @brief  Fills each ADC_CommonInitStruct member with its default value.
    369            * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure
    370            *         which will be initialized.
    371            * @retval None
    372            */
    373          void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
    374          {
    375            /* Initialize the ADC_Mode member */
    376            ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
    377          
    378            /* initialize the ADC_Prescaler member */
    379            ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
    380          
    381            /* Initialize the ADC_DMAAccessMode member */
    382            ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
    383          
    384            /* Initialize the ADC_TwoSamplingDelay member */
    385            ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
    386          }
    387          
    388          /**
    389            * @brief  Enables or disables the specified ADC peripheral.
    390            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    391            * @param  NewState: new state of the ADCx peripheral. 
    392            *          This parameter can be: ENABLE or DISABLE.
    393            * @retval None
    394            */
    395          void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    396          {
    397            /* Check the parameters */
    398          	/*
    399            assert(IS_ADC_ALL_PERIPH(ADCx));
    400            assert(IS_FUNCTIONAL_STATE(NewState));
    401          	*/
    402            if (NewState != DISABLE)
    403            {
    404              /* Set the ADON bit to wake up the ADC from power down mode */
    405              ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
    406            }
    407            else
    408            {
    409              /* Disable the selected ADC peripheral */
    410              ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
    411            }
    412          }
    413          /**
    414            * @}
    415            */
    416          
    417          /** @defgroup ADC_Group2 Analog Watchdog configuration functions
    418           *  @brief    Analog Watchdog configuration functions 
    419           *
    420          @verbatim   
    421           ===============================================================================
    422                              Analog Watchdog configuration functions
    423           ===============================================================================  
    424          
    425            This section provides functions allowing to configure the Analog Watchdog
    426            (AWD) feature in the ADC.
    427            
    428            A typical configuration Analog Watchdog is done following these steps :
    429             1. the ADC guarded channel(s) is (are) selected using the 
    430                ADC_AnalogWatchdogSingleChannelConfig() function.
    431             2. The Analog watchdog lower and higher threshold are configured using the  
    432               ADC_AnalogWatchdogThresholdsConfig() function.
    433             3. The Analog watchdog is enabled and configured to enable the check, on one
    434                or more channels, using the  ADC_AnalogWatchdogCmd() function.
    435          
    436          @endverbatim
    437            * @{
    438            */
    439            
    440          /**
    441            * @brief  Enables or disables the analog watchdog on single/all regular or 
    442            *         injected channels
    443            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    444            * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
    445            *         This parameter can be one of the following values:
    446            *            @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single regular channel
    447            *            @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single injected channel
    448            *            @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a single regular or injected channel
    449            *            @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on all regular channel
    450            *            @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on all injected channel
    451            *            @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels
    452            *            @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
    453            * @retval None	  
    454            */
    455          void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
    456          {
    457            uint32_t tmpreg = 0;
    458            /* Check the parameters */
    459            /*
    460            assert(IS_ADC_ALL_PERIPH(ADCx));
    461            assert(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
    462            */
    463            /* Get the old register value */
    464            tmpreg = ADCx->CR1;
    465            
    466            /* Clear AWDEN, JAWDEN and AWDSGL bits */
    467            tmpreg &= CR1_AWDMode_RESET;
    468            
    469            /* Set the analog watchdog enable mode */
    470            tmpreg |= ADC_AnalogWatchdog;
    471            
    472            /* Store the new register value */
    473            ADCx->CR1 = tmpreg;
    474          }
    475          
    476          /**
    477            * @brief  Configures the high and low thresholds of the analog watchdog.
    478            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    479            * @param  HighThreshold: the ADC analog watchdog High threshold value.
    480            *          This parameter must be a 12-bit value.
    481            * @param  LowThreshold:  the ADC analog watchdog Low threshold value.
    482            *          This parameter must be a 12-bit value.
    483            * @retval None
    484            */
    485          void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
    486                                                  uint16_t LowThreshold)
    487          {
    488            /* Check the parameters */
    489          	/*
    490            assert(IS_ADC_ALL_PERIPH(ADCx));
    491            assert(IS_ADC_THRESHOLD(HighThreshold));
    492            assert(IS_ADC_THRESHOLD(LowThreshold));
    493          	*/
    494            
    495            /* Set the ADCx high threshold */
    496            ADCx->HTR = HighThreshold;
    497            
    498            /* Set the ADCx low threshold */
    499            ADCx->LTR = LowThreshold;
    500          }
    501          
    502          /**
    503            * @brief  Configures the analog watchdog guarded single channel
    504            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    505            * @param  ADC_Channel: the ADC channel to configure for the analog watchdog. 
    506            *          This parameter can be one of the following values:
    507            *            @arg ADC_Channel_0: ADC Channel0 selected
    508            *            @arg ADC_Channel_1: ADC Channel1 selected
    509            *            @arg ADC_Channel_2: ADC Channel2 selected
    510            *            @arg ADC_Channel_3: ADC Channel3 selected
    511            *            @arg ADC_Channel_4: ADC Channel4 selected
    512            *            @arg ADC_Channel_5: ADC Channel5 selected
    513            *            @arg ADC_Channel_6: ADC Channel6 selected
    514            *            @arg ADC_Channel_7: ADC Channel7 selected
    515            *            @arg ADC_Channel_8: ADC Channel8 selected
    516            *            @arg ADC_Channel_9: ADC Channel9 selected
    517            *            @arg ADC_Channel_10: ADC Channel10 selected
    518            *            @arg ADC_Channel_11: ADC Channel11 selected
    519            *            @arg ADC_Channel_12: ADC Channel12 selected
    520            *            @arg ADC_Channel_13: ADC Channel13 selected
    521            *            @arg ADC_Channel_14: ADC Channel14 selected
    522            *            @arg ADC_Channel_15: ADC Channel15 selected
    523            *            @arg ADC_Channel_16: ADC Channel16 selected
    524            *            @arg ADC_Channel_17: ADC Channel17 selected
    525            *            @arg ADC_Channel_18: ADC Channel18 selected
    526            * @retval None
    527            */
    528          void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
    529          {
    530            uint32_t tmpreg = 0;
    531            /* Check the parameters */
    532            /*
    533            assert(IS_ADC_ALL_PERIPH(ADCx));
    534            assert(IS_ADC_CHANNEL(ADC_Channel));
    535            */
    536            /* Get the old register value */
    537            tmpreg = ADCx->CR1;
    538            
    539            /* Clear the Analog watchdog channel select bits */
    540            tmpreg &= CR1_AWDCH_RESET;
    541            
    542            /* Set the Analog watchdog channel */
    543            tmpreg |= ADC_Channel;
    544            
    545            /* Store the new register value */
    546            ADCx->CR1 = tmpreg;
    547          }
    548          /**
    549            * @}
    550            */
    551          
    552          /** @defgroup ADC_Group3 Temperature Sensor, Vrefint (Voltage Reference internal) 
    553           *            and VBAT (Voltage BATtery) management functions
    554           *  @brief   Temperature Sensor, Vrefint and VBAT management functions 
    555           *
    556          @verbatim   
    557           ===============================================================================
    558                         Temperature Sensor, Vrefint and VBAT management functions
    559           ===============================================================================  
    560          
    561            This section provides functions allowing to enable/ disable the internal 
    562            connections between the ADC and the Temperature Sensor, the Vrefint and the
    563            Vbat sources.
    564               
    565            A typical configuration to get the Temperature sensor and Vrefint channels 
    566            voltages is done following these steps :
    567             1. Enable the internal connection of Temperature sensor and Vrefint sources 
    568                with the ADC channels using ADC_TempSensorVrefintCmd() function. 
    569             2. Select the ADC_Channel_TempSensor and/or ADC_Channel_Vrefint using 
    570                ADC_RegularChannelConfig() or  ADC_InjectedChannelConfig() functions 
    571             3. Get the voltage values, using ADC_GetConversionValue() or  
    572                ADC_GetInjectedConversionValue().
    573          
    574            A typical configuration to get the VBAT channel voltage is done following 
    575            these steps :
    576             1. Enable the internal connection of VBAT source with the ADC channel using 
    577                ADC_VBATCmd() function. 
    578             2. Select the ADC_Channel_Vbat using ADC_RegularChannelConfig() or  
    579                ADC_InjectedChannelConfig() functions 
    580             3. Get the voltage value, using ADC_GetConversionValue() or  
    581                ADC_GetInjectedConversionValue().
    582           
    583          @endverbatim
    584            * @{
    585            */
    586            
    587            
    588          /**
    589            * @brief  Enables or disables the temperature sensor and Vrefint channels.
    590            * @param  NewState: new state of the temperature sensor and Vrefint channels.
    591            *          This parameter can be: ENABLE or DISABLE.
    592            * @retval None
    593            */
    594          void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
    595          {
    596            /* Check the parameters */
    597            //assert(IS_FUNCTIONAL_STATE(NewState));
    598            if (NewState != DISABLE)
    599            {
    600              /* Enable the temperature sensor and Vrefint channel*/
    601              ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
    602            }
    603            else
    604            {
    605              /* Disable the temperature sensor and Vrefint channel*/
    606              ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
    607            }
    608          }
    609          
    610          /**
    611            * @brief  Enables or disables the VBAT (Voltage Battery) channel.
    612            * @param  NewState: new state of the VBAT channel.
    613            *          This parameter can be: ENABLE or DISABLE.
    614            * @retval None
    615            */
    616          void ADC_VBATCmd(FunctionalState NewState)                             
    617          {
    618            /* Check the parameters */
    619            //assert(IS_FUNCTIONAL_STATE(NewState));
    620            if (NewState != DISABLE)
    621            {
    622              /* Enable the VBAT channel*/
    623              ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
    624            }
    625            else
    626            {
    627              /* Disable the VBAT channel*/
    628              ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);
    629            }
    630          }
    631          
    632          /**
    633            * @}
    634            */
    635          
    636          /** @defgroup ADC_Group4 Regular Channels Configuration functions
    637           *  @brief   Regular Channels Configuration functions 
    638           *
    639          @verbatim   
    640           ===============================================================================
    641                            Regular Channels Configuration functions
    642           ===============================================================================  
    643          
    644            This section provides functions allowing to manage the ADC's regular channels,
    645            it is composed of 2 sub sections : 
    646            
    647            1. Configuration and management functions for regular channels: This subsection 
    648               provides functions allowing to configure the ADC regular channels :    
    649                    - Configure the rank in the regular group sequencer for each channel
    650                    - Configure the sampling time for each channel
    651                    - select the conversion Trigger for regular channels
    652                    - select the desired EOC event behavior configuration
    653                    - Activate the continuous Mode  (*)
    654                    - Activate the Discontinuous Mode 
    655               Please Note that the following features for regular channels are configurated
    656               using the ADC_Init() function : 
    657                    - scan mode activation 
    658                    - continuous mode activation (**) 
    659                    - External trigger source  
    660                    - External trigger edge 
    661                    - number of conversion in the regular channels group sequencer.
    662               
    663               @note (*) and (**) are performing the same configuration
    664               
    665            2. Get the conversion data: This subsection provides an important function in 
    666               the ADC peripheral since it returns the converted data of the current 
    667               regular channel. When the Conversion value is read, the EOC Flag is 
    668               automatically cleared.
    669               
    670               @note For multi ADC mode, the last ADC1, ADC2 and ADC3 regular conversions 
    671                     results data (in the selected multi mode) can be returned in the same 
    672                     time using ADC_GetMultiModeConversionValue() function. 
    673                 
    674            
    675          @endverbatim
    676            * @{
    677            */
    678          /**
    679            * @brief  Configures for the selected ADC regular channel its corresponding
    680            *         rank in the sequencer and its sample time.
    681            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    682            * @param  ADC_Channel: the ADC channel to configure. 
    683            *          This parameter can be one of the following values:
    684            *            @arg ADC_Channel_0: ADC Channel0 selected
    685            *            @arg ADC_Channel_1: ADC Channel1 selected
    686            *            @arg ADC_Channel_2: ADC Channel2 selected
    687            *            @arg ADC_Channel_3: ADC Channel3 selected
    688            *            @arg ADC_Channel_4: ADC Channel4 selected
    689            *            @arg ADC_Channel_5: ADC Channel5 selected
    690            *            @arg ADC_Channel_6: ADC Channel6 selected
    691            *            @arg ADC_Channel_7: ADC Channel7 selected
    692            *            @arg ADC_Channel_8: ADC Channel8 selected
    693            *            @arg ADC_Channel_9: ADC Channel9 selected
    694            *            @arg ADC_Channel_10: ADC Channel10 selected
    695            *            @arg ADC_Channel_11: ADC Channel11 selected
    696            *            @arg ADC_Channel_12: ADC Channel12 selected
    697            *            @arg ADC_Channel_13: ADC Channel13 selected
    698            *            @arg ADC_Channel_14: ADC Channel14 selected
    699            *            @arg ADC_Channel_15: ADC Channel15 selected
    700            *            @arg ADC_Channel_16: ADC Channel16 selected
    701            *            @arg ADC_Channel_17: ADC Channel17 selected
    702            *            @arg ADC_Channel_18: ADC Channel18 selected                       
    703            * @param  Rank: The rank in the regular group sequencer.
    704            *          This parameter must be between 1 to 16.
    705            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
    706            *          This parameter can be one of the following values:
    707            *            @arg ADC_SampleTime_3Cycles: Sample time equal to 3 cycles
    708            *            @arg ADC_SampleTime_15Cycles: Sample time equal to 15 cycles
    709            *            @arg ADC_SampleTime_28Cycles: Sample time equal to 28 cycles
    710            *            @arg ADC_SampleTime_56Cycles: Sample time equal to 56 cycles	
    711            *            @arg ADC_SampleTime_84Cycles: Sample time equal to 84 cycles	
    712            *            @arg ADC_SampleTime_112Cycles: Sample time equal to 112 cycles	
    713            *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
    714            *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
    715            * @retval None
    716            */
    717          void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
    718          {
    719            uint32_t tmpreg1 = 0, tmpreg2 = 0;
    720            /* Check the parameters */
    721            /*
    722            assert(IS_ADC_ALL_PERIPH(ADCx));
    723            assert(IS_ADC_CHANNEL(ADC_Channel));
    724            assert(IS_ADC_REGULAR_RANK(Rank));
    725            assert(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
    726            */
    727            /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
    728            if (ADC_Channel > ADC_Channel_9)
    729            {
    730              /* Get the old register value */
    731              tmpreg1 = ADCx->SMPR1;
    732              
    733              /* Calculate the mask to clear */
    734              tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
    735              
    736              /* Clear the old sample time */
    737              tmpreg1 &= ~tmpreg2;
    738              
    739              /* Calculate the mask to set */
    740              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    741              
    742              /* Set the new sample time */
    743              tmpreg1 |= tmpreg2;
    744              
    745              /* Store the new register value */
    746              ADCx->SMPR1 = tmpreg1;
    747            }
    748            else /* ADC_Channel include in ADC_Channel_[0..9] */
    749            {
    750              /* Get the old register value */
    751              tmpreg1 = ADCx->SMPR2;
    752              
    753              /* Calculate the mask to clear */
    754              tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
    755              
    756              /* Clear the old sample time */
    757              tmpreg1 &= ~tmpreg2;
    758              
    759              /* Calculate the mask to set */
    760              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    761              
    762              /* Set the new sample time */
    763              tmpreg1 |= tmpreg2;
    764              
    765              /* Store the new register value */
    766              ADCx->SMPR2 = tmpreg1;
    767            }
    768            /* For Rank 1 to 6 */
    769            if (Rank < 7)
    770            {
    771              /* Get the old register value */
    772              tmpreg1 = ADCx->SQR3;
    773              
    774              /* Calculate the mask to clear */
    775              tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
    776              
    777              /* Clear the old SQx bits for the selected rank */
    778              tmpreg1 &= ~tmpreg2;
    779              
    780              /* Calculate the mask to set */
    781              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
    782              
    783              /* Set the SQx bits for the selected rank */
    784              tmpreg1 |= tmpreg2;
    785              
    786              /* Store the new register value */
    787              ADCx->SQR3 = tmpreg1;
    788            }
    789            /* For Rank 7 to 12 */
    790            else if (Rank < 13)
    791            {
    792              /* Get the old register value */
    793              tmpreg1 = ADCx->SQR2;
    794              
    795              /* Calculate the mask to clear */
    796              tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
    797              
    798              /* Clear the old SQx bits for the selected rank */
    799              tmpreg1 &= ~tmpreg2;
    800              
    801              /* Calculate the mask to set */
    802              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
    803              
    804              /* Set the SQx bits for the selected rank */
    805              tmpreg1 |= tmpreg2;
    806              
    807              /* Store the new register value */
    808              ADCx->SQR2 = tmpreg1;
    809            }
    810            /* For Rank 13 to 16 */
    811            else
    812            {
    813              /* Get the old register value */
    814              tmpreg1 = ADCx->SQR1;
    815              
    816              /* Calculate the mask to clear */
    817              tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
    818              
    819              /* Clear the old SQx bits for the selected rank */
    820              tmpreg1 &= ~tmpreg2;
    821              
    822              /* Calculate the mask to set */
    823              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
    824              
    825              /* Set the SQx bits for the selected rank */
    826              tmpreg1 |= tmpreg2;
    827              
    828              /* Store the new register value */
    829              ADCx->SQR1 = tmpreg1;
    830            }
    831          }
    832          
    833          /**
    834            * @brief  Enables the selected ADC software start conversion of the regular channels.
    835            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    836            * @retval None
    837            */
    838          void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
    839          {
    840            /* Check the parameters */
    841            assert(IS_ADC_ALL_PERIPH(ADCx));
    842            
    843            /* Enable the selected ADC conversion for regular group */
    844            ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
    845          }
    846          
    847          /**
    848            * @brief  Gets the selected ADC Software start regular conversion Status.
    849            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    850            * @retval The new state of ADC software start conversion (SET or RESET).
    851            */
    852          FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
    853          {
    854            FlagStatus bitstatus = RESET;
    855            /* Check the parameters */
    856            assert(IS_ADC_ALL_PERIPH(ADCx));
    857            
    858            /* Check the status of SWSTART bit */
    859            if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
    860            {
    861              /* SWSTART bit is set */
    862              bitstatus = SET;
    863            }
    864            else
    865            {
    866              /* SWSTART bit is reset */
    867              bitstatus = RESET;
    868            }
    869            
    870            /* Return the SWSTART bit status */
    871            return  bitstatus;
    872          }
    873          
    874          
    875          /**
    876            * @brief  Enables or disables the EOC on each regular channel conversion
    877            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    878            * @param  NewState: new state of the selected ADC EOC flag rising
    879            *          This parameter can be: ENABLE or DISABLE.
    880            * @retval None
    881            */
    882          void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    883          {
    884            /* Check the parameters */
    885            assert(IS_ADC_ALL_PERIPH(ADCx));
    886            assert(IS_FUNCTIONAL_STATE(NewState));
    887            
    888            if (NewState != DISABLE)
    889            {
    890              /* Enable the selected ADC EOC rising on each regular channel conversion */
    891              ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
    892            }
    893            else
    894            {
    895              /* Disable the selected ADC EOC rising on each regular channel conversion */
    896              ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);
    897            }
    898          }
    899          
    900          /**
    901            * @brief  Enables or disables the ADC continuous conversion mode 
    902            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    903            * @param  NewState: new state of the selected ADC continuous conversion mode
    904            *          This parameter can be: ENABLE or DISABLE.
    905            * @retval None
    906            */
    907          void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    908          {
    909            /* Check the parameters */
    910            assert(IS_ADC_ALL_PERIPH(ADCx));
    911            assert(IS_FUNCTIONAL_STATE(NewState));
    912            
    913            if (NewState != DISABLE)
    914            {
    915              /* Enable the selected ADC continuous conversion mode */
    916              ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
    917            }
    918            else
    919            {
    920              /* Disable the selected ADC continuous conversion mode */
    921              ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
    922            }
    923          }
    924          
    925          /**
    926            * @brief  Configures the discontinuous mode for the selected ADC regular group 
    927            *         channel.
    928            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    929            * @param  Number: specifies the discontinuous mode regular channel count value.
    930            *          This number must be between 1 and 8.
    931            * @retval None
    932            */
    933          void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
    934          {
    935            uint32_t tmpreg1 = 0;
    936            uint32_t tmpreg2 = 0;
    937            
    938            /* Check the parameters */
    939            ///assert(IS_ADC_ALL_PERIPH(ADCx));
    940            //assert(IS_ADC_REGULAR_DISC_NUMBER(Number));
    941            
    942            /* Get the old register value */
    943            tmpreg1 = ADCx->CR1;
    944            
    945            /* Clear the old discontinuous mode channel count */
    946            tmpreg1 &= CR1_DISCNUM_RESET;
    947            
    948            /* Set the discontinuous mode channel count */
    949            tmpreg2 = Number - 1;
    950            tmpreg1 |= tmpreg2 << 13;
    951            
    952            /* Store the new register value */
    953            ADCx->CR1 = tmpreg1;
    954          }
    955          
    956          /**
    957            * @brief  Enables or disables the discontinuous mode on regular group channel 
    958            *         for the specified ADC
    959            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    960            * @param  NewState: new state of the selected ADC discontinuous mode on 
    961            *         regular group channel.
    962            *          This parameter can be: ENABLE or DISABLE.
    963            * @retval None
    964            */
    965          void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    966          {
    967            /* Check the parameters */
    968            //assert(IS_ADC_ALL_PERIPH(ADCx));
    969            //assert(IS_FUNCTIONAL_STATE(NewState));
    970            
    971            if (NewState != DISABLE)
    972            {
    973              /* Enable the selected ADC regular discontinuous mode */
    974              ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
    975            }
    976            else
    977            {
    978              /* Disable the selected ADC regular discontinuous mode */
    979              ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
    980            }
    981          }
    982          
    983          /**
    984            * @brief  Returns the last ADCx conversion result data for regular channel.
    985            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    986            * @retval The Data conversion value.
    987            */
    988          uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
    989          {
    990            /* Check the parameters */
    991            //assert(IS_ADC_ALL_PERIPH(ADCx));
    992            
    993            /* Return the selected ADC conversion value */
    994            return (uint16_t) ADCx->DR;
    995          }
    996          
    997          /**
    998            * @brief  Returns the last ADC1, ADC2 and ADC3 regular conversions results 
    999            *         data in the selected multi mode.
   1000            * @param  None  
   1001            * @retval The Data conversion value.
   1002            * @note   In dual mode, the value returned by this function is as following
   1003            *           Data[15:0] : these bits contain the regular data of ADC1.
   1004            *           Data[31:16]: these bits contain the regular data of ADC2.
   1005            * @note   In triple mode, the value returned by this function is as following
   1006            *           Data[15:0] : these bits contain alternatively the regular data of ADC1, ADC3 and ADC2.
   1007            *           Data[31:16]: these bits contain alternatively the regular data of ADC2, ADC1 and ADC3.           
   1008            */
   1009          uint32_t ADC_GetMultiModeConversionValue(void)
   1010          {
   1011            /* Return the multi mode conversion value */
   1012            return (*(__IO uint32_t *) CDR_ADDRESS);
   1013          }
   1014          /**
   1015            * @}
   1016            */
   1017          
   1018          /** @defgroup ADC_Group5 Regular Channels DMA Configuration functions
   1019           *  @brief   Regular Channels DMA Configuration functions 
   1020           *
   1021          @verbatim   
   1022           ===============================================================================
   1023                             Regular Channels DMA Configuration functions
   1024           ===============================================================================  
   1025          
   1026            This section provides functions allowing to configure the DMA for ADC regular 
   1027            channels.
   1028            Since converted regular channel values are stored into a unique data register, 
   1029            it is useful to use DMA for conversion of more than one regular channel. This 
   1030            avoids the loss of the data already stored in the ADC Data register. 
   1031            
   1032            When the DMA mode is enabled (using the ADC_DMACmd() function), after each
   1033            conversion of a regular channel, a DMA request is generated.
   1034            
   1035            Depending on the "DMA disable selection for Independent ADC mode" 
   1036            configuration (using the ADC_DMARequestAfterLastTransferCmd() function), 
   1037            at the end of the last DMA transfer, two possibilities are allowed:
   1038            - No new DMA request is issued to the DMA controller (feature DISABLED) 
   1039            - Requests can continue to be generated (feature ENABLED).
   1040            
   1041            Depending on the "DMA disable selection for multi ADC mode" configuration 
   1042            (using the void ADC_MultiModeDMARequestAfterLastTransferCmd() function), 
   1043            at the end of the last DMA transfer, two possibilities are allowed:
   1044            - No new DMA request is issued to the DMA controller (feature DISABLED) 
   1045            - Requests can continue to be generated (feature ENABLED).
   1046          
   1047          @endverbatim
   1048            * @{
   1049            */
   1050            
   1051           /**
   1052            * @brief  Enables or disables the specified ADC DMA request.
   1053            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1054            * @param  NewState: new state of the selected ADC DMA transfer.
   1055            *          This parameter can be: ENABLE or DISABLE.
   1056            * @retval None
   1057            */
   1058          void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1059          {
   1060            /* Check the parameters */
   1061            //assert(IS_ADC_ALL_PERIPH(ADCx));
   1062            //assert(IS_FUNCTIONAL_STATE(NewState));
   1063            if (NewState != DISABLE)
   1064            {
   1065              /* Enable the selected ADC DMA request */
   1066              ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
   1067            }
   1068            else
   1069            {
   1070              /* Disable the selected ADC DMA request */
   1071              ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
   1072            }
   1073          }
   1074          
   1075          /**
   1076            * @brief  Enables or disables the ADC DMA request after last transfer (Single-ADC mode)  
   1077            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1078            * @param  NewState: new state of the selected ADC DMA request after last transfer.
   1079            *          This parameter can be: ENABLE or DISABLE.
   1080            * @retval None
   1081            */
   1082          void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1083          {
   1084            /* Check the parameters */
   1085            //assert(IS_ADC_ALL_PERIPH(ADCx));
   1086            //assert(IS_FUNCTIONAL_STATE(NewState));
   1087            if (NewState != DISABLE)
   1088            {
   1089              /* Enable the selected ADC DMA request after last transfer */
   1090              ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
   1091            }
   1092            else
   1093            {
   1094              /* Disable the selected ADC DMA request after last transfer */
   1095              ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
   1096            }
   1097          }
   1098          
   1099          /**
   1100            * @brief  Enables or disables the ADC DMA request after last transfer in multi ADC mode       
   1101            * @param  NewState: new state of the selected ADC DMA request after last transfer.
   1102            *          This parameter can be: ENABLE or DISABLE.
   1103            * @note   if Enabled, DMA requests are issued as long as data are converted and 
   1104            *         DMA mode for multi ADC mode (selected using ADC_CommonInit() function 
   1105            *         by ADC_CommonInitStruct.ADC_DMAAccessMode structure member) is 
   1106            *          ADC_DMAAccessMode_1, ADC_DMAAccessMode_2 or ADC_DMAAccessMode_3.     
   1107            * @retval None
   1108            */
   1109          void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
   1110          {
   1111            /* Check the parameters */
   1112            //assert(IS_FUNCTIONAL_STATE(NewState));
   1113            if (NewState != DISABLE)
   1114            {
   1115              /* Enable the selected ADC DMA request after last transfer */
   1116              ADC->CCR |= (uint32_t)ADC_CCR_DDS;
   1117            }
   1118            else
   1119            {
   1120              /* Disable the selected ADC DMA request after last transfer */
   1121              ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
   1122            }
   1123          }
   1124          /**
   1125            * @}
   1126            */
   1127          
   1128          /** @defgroup ADC_Group6 Injected channels Configuration functions
   1129           *  @brief   Injected channels Configuration functions 
   1130           *
   1131          @verbatim   
   1132           ===============================================================================
   1133                               Injected channels Configuration functions
   1134           ===============================================================================  
   1135          
   1136            This section provide functions allowing to configure the ADC Injected channels,
   1137            it is composed of 2 sub sections : 
   1138              
   1139            1. Configuration functions for Injected channels: This subsection provides 
   1140               functions allowing to configure the ADC injected channels :    
   1141              - Configure the rank in the injected group sequencer for each channel
   1142              - Configure the sampling time for each channel    
   1143              - Activate the Auto injected Mode  
   1144              - Activate the Discontinuous Mode 
   1145              - scan mode activation  
   1146              - External/software trigger source   
   1147              - External trigger edge 
   1148              - injected channels sequencer.
   1149              
   1150             2. Get the Specified Injected channel conversion data: This subsection 
   1151                provides an important function in the ADC peripheral since it returns the 
   1152                converted data of the specific injected channel.
   1153          
   1154          @endverbatim
   1155            * @{
   1156            */ 
   1157          /**
   1158            * @brief  Configures for the selected ADC injected channel its corresponding
   1159            *         rank in the sequencer and its sample time.
   1160            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1161            * @param  ADC_Channel: the ADC channel to configure. 
   1162            *          This parameter can be one of the following values:
   1163            *            @arg ADC_Channel_0: ADC Channel0 selected
   1164            *            @arg ADC_Channel_1: ADC Channel1 selected
   1165            *            @arg ADC_Channel_2: ADC Channel2 selected
   1166            *            @arg ADC_Channel_3: ADC Channel3 selected
   1167            *            @arg ADC_Channel_4: ADC Channel4 selected
   1168            *            @arg ADC_Channel_5: ADC Channel5 selected
   1169            *            @arg ADC_Channel_6: ADC Channel6 selected
   1170            *            @arg ADC_Channel_7: ADC Channel7 selected
   1171            *            @arg ADC_Channel_8: ADC Channel8 selected
   1172            *            @arg ADC_Channel_9: ADC Channel9 selected
   1173            *            @arg ADC_Channel_10: ADC Channel10 selected
   1174            *            @arg ADC_Channel_11: ADC Channel11 selected
   1175            *            @arg ADC_Channel_12: ADC Channel12 selected
   1176            *            @arg ADC_Channel_13: ADC Channel13 selected
   1177            *            @arg ADC_Channel_14: ADC Channel14 selected
   1178            *            @arg ADC_Channel_15: ADC Channel15 selected
   1179            *            @arg ADC_Channel_16: ADC Channel16 selected
   1180            *            @arg ADC_Channel_17: ADC Channel17 selected
   1181            *            @arg ADC_Channel_18: ADC Channel18 selected                       
   1182            * @param  Rank: The rank in the injected group sequencer. 
   1183            *          This parameter must be between 1 to 4.
   1184            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
   1185            *          This parameter can be one of the following values:
   1186            *            @arg ADC_SampleTime_3Cycles: Sample time equal to 3 cycles
   1187            *            @arg ADC_SampleTime_15Cycles: Sample time equal to 15 cycles
   1188            *            @arg ADC_SampleTime_28Cycles: Sample time equal to 28 cycles
   1189            *            @arg ADC_SampleTime_56Cycles: Sample time equal to 56 cycles	
   1190            *            @arg ADC_SampleTime_84Cycles: Sample time equal to 84 cycles	
   1191            *            @arg ADC_SampleTime_112Cycles: Sample time equal to 112 cycles	
   1192            *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
   1193            *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
   1194            * @retval None
   1195            */
   1196          void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
   1197          {
   1198            uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
   1199            /* Check the parameters */
   1200            /*
   1201            assert(IS_ADC_ALL_PERIPH(ADCx));
   1202            assert(IS_ADC_CHANNEL(ADC_Channel));
   1203            assert(IS_ADC_INJECTED_RANK(Rank));
   1204            assert(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
   1205            */
   1206            /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
   1207            if (ADC_Channel > ADC_Channel_9)
   1208            {
   1209              /* Get the old register value */
   1210              tmpreg1 = ADCx->SMPR1;
   1211              /* Calculate the mask to clear */
   1212              tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
   1213              /* Clear the old sample time */
   1214              tmpreg1 &= ~tmpreg2;
   1215              /* Calculate the mask to set */
   1216              tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
   1217              /* Set the new sample time */
   1218              tmpreg1 |= tmpreg2;
   1219              /* Store the new register value */
   1220              ADCx->SMPR1 = tmpreg1;
   1221            }
   1222            else /* ADC_Channel include in ADC_Channel_[0..9] */
   1223            {
   1224              /* Get the old register value */
   1225              tmpreg1 = ADCx->SMPR2;
   1226              /* Calculate the mask to clear */
   1227              tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
   1228              /* Clear the old sample time */
   1229              tmpreg1 &= ~tmpreg2;
   1230              /* Calculate the mask to set */
   1231              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
   1232              /* Set the new sample time */
   1233              tmpreg1 |= tmpreg2;
   1234              /* Store the new register value */
   1235              ADCx->SMPR2 = tmpreg1;
   1236            }
   1237            /* Rank configuration */
   1238            /* Get the old register value */
   1239            tmpreg1 = ADCx->JSQR;
   1240            /* Get JL value: Number = JL+1 */
   1241            tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
   1242            /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
   1243            tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   1244            /* Clear the old JSQx bits for the selected rank */
   1245            tmpreg1 &= ~tmpreg2;
   1246            /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
   1247            tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   1248            /* Set the JSQx bits for the selected rank */
   1249            tmpreg1 |= tmpreg2;
   1250            /* Store the new register value */
   1251            ADCx->JSQR = tmpreg1;
   1252          }
   1253          
   1254          /**
   1255            * @brief  Configures the sequencer length for injected channels
   1256            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1257            * @param  Length: The sequencer length. 
   1258            *          This parameter must be a number between 1 to 4.
   1259            * @retval None
   1260            */
   1261          void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
   1262          {
   1263            uint32_t tmpreg1 = 0;
   1264            uint32_t tmpreg2 = 0;
   1265            /* Check the parameters */
   1266            //assert(IS_ADC_ALL_PERIPH(ADCx));
   1267            //assert(IS_ADC_INJECTED_LENGTH(Length));
   1268            
   1269            /* Get the old register value */
   1270            tmpreg1 = ADCx->JSQR;
   1271            
   1272            /* Clear the old injected sequence length JL bits */
   1273            tmpreg1 &= JSQR_JL_RESET;
   1274            
   1275            /* Set the injected sequence length JL bits */
   1276            tmpreg2 = Length - 1; 
   1277            tmpreg1 |= tmpreg2 << 20;
   1278            
   1279            /* Store the new register value */
   1280            ADCx->JSQR = tmpreg1;
   1281          }
   1282          
   1283          /**
   1284            * @brief  Set the injected channels conversion value offset
   1285            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1286            * @param  ADC_InjectedChannel: the ADC injected channel to set its offset. 
   1287            *          This parameter can be one of the following values:
   1288            *            @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1289            *            @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1290            *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1291            *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1292            * @param  Offset: the offset value for the selected ADC injected channel
   1293            *          This parameter must be a 12bit value.
   1294            * @retval None
   1295            */
   1296          void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
   1297          {
   1298              __IO uint32_t tmp = 0;
   1299            /* Check the parameters */
   1300            //assert(IS_ADC_ALL_PERIPH(ADCx));
   1301            //assert(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1302            //assert(IS_ADC_OFFSET(Offset));
   1303            
   1304            tmp = (uint32_t)ADCx;
   1305            tmp += ADC_InjectedChannel;
   1306            
   1307            /* Set the selected injected channel data offset */
   1308           *(__IO uint32_t *) tmp = (uint32_t)Offset;
   1309          }
   1310          
   1311           /**
   1312            * @brief  Configures the ADCx external trigger for injected channels conversion.
   1313            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1314            * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected conversion.
   1315            *          This parameter can be one of the following values:                    
   1316            *            @arg ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture compare4 selected 
   1317            *            @arg ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event selected 
   1318            *            @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected 
   1319            *            @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected 
   1320            *            @arg ADC_ExternalTrigInjecConv_T3_CC2: Timer3 capture compare2 selected 
   1321            *            @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected 
   1322            *            @arg ADC_ExternalTrigInjecConv_T4_CC1: Timer4 capture compare1 selected                       
   1323            *            @arg ADC_ExternalTrigInjecConv_T4_CC2: Timer4 capture compare2 selected 
   1324            *            @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected                        
   1325            *            @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected 
   1326            *            @arg ADC_ExternalTrigInjecConv_T5_CC4: Timer5 capture compare4 selected                        
   1327            *            @arg ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event selected                        
   1328            *            @arg ADC_ExternalTrigInjecConv_T8_CC2: Timer8 capture compare2 selected
   1329            *            @arg ADC_ExternalTrigInjecConv_T8_CC3: Timer8 capture compare3 selected                        
   1330            *            @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected 
   1331            *            @arg ADC_ExternalTrigInjecConv_Ext_IT15: External interrupt line 15 event selected                          
   1332            * @retval None
   1333            */
   1334          void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
   1335          {
   1336            uint32_t tmpreg = 0;
   1337            /* Check the parameters */
   1338            //assert(IS_ADC_ALL_PERIPH(ADCx));
   1339            //assert(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
   1340            
   1341            /* Get the old register value */
   1342            tmpreg = ADCx->CR2;
   1343            
   1344            /* Clear the old external event selection for injected group */
   1345            tmpreg &= CR2_JEXTSEL_RESET;
   1346            
   1347            /* Set the external event selection for injected group */
   1348            tmpreg |= ADC_ExternalTrigInjecConv;
   1349            
   1350            /* Store the new register value */
   1351            ADCx->CR2 = tmpreg;
   1352          }
   1353          
   1354          /**
   1355            * @brief  Configures the ADCx external trigger edge for injected channels conversion.
   1356            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1357            * @param  ADC_ExternalTrigInjecConvEdge: specifies the ADC external trigger edge
   1358            *         to start injected conversion. 
   1359            *          This parameter can be one of the following values:
   1360            *            @arg ADC_ExternalTrigInjecConvEdge_None: external trigger disabled for 
   1361            *                                                     injected conversion
   1362            *            @arg ADC_ExternalTrigInjecConvEdge_Rising: detection on rising edge
   1363            *            @arg ADC_ExternalTrigInjecConvEdge_Falling: detection on falling edge
   1364            *            @arg ADC_ExternalTrigInjecConvEdge_RisingFalling: detection on both rising 
   1365            *                                                               and falling edge
   1366            * @retval None
   1367            */
   1368          void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
   1369          {
   1370            uint32_t tmpreg = 0;
   1371            /* Check the parameters */
   1372            //assert(IS_ADC_ALL_PERIPH(ADCx));
   1373            //assert(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
   1374            /* Get the old register value */
   1375            tmpreg = ADCx->CR2;
   1376            /* Clear the old external trigger edge for injected group */
   1377            tmpreg &= CR2_JEXTEN_RESET;
   1378            /* Set the new external trigger edge for injected group */
   1379            tmpreg |= ADC_ExternalTrigInjecConvEdge;
   1380            /* Store the new register value */
   1381            ADCx->CR2 = tmpreg;
   1382          }
   1383          
   1384          /**
   1385            * @brief  Enables the selected ADC software start conversion of the injected channels.
   1386            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1387            * @retval None
   1388            */
   1389          void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
   1390          {
   1391            /* Check the parameters */
   1392            //assert(IS_ADC_ALL_PERIPH(ADCx));
   1393            /* Enable the selected ADC conversion for injected group */
   1394            ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
   1395          }
   1396          
   1397          /**
   1398            * @brief  Gets the selected ADC Software start injected conversion Status.
   1399            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1400            * @retval The new state of ADC software start injected conversion (SET or RESET).
   1401            */
   1402          FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
   1403          {
   1404            FlagStatus bitstatus = RESET;
   1405            /* Check the parameters */
   1406            //assert(IS_ADC_ALL_PERIPH(ADCx));
   1407            
   1408            /* Check the status of JSWSTART bit */
   1409            if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
   1410            {
   1411              /* JSWSTART bit is set */
   1412              bitstatus = SET;
   1413            }
   1414            else
   1415            {
   1416              /* JSWSTART bit is reset */
   1417              bitstatus = RESET;
   1418            }
   1419            /* Return the JSWSTART bit status */
   1420            return  bitstatus;
   1421          }
   1422          
   1423          /**
   1424            * @brief  Enables or disables the selected ADC automatic injected group 
   1425            *         conversion after regular one.
   1426            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1427            * @param  NewState: new state of the selected ADC auto injected conversion
   1428            *          This parameter can be: ENABLE or DISABLE.
   1429            * @retval None
   1430            */
   1431          void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1432          {
   1433            /* Check the parameters */
   1434            //assert(IS_ADC_ALL_PERIPH(ADCx));
   1435            //assert(IS_FUNCTIONAL_STATE(NewState));
   1436            if (NewState != DISABLE)
   1437            {
   1438              /* Enable the selected ADC automatic injected group conversion */
   1439              ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
   1440            }
   1441            else
   1442            {
   1443              /* Disable the selected ADC automatic injected group conversion */
   1444              ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
   1445            }
   1446          }
   1447          
   1448          /**
   1449            * @brief  Enables or disables the discontinuous mode for injected group 
   1450            *         channel for the specified ADC
   1451            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1452            * @param  NewState: new state of the selected ADC discontinuous mode on injected
   1453            *         group channel.
   1454            *          This parameter can be: ENABLE or DISABLE.
   1455            * @retval None
   1456            */
   1457          void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1458          {
   1459            /* Check the parameters */
   1460            ///assert(IS_ADC_ALL_PERIPH(ADCx));
   1461            //assert(IS_FUNCTIONAL_STATE(NewState));
   1462            if (NewState != DISABLE)
   1463            {
   1464              /* Enable the selected ADC injected discontinuous mode */
   1465              ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
   1466            }
   1467            else
   1468            {
   1469              /* Disable the selected ADC injected discontinuous mode */
   1470              ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
   1471            }
   1472          }
   1473          
   1474          /**
   1475            * @brief  Returns the ADC injected channel conversion result
   1476            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1477            * @param  ADC_InjectedChannel: the converted ADC injected channel.
   1478            *          This parameter can be one of the following values:
   1479            *            @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1480            *            @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1481            *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1482            *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1483            * @retval The Data conversion value.
   1484            */
   1485          uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
   1486          {
   1487            __IO uint32_t tmp = 0;
   1488            
   1489            /* Check the parameters */
   1490            //assert(IS_ADC_ALL_PERIPH(ADCx));
   1491            //assert(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1492          
   1493            tmp = (uint32_t)ADCx;
   1494            tmp += ADC_InjectedChannel + JDR_OFFSET;
   1495            
   1496            /* Returns the selected injected channel conversion data value */
   1497            return (uint16_t) (*(__IO uint32_t*)  tmp); 
   1498          }
   1499          /**
   1500            * @}
   1501            */
   1502          
   1503          /** @defgroup ADC_Group7 Interrupts and flags management functions
   1504           *  @brief   Interrupts and flags management functions
   1505           *
   1506          @verbatim   
   1507           ===============================================================================
   1508                             Interrupts and flags management functions
   1509           ===============================================================================  
   1510          
   1511            This section provides functions allowing to configure the ADC Interrupts and 
   1512            to get the status and clear flags and Interrupts pending bits.
   1513            
   1514            Each ADC provides 4 Interrupts sources and 6 Flags which can be divided into 
   1515            3 groups:
   1516            
   1517            I. Flags and Interrupts for ADC regular channels
   1518            =================================================
   1519            Flags :
   1520            ---------- 
   1521               1. ADC_FLAG_OVR : Overrun detection when regular converted data are lost
   1522          
   1523               2. ADC_FLAG_EOC : Regular channel end of conversion ==> to indicate (depending 
   1524                        on EOCS bit, managed by ADC_EOCOnEachRegularChannelCmd() ) the end of:
   1525                         ==> a regular CHANNEL conversion 
   1526                         ==> sequence of regular GROUP conversions .
   1527          
   1528               3. ADC_FLAG_STRT: Regular channel start ==> to indicate when regular CHANNEL 
   1529                        conversion starts.
   1530          
   1531            Interrupts :
   1532            ------------
   1533               1. ADC_IT_OVR : specifies the interrupt source for Overrun detection event.  
   1534               2. ADC_IT_EOC : specifies the interrupt source for Regular channel end of 
   1535                               conversion event.
   1536            
   1537            
   1538            II. Flags and Interrupts for ADC Injected channels
   1539            =================================================
   1540            Flags :
   1541            ---------- 
   1542               1. ADC_FLAG_JEOC : Injected channel end of conversion ==> to indicate at 
   1543                         the end of injected GROUP conversion  
   1544                        
   1545               2. ADC_FLAG_JSTRT: Injected channel start ==> to indicate hardware when 
   1546                         injected GROUP conversion starts.
   1547          
   1548            Interrupts :
   1549            ------------
   1550               1. ADC_IT_JEOC : specifies the interrupt source for Injected channel end of 
   1551                                conversion event.     
   1552          
   1553            III. General Flags and Interrupts for the ADC
   1554            ================================================= 
   1555            Flags :
   1556            ---------- 
   1557               1. ADC_FLAG_AWD: Analog watchdog ==> to indicate if the converted voltage 
   1558                        crosses the programmed thresholds values.
   1559                        
   1560            Interrupts :
   1561            ------------
   1562               1. ADC_IT_AWD : specifies the interrupt source for Analog watchdog event. 
   1563          
   1564            
   1565            The user should identify which mode will be used in his application to manage 
   1566            the ADC controller events: Polling mode or Interrupt mode.
   1567            
   1568            In the Polling Mode it is advised to use the following functions:
   1569                - ADC_GetFlagStatus() : to check if flags events occur. 
   1570                - ADC_ClearFlag()     : to clear the flags events.
   1571                
   1572            In the Interrupt Mode it is advised to use the following functions:
   1573               - ADC_ITConfig()          : to enable or disable the interrupt source.
   1574               - ADC_GetITStatus()       : to check if Interrupt occurs.
   1575               - ADC_ClearITPendingBit() : to clear the Interrupt pending Bit 
   1576                                           (corresponding Flag). 
   1577          @endverbatim
   1578            * @{
   1579            */ 
   1580          /**
   1581            * @brief  Enables or disables the specified ADC interrupts.
   1582            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1583            * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled. 
   1584            *          This parameter can be one of the following values:
   1585            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1586            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1587            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1588            *            @arg ADC_IT_OVR: Overrun interrupt enable                       
   1589            * @param  NewState: new state of the specified ADC interrupts.
   1590            *          This parameter can be: ENABLE or DISABLE.
   1591            * @retval None
   1592            */
   1593          void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
   1594          {
   1595            uint32_t itmask = 0;
   1596            /* Check the parameters */
   1597            //assert(IS_ADC_ALL_PERIPH(ADCx));
   1598            //assert(IS_FUNCTIONAL_STATE(NewState));
   1599            //assert(IS_ADC_IT(ADC_IT)); 
   1600          
   1601            /* Get the ADC IT index */
   1602            itmask = (uint8_t)ADC_IT;
   1603            itmask = (uint32_t)0x01 << itmask;    
   1604          
   1605            if (NewState != DISABLE)
   1606            {
   1607              /* Enable the selected ADC interrupts */
   1608              ADCx->CR1 |= itmask;
   1609            }
   1610            else
   1611            {
   1612              /* Disable the selected ADC interrupts */
   1613              ADCx->CR1 &= (~(uint32_t)itmask);
   1614            }
   1615          }
   1616          
   1617          /**
   1618            * @brief  Checks whether the specified ADC flag is set or not.
   1619            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1620            * @param  ADC_FLAG: specifies the flag to check. 
   1621            *          This parameter can be one of the following values:
   1622            *            @arg ADC_FLAG_AWD: Analog watchdog flag
   1623            *            @arg ADC_FLAG_EOC: End of conversion flag
   1624            *            @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1625            *            @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1626            *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1627            *            @arg ADC_FLAG_OVR: Overrun flag                                                 
   1628            * @retval The new state of ADC_FLAG (SET or RESET).
   1629            */
   1630          FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
   1631          {
   1632            FlagStatus bitstatus = RESET;
   1633            /* Check the parameters */
   1634            //assert(IS_ADC_ALL_PERIPH(ADCx));
   1635            //assert(IS_ADC_GET_FLAG(ADC_FLAG));
   1636          
   1637            /* Check the status of the specified ADC flag */
   1638            if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
   1639            {
   1640              /* ADC_FLAG is set */
   1641              bitstatus = SET;
   1642            }
   1643            else
   1644            {
   1645              /* ADC_FLAG is reset */
   1646              bitstatus = RESET;
   1647            }
   1648            /* Return the ADC_FLAG status */
   1649            return  bitstatus;
   1650          }
   1651          
   1652          /**
   1653            * @brief  Clears the ADCx's pending flags.
   1654            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1655            * @param  ADC_FLAG: specifies the flag to clear. 
   1656            *          This parameter can be any combination of the following values:
   1657            *            @arg ADC_FLAG_AWD: Analog watchdog flag
   1658            *            @arg ADC_FLAG_EOC: End of conversion flag
   1659            *            @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1660            *            @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1661            *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1662            *            @arg ADC_FLAG_OVR: Overrun flag                          
   1663            * @retval None
   1664            */
   1665          void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
   1666          {
   1667            /* Check the parameters */
   1668            //assert(IS_ADC_ALL_PERIPH(ADCx));
   1669            //assert(IS_ADC_CLEAR_FLAG(ADC_FLAG));
   1670          
   1671            /* Clear the selected ADC flags */
   1672            ADCx->SR = ~(uint32_t)ADC_FLAG;
   1673          }
   1674          
   1675          /**
   1676            * @brief  Checks whether the specified ADC interrupt has occurred or not.
   1677            * @param  ADCx:   where x can be 1, 2 or 3 to select the ADC peripheral.
   1678            * @param  ADC_IT: specifies the ADC interrupt source to check. 
   1679            *          This parameter can be one of the following values:
   1680            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1681            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1682            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1683            *            @arg ADC_IT_OVR: Overrun interrupt mask                        
   1684            * @retval The new state of ADC_IT (SET or RESET).
   1685            */
   1686          ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1687          {
   1688            ITStatus bitstatus = RESET;
   1689            uint32_t itmask = 0, enablestatus = 0;
   1690          
   1691            /* Check the parameters */
   1692            //assert(IS_ADC_ALL_PERIPH(ADCx));
   1693            //assert(IS_ADC_IT(ADC_IT));
   1694          
   1695            /* Get the ADC IT index */
   1696            itmask = ADC_IT >> 8;
   1697          
   1698            /* Get the ADC_IT enable bit status */
   1699            enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
   1700          
   1701            /* Check the status of the specified ADC interrupt */
   1702            if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
   1703            {
   1704              /* ADC_IT is set */
   1705              bitstatus = SET;
   1706            }
   1707            else
   1708            {
   1709              /* ADC_IT is reset */
   1710              bitstatus = RESET;
   1711            }
   1712            /* Return the ADC_IT status */
   1713            return  bitstatus;
   1714          }
   1715          
   1716          /**
   1717            * @brief  Clears the ADCx's interrupt pending bits.
   1718            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1719            * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
   1720            *          This parameter can be one of the following values:
   1721            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1722            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1723            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1724            *            @arg ADC_IT_OVR: Overrun interrupt mask                         
   1725            * @retval None
   1726            */
   1727          void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1728          {
   1729            uint8_t itmask = 0;
   1730            /* Check the parameters */
   1731            //assert(IS_ADC_ALL_PERIPH(ADCx));
   1732            //assert(IS_ADC_IT(ADC_IT)); 
   1733            /* Get the ADC IT index */
   1734            itmask = (uint8_t)(ADC_IT >> 8);
   1735            /* Clear the selected ADC interrupt pending bits */
   1736            ADCx->SR = ~(uint32_t)itmask;
   1737          }                    
   1738          /**
   1739            * @}
   1740            */ 
   1741          
   1742          /**
   1743            * @}
   1744            */
   1745          
   1746          /**
   1747            * @}
   1748            */ 
   1749          
   1750          /**
   1751            * @}
   1752            */ 
   1753          
   1754          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     ADC_AnalogWatchdogCmd               0
     ADC_AnalogWatchdogSingleChannelConfig
                                         0
     ADC_AnalogWatchdogThresholdsConfig
                                         0
     ADC_AutoInjectedConvCmd             0
     ADC_ClearFlag                       0
     ADC_ClearITPendingBit               0
     ADC_Cmd                             0
     ADC_CommonInit                      0
     ADC_CommonStructInit                0
     ADC_ContinuousModeCmd              16
     ADC_DMACmd                          0
     ADC_DMARequestAfterLastTransferCmd
                                         0
     ADC_DeInit                          8
     ADC_DiscModeChannelCountConfig      4
     ADC_DiscModeCmd                     0
     ADC_EOCOnEachRegularChannelCmd     16
     ADC_ExternalTrigInjectedConvConfig
                                         0
     ADC_ExternalTrigInjectedConvEdgeConfig
                                         0
     ADC_GetConversionValue              0
     ADC_GetFlagStatus                   0
     ADC_GetITStatus                    12
     ADC_GetInjectedConversionValue      4
     ADC_GetMultiModeConversionValue
                                         0
     ADC_GetSoftwareStartConvStatus     16
     ADC_GetSoftwareStartInjectedConvCmdStatus
                                         0
     ADC_ITConfig                        4
     ADC_Init                            8
     ADC_InjectedChannelConfig          20
     ADC_InjectedDiscModeCmd             0
     ADC_InjectedSequencerLengthConfig
                                         4
     ADC_MultiModeDMARequestAfterLastTransferCmd
                                         0
     ADC_RegularChannelConfig           16
     ADC_SetInjectedOffset               4
     ADC_SoftwareStartConv               8
     ADC_SoftwareStartInjectedConv       0
     ADC_StructInit                      0
     ADC_TempSensorVrefintCmd            0
     ADC_VBATCmd                         0


   Section sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     ADC_DeInit                                       24
     ADC_Init                                         84
     ADC_StructInit                                   30
     ADC_CommonInit                                   40
     ADC_CommonStructInit                             18
     ADC_Cmd                                          26
     ADC_AnalogWatchdogCmd                            16
     ADC_AnalogWatchdogThresholdsConfig
                                                      10
     ADC_AnalogWatchdogSingleChannelConfig
                                                      18
     ADC_TempSensorVrefintCmd                         34
     ADC_VBATCmd                                      34
     ADC_RegularChannelConfig                        238
     ADC_SoftwareStartConv                            52
     ADC_GetSoftwareStartConvStatus                   66
     ADC_EOCOnEachRegularChannelCmd                  102
     ADC_ContinuousModeCmd                           102
     ADC_DiscModeChannelCountConfig                   30
     ADC_DiscModeCmd                                  26
     ADC_GetConversionValue                            6
     ADC_GetMultiModeConversionValue
                                                       6
     ADC_DMACmd                                       28
     ADC_DMARequestAfterLastTransferCmd
                                                      28
     ADC_MultiModeDMARequestAfterLastTransferCmd
                                                      34
     ADC_InjectedChannelConfig                       178
     ADC_InjectedSequencerLengthConfig
                                                      30
     ADC_SetInjectedOffset                            26
     ADC_ExternalTrigInjectedConvConfig
                                                      16
     ADC_ExternalTrigInjectedConvEdgeConfig
                                                      16
     ADC_SoftwareStartInjectedConv                    10
     ADC_GetSoftwareStartInjectedConvCmdStatus
                                                      24
     ADC_AutoInjectedConvCmd                          26
     ADC_InjectedDiscModeCmd                          26
     ADC_GetInjectedConversionValue                   32
     ADC_ITConfig                                     40
     ADC_GetFlagStatus                                26
     ADC_ClearFlag                                     8
     ADC_GetITStatus                                  54
     ADC_ClearITPendingBit                            16
     ??DataTable13                                     4
     ??DataTable13_1                                   4
     ??DataTable13_2                                   4
     ??DataTable13_3                                   4
     ??DataTable13_4                                   4
     ??DataTable13_5                                   4
     ??DataTable13_6                                   4
     ??DataTable13_7                                   4
     ??DataTable13_8                                   4
     ?<Constant "IS_ADC_ALL_PERIPH(ADCx)">            24
     ?<Constant "D:\\work\\\320\320\261\352\262\372  176
     ?<Constant "IS_FUNCTIONAL_STATE(N...">           32

 
 1 848 bytes in section .text
 
 1 848 bytes of CODE memory

Errors: none
Warnings: none
