###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.10.2.52244/W32 for ARM     04/Dec/2013  10:58:14 #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\STM32F2xx_StdPeriph_Driver\src\stm32f2xx #
#                    _tim.c                                                   #
#    Command line =  D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\STM32F2xx_StdPeriph_Driver\src\stm32f2xx #
#                    _tim.c -D STM32F10X_CL -D USE_STDPERIPH_DRIVER -lcN      #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\List\ -lb                    #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\List\ -o                     #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\Obj\ --no_cse --no_unroll    #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --warnings_are_errors --fpu=None --dlib_config        #
#                    E:\SoftwareInstall\arm\INC\c\DLib_Config_Normal.h -I     #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\..\inc\ -I                         #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\..\CMSIS\CM3\CoreSupport\ -I       #
#                    D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\..\STM32F2xx_StdPeriph_Driver\inc\ #
#                     -I D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\ #
#                    改进型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_13081 #
#                    5_IAR6.1\STM32_Boot\EWARM\..\CMSIS\CM3\DeviceSupport\ST\ #
#                    STM32F2xx\ -On --use_c++_inline                          #
#    List file    =  D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\List\stm32f2xx_tim.lst       #
#    Object file  =  D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进 #
#                    型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IA #
#                    R6.1\STM32_Boot\EWARM\Debug\Obj\stm32f2xx_tim.o          #
#                                                                             #
#                                                                             #
###############################################################################

D:\work\行标产品\改进版一体机\源程序\改进型EGS701-1\改进型EGS701-1\STM32F2xx_Boot_V1.62\STM32F2xx_Boot_130815_IAR6.1\STM32_Boot\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_tim.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    18-April-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the TIM peripheral:
      9            *            - TimeBase management
     10            *            - Output Compare management
     11            *            - Input Capture management
     12            *            - Advanced-control timers (TIM1 and TIM8) specific features  
     13            *            - Interrupts, DMA and flags management
     14            *            - Clocks management
     15            *            - Synchronization management
     16            *            - Specific interface management
     17            *            - Specific remapping management      
     18            *              
     19            *  @verbatim
     20            *  
     21            *          ===================================================================
     22            *                                 How to use this driver
     23            *          ===================================================================
     24            *          This driver provides functions to configure and program the TIM 
     25            *          of all STM32F2xx devices.
     26            *          These functions are split in 9 groups: 
     27            *   
     28            *          1. TIM TimeBase management: this group includes all needed functions 
     29            *             to configure the TM Timebase unit:
     30            *                   - Set/Get Prescaler
     31            *                   - Set/Get Autoreload  
     32            *                   - Counter modes configuration
     33            *                   - Set Clock division  
     34            *                   - Select the One Pulse mode
     35            *                   - Update Request Configuration
     36            *                   - Update Disable Configuration
     37            *                   - Auto-Preload Configuration 
     38            *                   - Enable/Disable the counter     
     39            *                 
     40            *          2. TIM Output Compare management: this group includes all needed 
     41            *             functions to configure the Capture/Compare unit used in Output 
     42            *             compare mode: 
     43            *                   - Configure each channel, independently, in Output Compare mode
     44            *                   - Select the output compare modes
     45            *                   - Select the Polarities of each channel
     46            *                   - Set/Get the Capture/Compare register values
     47            *                   - Select the Output Compare Fast mode 
     48            *                   - Select the Output Compare Forced mode  
     49            *                   - Output Compare-Preload Configuration 
     50            *                   - Clear Output Compare Reference
     51            *                   - Select the OCREF Clear signal
     52            *                   - Enable/Disable the Capture/Compare Channels    
     53            *                   
     54            *          3. TIM Input Capture management: this group includes all needed 
     55            *             functions to configure the Capture/Compare unit used in 
     56            *             Input Capture mode:
     57            *                   - Configure each channel in input capture mode
     58            *                   - Configure Channel1/2 in PWM Input mode
     59            *                   - Set the Input Capture Prescaler
     60            *                   - Get the Capture/Compare values      
     61            *                   
     62            *          4. Advanced-control timers (TIM1 and TIM8) specific features
     63            *                   - Configures the Break input, dead time, Lock level, the OSSI,
     64            *                      the OSSR State and the AOE(automatic output enable)
     65            *                   - Enable/Disable the TIM peripheral Main Outputs
     66            *                   - Select the Commutation event
     67            *                   - Set/Reset the Capture Compare Preload Control bit
     68            *                              
     69            *          5. TIM interrupts, DMA and flags management
     70            *                   - Enable/Disable interrupt sources
     71            *                   - Get flags status
     72            *                   - Clear flags/ Pending bits
     73            *                   - Enable/Disable DMA requests 
     74            *                   - Configure DMA burst mode
     75            *                   - Select CaptureCompare DMA request  
     76            *              
     77            *          6. TIM clocks management: this group includes all needed functions 
     78            *             to configure the clock controller unit:
     79            *                   - Select internal/External clock
     80            *                   - Select the external clock mode: ETR(Mode1/Mode2), TIx or ITRx
     81            *         
     82            *          7. TIM synchronization management: this group includes all needed 
     83            *             functions to configure the Synchronization unit:
     84            *                   - Select Input Trigger  
     85            *                   - Select Output Trigger  
     86            *                   - Select Master Slave Mode 
     87            *                   - ETR Configuration when used as external trigger   
     88            *     
     89            *          8. TIM specific interface management, this group includes all 
     90            *             needed functions to use the specific TIM interface:
     91            *                   - Encoder Interface Configuration
     92            *                   - Select Hall Sensor   
     93            *         
     94            *          9. TIM specific remapping management includes the Remapping 
     95            *             configuration of specific timers               
     96            *   
     97            *  @endverbatim
     98            *    
     99            ******************************************************************************
    100            * @attention
    101            *
    102            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
    103            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
    104            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
    105            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
    106            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
    107            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
    108            *
    109            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
    110            ******************************************************************************
    111            */
    112          
    113          /* Includes ------------------------------------------------------------------*/
    114          #include "stm32f2xx_tim.h"
    115          #include "stm32f2xx_rcc.h"
    116          #include "assert.h"
    117          /** @addtogroup STM32F2xx_StdPeriph_Driver
    118            * @{
    119            */
    120          
    121          /** @defgroup TIM 
    122            * @brief TIM driver modules
    123            * @{
    124            */
    125          
    126          /* Private typedef -----------------------------------------------------------*/
    127          /* Private define ------------------------------------------------------------*/
    128          
    129          /* ---------------------- TIM registers bit mask ------------------------ */
    130          #define SMCR_ETR_MASK      ((uint16_t)0x00FF) 
    131          #define CCMR_OFFSET        ((uint16_t)0x0018)
    132          #define CCER_CCE_SET       ((uint16_t)0x0001)  
    133          #define	CCER_CCNE_SET      ((uint16_t)0x0004) 
    134          #define CCMR_OC13M_MASK    ((uint16_t)0xFF8F)
    135          #define CCMR_OC24M_MASK    ((uint16_t)0x8FFF) 
    136          
    137          /* Private macro -------------------------------------------------------------*/
    138          /* Private variables ---------------------------------------------------------*/
    139          /* Private function prototypes -----------------------------------------------*/
    140          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    141                                 uint16_t TIM_ICFilter);
    142          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    143                                 uint16_t TIM_ICFilter);
    144          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    145                                 uint16_t TIM_ICFilter);
    146          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
    147                                 uint16_t TIM_ICFilter);
    148          
    149          /* Private functions ---------------------------------------------------------*/
    150          
    151          /** @defgroup TIM_Private_Functions
    152            * @{
    153            */
    154          
    155          /** @defgroup TIM_Group1 TimeBase management functions
    156           *  @brief   TimeBase management functions 
    157           *
    158          @verbatim   
    159           ===============================================================================
    160                                 TimeBase management functions
    161           ===============================================================================  
    162            
    163                 ===================================================================      
    164                        TIM Driver: how to use it in Timing(Time base) Mode
    165                 =================================================================== 
    166                 To use the Timer in Timing(Time base) mode, the following steps are mandatory:
    167                 
    168                 1. Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function
    169                              
    170                 2. Fill the TIM_TimeBaseInitStruct with the desired parameters.
    171                 
    172                 3. Call TIM_TimeBaseInit(TIMx, &TIM_TimeBaseInitStruct) to configure the Time Base unit
    173                    with the corresponding configuration
    174                    
    175                 4. Enable the NVIC if you need to generate the update interrupt. 
    176                    
    177                 5. Enable the corresponding interrupt using the function TIM_ITConfig(TIMx, TIM_IT_Update) 
    178                 
    179                 6. Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
    180                       
    181                 Note1: All other functions can be used separately to modify, if needed,
    182                    a specific feature of the Timer. 
    183          
    184          @endverbatim
    185            * @{
    186            */
    187            
    188          /**
    189            * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
    190            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    191            * @retval None
    192          
    193            */
    194          void TIM_DeInit(TIM_TypeDef* TIMx)
    195          {
    196            /* Check the parameters */
    197            assert(IS_TIM_ALL_PERIPH(TIMx)); 
    198           
    199            if (TIMx == TIM1)
    200            {
    201              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
    202              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
    203            } 
    204            else if (TIMx == TIM2) 
    205            {     
    206              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
    207              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
    208            }  
    209            else if (TIMx == TIM3)
    210            { 
    211              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    212              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
    213            }  
    214            else if (TIMx == TIM4)
    215            { 
    216              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
    217              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
    218            }  
    219            else if (TIMx == TIM5)
    220            {      
    221              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
    222              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
    223            }  
    224            else if (TIMx == TIM6)  
    225            {    
    226              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
    227              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
    228            }  
    229            else if (TIMx == TIM7)
    230            {      
    231              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
    232              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
    233            }  
    234            else if (TIMx == TIM8)
    235            {      
    236              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
    237              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
    238            }  
    239            else if (TIMx == TIM9)
    240            {      
    241              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
    242              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
    243             }  
    244            else if (TIMx == TIM10)
    245            {      
    246              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
    247              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
    248            }  
    249            else if (TIMx == TIM11) 
    250            {     
    251              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
    252              RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
    253            }  
    254            else if (TIMx == TIM12)
    255            {      
    256              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
    257              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
    258            }  
    259            else if (TIMx == TIM13) 
    260            {       
    261              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
    262              RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
    263            }  
    264            else
    265            { 
    266              if (TIMx == TIM14) 
    267              {     
    268                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
    269                RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
    270              }   
    271            }
    272          }
    273          
    274          /**
    275            * @brief  Initializes the TIMx Time Base Unit peripheral according to 
    276            *         the specified parameters in the TIM_TimeBaseInitStruct.
    277            * @param  TIMx: where x can be  1 to 14 to select the TIM peripheral.
    278            * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure
    279            *         that contains the configuration information for the specified TIM peripheral.
    280            * @retval None
    281            */
    282          void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    283          {
    284            uint16_t tmpcr1 = 0;
    285          
    286            /* Check the parameters */
    287            assert(IS_TIM_ALL_PERIPH(TIMx)); 
    288            assert(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
    289            assert(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
    290          
    291            tmpcr1 = TIMx->CR1;  
    292          
    293            if((TIMx == TIM1) || (TIMx == TIM8)||
    294               (TIMx == TIM2) || (TIMx == TIM3)||
    295               (TIMx == TIM4) || (TIMx == TIM5)) 
    296            {
    297              /* Select the Counter Mode */
    298              tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
    299              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
    300            }
    301           
    302            if((TIMx != TIM6) && (TIMx != TIM7))
    303            {
    304              /* Set the clock division */
    305              tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
    306              tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
    307            }
    308          
    309            TIMx->CR1 = tmpcr1;
    310          
    311            /* Set the Autoreload value */
    312            TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
    313           
    314            /* Set the Prescaler value */
    315            TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
    316              
    317            if ((TIMx == TIM1) || (TIMx == TIM8))  
    318            {
    319              /* Set the Repetition Counter value */
    320              TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
    321            }
    322          
    323            /* Generate an update event to reload the Prescaler 
    324               and the repetition counter(only for TIM1 and TIM8) value immediatly */
    325            TIMx->EGR = TIM_PSCReloadMode_Immediate;          
    326          }
    327          
    328          /**
    329            * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.
    330            * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
    331            *         structure which will be initialized.
    332            * @retval None
    333            */
    334          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    335          {
    336            /* Set the default configuration */
    337            TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
    338            TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
    339            TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
    340            TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
    341            TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
    342          }
    343          
    344          /**
    345            * @brief  Configures the TIMx Prescaler.
    346            * @param  TIMx: where x can be  1 to 14 to select the TIM peripheral.
    347            * @param  Prescaler: specifies the Prescaler Register value
    348            * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
    349            *          This parameter can be one of the following values:
    350            *            @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
    351            *            @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediatly.
    352            * @retval None
    353            */
    354          void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
    355          {
    356            /* Check the parameters */
    357            assert(IS_TIM_ALL_PERIPH(TIMx));
    358            assert(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
    359            /* Set the Prescaler value */
    360            TIMx->PSC = Prescaler;
    361            /* Set or reset the UG Bit */
    362            TIMx->EGR = TIM_PSCReloadMode;
    363          }
    364          
    365          /**
    366            * @brief  Specifies the TIMx Counter Mode to be used.
    367            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    368            * @param  TIM_CounterMode: specifies the Counter Mode to be used
    369            *          This parameter can be one of the following values:
    370            *            @arg TIM_CounterMode_Up: TIM Up Counting Mode
    371            *            @arg TIM_CounterMode_Down: TIM Down Counting Mode
    372            *            @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
    373            *            @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
    374            *            @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
    375            * @retval None
    376            */
    377          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
    378          {
    379            uint16_t tmpcr1 = 0;
    380          
    381            /* Check the parameters */
    382            assert(IS_TIM_LIST3_PERIPH(TIMx));
    383            assert(IS_TIM_COUNTER_MODE(TIM_CounterMode));
    384          
    385            tmpcr1 = TIMx->CR1;
    386          
    387            /* Reset the CMS and DIR Bits */
    388            tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
    389          
    390            /* Set the Counter Mode */
    391            tmpcr1 |= TIM_CounterMode;
    392          
    393            /* Write to TIMx CR1 register */
    394            TIMx->CR1 = tmpcr1;
    395          }
    396          
    397          /**
    398            * @brief  Sets the TIMx Counter Register value
    399            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    400            * @param  Counter: specifies the Counter register new value.
    401            * @retval None
    402            */
    403          void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
    404          {
    405            /* Check the parameters */
    406             assert(IS_TIM_ALL_PERIPH(TIMx));
    407          
    408            /* Set the Counter Register value */
    409            TIMx->CNT = Counter;
    410          }
    411          
    412          /**
    413            * @brief  Sets the TIMx Autoreload Register value
    414            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    415            * @param  Autoreload: specifies the Autoreload register new value.
    416            * @retval None
    417            */
    418          void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
    419          {
    420            /* Check the parameters */
    421            assert(IS_TIM_ALL_PERIPH(TIMx));
    422            
    423            /* Set the Autoreload Register value */
    424            TIMx->ARR = Autoreload;
    425          }
    426          
    427          /**
    428            * @brief  Gets the TIMx Counter value.
    429            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    430            * @retval Counter Register value
    431            */
    432          uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
    433          {
    434            /* Check the parameters */
    435            assert(IS_TIM_ALL_PERIPH(TIMx));
    436          
    437            /* Get the Counter Register value */
    438            return TIMx->CNT;
    439          }
    440          
    441          /**
    442            * @brief  Gets the TIMx Prescaler value.
    443            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    444            * @retval Prescaler Register value.
    445            */
    446          uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
    447          {
    448            /* Check the parameters */
    449            assert(IS_TIM_ALL_PERIPH(TIMx));
    450          
    451            /* Get the Prescaler Register value */
    452            return TIMx->PSC;
    453          }
    454          
    455          /**
    456            * @brief  Enables or Disables the TIMx Update event.
    457            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    458            * @param  NewState: new state of the TIMx UDIS bit
    459            *          This parameter can be: ENABLE or DISABLE.
    460            * @retval None
    461            */
    462          void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
    463          {
    464            /* Check the parameters */
    465            assert(IS_TIM_ALL_PERIPH(TIMx));
    466            assert(IS_FUNCTIONAL_STATE(NewState));
    467          
    468            if (NewState != DISABLE)
    469            {
    470              /* Set the Update Disable Bit */
    471              TIMx->CR1 |= TIM_CR1_UDIS;
    472            }
    473            else
    474            {
    475              /* Reset the Update Disable Bit */
    476              TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
    477            }
    478          }
    479          
    480          /**
    481            * @brief  Configures the TIMx Update Request Interrupt source.
    482            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    483            * @param  TIM_UpdateSource: specifies the Update source.
    484            *          This parameter can be one of the following values:
    485            *            @arg TIM_UpdateSource_Regular: Source of update is the counter
    486            *                 overflow/underflow or the setting of UG bit, or an update
    487            *                 generation through the slave mode controller.
    488            *            @arg TIM_UpdateSource_Global: Source of update is counter overflow/underflow.
    489            * @retval None
    490            */
    491          void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
    492          {
    493            /* Check the parameters */
    494            assert(IS_TIM_ALL_PERIPH(TIMx));
    495            assert(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
    496          
    497            if (TIM_UpdateSource != TIM_UpdateSource_Global)
    498            {
    499              /* Set the URS Bit */
    500              TIMx->CR1 |= TIM_CR1_URS;
    501            }
    502            else
    503            {
    504              /* Reset the URS Bit */
    505              TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
    506            }
    507          }
    508          
    509          /**
    510            * @brief  Enables or disables TIMx peripheral Preload register on ARR.
    511            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    512            * @param  NewState: new state of the TIMx peripheral Preload register
    513            *          This parameter can be: ENABLE or DISABLE.
    514            * @retval None
    515            */
    516          void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
    517          {
    518            /* Check the parameters */
    519            assert(IS_TIM_ALL_PERIPH(TIMx));
    520            assert(IS_FUNCTIONAL_STATE(NewState));
    521          
    522            if (NewState != DISABLE)
    523            {
    524              /* Set the ARR Preload Bit */
    525              TIMx->CR1 |= TIM_CR1_ARPE;
    526            }
    527            else
    528            {
    529              /* Reset the ARR Preload Bit */
    530              TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
    531            }
    532          }
    533          
    534          /**
    535            * @brief  Selects the TIMx's One Pulse Mode.
    536            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
    537            * @param  TIM_OPMode: specifies the OPM Mode to be used.
    538            *          This parameter can be one of the following values:
    539            *            @arg TIM_OPMode_Single
    540            *            @arg TIM_OPMode_Repetitive
    541            * @retval None
    542            */
    543          void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
    544          {
    545            /* Check the parameters */
    546            assert(IS_TIM_ALL_PERIPH(TIMx));
    547            assert(IS_TIM_OPM_MODE(TIM_OPMode));
    548          
    549            /* Reset the OPM Bit */
    550            TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
    551          
    552            /* Configure the OPM Mode */
    553            TIMx->CR1 |= TIM_OPMode;
    554          }
    555          
    556          /**
    557            * @brief  Sets the TIMx Clock Division value.
    558            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
    559            * @param  TIM_CKD: specifies the clock division value.
    560            *          This parameter can be one of the following value:
    561            *            @arg TIM_CKD_DIV1: TDTS = Tck_tim
    562            *            @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
    563            *            @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
    564            * @retval None
    565            */
    566          void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
    567          {
    568            /* Check the parameters */
    569            assert(IS_TIM_LIST1_PERIPH(TIMx));
    570            assert(IS_TIM_CKD_DIV(TIM_CKD));
    571          
    572            /* Reset the CKD Bits */
    573            TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
    574          
    575            /* Set the CKD value */
    576            TIMx->CR1 |= TIM_CKD;
    577          }
    578          
    579          /**
    580            * @brief  Enables or disables the specified TIM peripheral.
    581            * @param  TIMx: where x can be 1 to 14 to select the TIMx peripheral.
    582            * @param  NewState: new state of the TIMx peripheral.
    583            *          This parameter can be: ENABLE or DISABLE.
    584            * @retval None
    585            */
    586          void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
    587          {
    588            /* Check the parameters */
    589            assert(IS_TIM_ALL_PERIPH(TIMx)); 
    590            assert(IS_FUNCTIONAL_STATE(NewState));
    591            
    592            if (NewState != DISABLE)
    593            {
    594              /* Enable the TIM Counter */
    595              TIMx->CR1 |= TIM_CR1_CEN;
    596            }
    597            else
    598            {
    599              /* Disable the TIM Counter */
    600              TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
    601            }
    602          }
    603          /**
    604            * @}
    605            */
    606          
    607          /** @defgroup TIM_Group2 Output Compare management functions
    608           *  @brief    Output Compare management functions 
    609           *
    610          @verbatim   
    611           ===============================================================================
    612                                  Output Compare management functions
    613           ===============================================================================  
    614             
    615                 ===================================================================      
    616                        TIM Driver: how to use it in Output Compare Mode
    617                 =================================================================== 
    618                 To use the Timer in Output Compare mode, the following steps are mandatory:
    619                 
    620                 1. Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function
    621                 
    622                 2. Configure the TIM pins by configuring the corresponding GPIO pins
    623                 
    624                 2. Configure the Time base unit as described in the first part of this driver, 
    625                    if needed, else the Timer will run with the default configuration:
    626                    - Autoreload value = 0xFFFF
    627                    - Prescaler value = 0x0000
    628                    - Counter mode = Up counting
    629                    - Clock Division = TIM_CKD_DIV1
    630                    
    631                 3. Fill the TIM_OCInitStruct with the desired parameters including:
    632                    - The TIM Output Compare mode: TIM_OCMode
    633                    - TIM Output State: TIM_OutputState
    634                    - TIM Pulse value: TIM_Pulse
    635                    - TIM Output Compare Polarity : TIM_OCPolarity
    636                 
    637                 4. Call TIM_OCxInit(TIMx, &TIM_OCInitStruct) to configure the desired channel with the 
    638                    corresponding configuration
    639                 
    640                 5. Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
    641                 
    642                 Note1: All other functions can be used separately to modify, if needed,
    643                        a specific feature of the Timer. 
    644                    
    645                 Note2: In case of PWM mode, this function is mandatory:
    646                        TIM_OCxPreloadConfig(TIMx, TIM_OCPreload_ENABLE); 
    647                        
    648                 Note3: If the corresponding interrupt or DMA request are needed, the user should:
    649                          1. Enable the NVIC (or the DMA) to use the TIM interrupts (or DMA requests). 
    650                          2. Enable the corresponding interrupt (or DMA request) using the function 
    651                             TIM_ITConfig(TIMx, TIM_IT_CCx) (or TIM_DMA_Cmd(TIMx, TIM_DMA_CCx))   
    652          
    653          @endverbatim
    654            * @{
    655            */
    656          
    657          /**
    658            * @brief  Initializes the TIMx Channel1 according to the specified parameters in
    659            *         the TIM_OCInitStruct.
    660            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
    661            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    662            *         the configuration information for the specified TIM peripheral.
    663            * @retval None
    664            */
    665          void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    666          {
    667            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    668             
    669            /* Check the parameters */
    670            assert(IS_TIM_LIST1_PERIPH(TIMx)); 
    671            assert(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    672            assert(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    673            assert(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    674          
    675            /* Disable the Channel 1: Reset the CC1E Bit */
    676            TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
    677            
    678            /* Get the TIMx CCER register value */
    679            tmpccer = TIMx->CCER;
    680            /* Get the TIMx CR2 register value */
    681            tmpcr2 =  TIMx->CR2;
    682            
    683            /* Get the TIMx CCMR1 register value */
    684            tmpccmrx = TIMx->CCMR1;
    685              
    686            /* Reset the Output Compare Mode Bits */
    687            tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
    688            tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
    689            /* Select the Output Compare Mode */
    690            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    691            
    692            /* Reset the Output Polarity level */
    693            tmpccer &= (uint16_t)~TIM_CCER_CC1P;
    694            /* Set the Output Compare Polarity */
    695            tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
    696            
    697            /* Set the Output State */
    698            tmpccer |= TIM_OCInitStruct->TIM_OutputState;
    699              
    700            if((TIMx == TIM1) || (TIMx == TIM8))
    701            {
    702              assert(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    703              assert(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    704              assert(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    705              assert(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    706              
    707              /* Reset the Output N Polarity level */
    708              tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
    709              /* Set the Output N Polarity */
    710              tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
    711              /* Reset the Output N State */
    712              tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
    713              
    714              /* Set the Output N State */
    715              tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
    716              /* Reset the Output Compare and Output Compare N IDLE State */
    717              tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
    718              tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
    719              /* Set the Output Idle state */
    720              tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
    721              /* Set the Output N Idle state */
    722              tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
    723            }
    724            /* Write to TIMx CR2 */
    725            TIMx->CR2 = tmpcr2;
    726            
    727            /* Write to TIMx CCMR1 */
    728            TIMx->CCMR1 = tmpccmrx;
    729            
    730            /* Set the Capture Compare Register value */
    731            TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
    732            
    733            /* Write to TIMx CCER */
    734            TIMx->CCER = tmpccer;
    735          }
    736          
    737          /**
    738            * @brief  Initializes the TIMx Channel2 according to the specified parameters 
    739            *         in the TIM_OCInitStruct.
    740            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
    741            *         peripheral.
    742            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    743            *         the configuration information for the specified TIM peripheral.
    744            * @retval None
    745            */
    746          void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    747          {
    748            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    749             
    750            /* Check the parameters */
    751            assert(IS_TIM_LIST2_PERIPH(TIMx)); 
    752            assert(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    753            assert(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    754            assert(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    755          
    756            /* Disable the Channel 2: Reset the CC2E Bit */
    757            TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
    758            
    759            /* Get the TIMx CCER register value */  
    760            tmpccer = TIMx->CCER;
    761            /* Get the TIMx CR2 register value */
    762            tmpcr2 =  TIMx->CR2;
    763            
    764            /* Get the TIMx CCMR1 register value */
    765            tmpccmrx = TIMx->CCMR1;
    766              
    767            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    768            tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
    769            tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
    770            
    771            /* Select the Output Compare Mode */
    772            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
    773            
    774            /* Reset the Output Polarity level */
    775            tmpccer &= (uint16_t)~TIM_CCER_CC2P;
    776            /* Set the Output Compare Polarity */
    777            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
    778            
    779            /* Set the Output State */
    780            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
    781              
    782            if((TIMx == TIM1) || (TIMx == TIM8))
    783            {
    784              assert(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    785              assert(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    786              assert(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    787              assert(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    788              
    789              /* Reset the Output N Polarity level */
    790              tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
    791              /* Set the Output N Polarity */
    792              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
    793              /* Reset the Output N State */
    794              tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
    795              
    796              /* Set the Output N State */
    797              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
    798              /* Reset the Output Compare and Output Compare N IDLE State */
    799              tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
    800              tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
    801              /* Set the Output Idle state */
    802              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
    803              /* Set the Output N Idle state */
    804              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
    805            }
    806            /* Write to TIMx CR2 */
    807            TIMx->CR2 = tmpcr2;
    808            
    809            /* Write to TIMx CCMR1 */
    810            TIMx->CCMR1 = tmpccmrx;
    811            
    812            /* Set the Capture Compare Register value */
    813            TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
    814            
    815            /* Write to TIMx CCER */
    816            TIMx->CCER = tmpccer;
    817          }
    818          
    819          /**
    820            * @brief  Initializes the TIMx Channel3 according to the specified parameters
    821            *         in the TIM_OCInitStruct.
    822            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    823            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    824            *         the configuration information for the specified TIM peripheral.
    825            * @retval None
    826            */
    827          void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    828          {
    829            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    830             
    831            /* Check the parameters */
    832            assert(IS_TIM_LIST3_PERIPH(TIMx)); 
    833            assert(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    834            assert(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    835            assert(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    836          
    837            /* Disable the Channel 3: Reset the CC2E Bit */
    838            TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
    839            
    840            /* Get the TIMx CCER register value */
    841            tmpccer = TIMx->CCER;
    842            /* Get the TIMx CR2 register value */
    843            tmpcr2 =  TIMx->CR2;
    844            
    845            /* Get the TIMx CCMR2 register value */
    846            tmpccmrx = TIMx->CCMR2;
    847              
    848            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    849            tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
    850            tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
    851            /* Select the Output Compare Mode */
    852            tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    853            
    854            /* Reset the Output Polarity level */
    855            tmpccer &= (uint16_t)~TIM_CCER_CC3P;
    856            /* Set the Output Compare Polarity */
    857            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
    858            
    859            /* Set the Output State */
    860            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
    861              
    862            if((TIMx == TIM1) || (TIMx == TIM8))
    863            {
    864              assert(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
    865              assert(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    866              assert(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    867              assert(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    868              
    869              /* Reset the Output N Polarity level */
    870              tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
    871              /* Set the Output N Polarity */
    872              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
    873              /* Reset the Output N State */
    874              tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
    875              
    876              /* Set the Output N State */
    877              tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
    878              /* Reset the Output Compare and Output Compare N IDLE State */
    879              tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
    880              tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
    881              /* Set the Output Idle state */
    882              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
    883              /* Set the Output N Idle state */
    884              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
    885            }
    886            /* Write to TIMx CR2 */
    887            TIMx->CR2 = tmpcr2;
    888            
    889            /* Write to TIMx CCMR2 */
    890            TIMx->CCMR2 = tmpccmrx;
    891            
    892            /* Set the Capture Compare Register value */
    893            TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
    894            
    895            /* Write to TIMx CCER */
    896            TIMx->CCER = tmpccer;
    897          }
    898          
    899          /**
    900            * @brief  Initializes the TIMx Channel4 according to the specified parameters
    901            *         in the TIM_OCInitStruct.
    902            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
    903            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
    904            *         the configuration information for the specified TIM peripheral.
    905            * @retval None
    906            */
    907          void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    908          {
    909            uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
    910             
    911            /* Check the parameters */
    912            assert(IS_TIM_LIST3_PERIPH(TIMx)); 
    913            assert(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    914            assert(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
    915            assert(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
    916          
    917            /* Disable the Channel 4: Reset the CC4E Bit */
    918            TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
    919            
    920            /* Get the TIMx CCER register value */
    921            tmpccer = TIMx->CCER;
    922            /* Get the TIMx CR2 register value */
    923            tmpcr2 =  TIMx->CR2;
    924            
    925            /* Get the TIMx CCMR2 register value */
    926            tmpccmrx = TIMx->CCMR2;
    927              
    928            /* Reset the Output Compare mode and Capture/Compare selection Bits */
    929            tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
    930            tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
    931            
    932            /* Select the Output Compare Mode */
    933            tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
    934            
    935            /* Reset the Output Polarity level */
    936            tmpccer &= (uint16_t)~TIM_CCER_CC4P;
    937            /* Set the Output Compare Polarity */
    938            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
    939            
    940            /* Set the Output State */
    941            tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
    942            
    943            if((TIMx == TIM1) || (TIMx == TIM8))
    944            {
    945              assert(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    946              /* Reset the Output Compare IDLE State */
    947              tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
    948              /* Set the Output Idle state */
    949              tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
    950            }
    951            /* Write to TIMx CR2 */
    952            TIMx->CR2 = tmpcr2;
    953            
    954            /* Write to TIMx CCMR2 */  
    955            TIMx->CCMR2 = tmpccmrx;
    956              
    957            /* Set the Capture Compare Register value */
    958            TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
    959            
    960            /* Write to TIMx CCER */
    961            TIMx->CCER = tmpccer;
    962          }
    963          
    964          /**
    965            * @brief  Fills each TIM_OCInitStruct member with its default value.
    966            * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure which will
    967            *         be initialized.
    968            * @retval None
    969            */
    970          void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
    971          {
    972            /* Set the default configuration */
    973            TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
    974            TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
    975            TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
    976            TIM_OCInitStruct->TIM_Pulse = 0x00000000;
    977            TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
    978            TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
    979            TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
    980            TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
    981          }
    982          
    983          /**
    984            * @brief  Selects the TIM Output Compare Mode.
    985            * @note   This function disables the selected channel before changing the Output
    986            *         Compare Mode. If needed, user has to enable this channel using
    987            *         TIM_CCxCmd() and TIM_CCxNCmd() functions.
    988            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
    989            * @param  TIM_Channel: specifies the TIM Channel
    990            *          This parameter can be one of the following values:
    991            *            @arg TIM_Channel_1: TIM Channel 1
    992            *            @arg TIM_Channel_2: TIM Channel 2
    993            *            @arg TIM_Channel_3: TIM Channel 3
    994            *            @arg TIM_Channel_4: TIM Channel 4
    995            * @param  TIM_OCMode: specifies the TIM Output Compare Mode.
    996            *           This parameter can be one of the following values:
    997            *            @arg TIM_OCMode_Timing
    998            *            @arg TIM_OCMode_Active
    999            *            @arg TIM_OCMode_Toggle
   1000            *            @arg TIM_OCMode_PWM1
   1001            *            @arg TIM_OCMode_PWM2
   1002            *            @arg TIM_ForcedAction_Active
   1003            *            @arg TIM_ForcedAction_InActive
   1004            * @retval None
   1005            */
   1006          void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
   1007          {
   1008            uint32_t tmp = 0;
   1009            uint16_t tmp1 = 0;
   1010          
   1011            /* Check the parameters */
   1012            assert(IS_TIM_LIST1_PERIPH(TIMx));
   1013            assert(IS_TIM_CHANNEL(TIM_Channel));
   1014            assert(IS_TIM_OCM(TIM_OCMode));
   1015          
   1016            tmp = (uint32_t) TIMx;
   1017            tmp += CCMR_OFFSET;
   1018          
   1019            tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
   1020          
   1021            /* Disable the Channel: Reset the CCxE Bit */
   1022            TIMx->CCER &= (uint16_t) ~tmp1;
   1023          
   1024            if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
   1025            {
   1026              tmp += (TIM_Channel>>1);
   1027          
   1028              /* Reset the OCxM bits in the CCMRx register */
   1029              *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
   1030             
   1031              /* Configure the OCxM bits in the CCMRx register */
   1032              *(__IO uint32_t *) tmp |= TIM_OCMode;
   1033            }
   1034            else
   1035            {
   1036              tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
   1037          
   1038              /* Reset the OCxM bits in the CCMRx register */
   1039              *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
   1040              
   1041              /* Configure the OCxM bits in the CCMRx register */
   1042              *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
   1043            }
   1044          }
   1045          
   1046          /**
   1047            * @brief  Sets the TIMx Capture Compare1 Register value
   1048            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1049            * @param  Compare1: specifies the Capture Compare1 register new value.
   1050            * @retval None
   1051            */
   1052          void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
   1053          {
   1054            /* Check the parameters */
   1055            assert(IS_TIM_LIST1_PERIPH(TIMx));
   1056          
   1057            /* Set the Capture Compare1 Register value */
   1058            TIMx->CCR1 = Compare1;
   1059          }
   1060          
   1061          /**
   1062            * @brief  Sets the TIMx Capture Compare2 Register value
   1063            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1064            *         peripheral.
   1065            * @param  Compare2: specifies the Capture Compare2 register new value.
   1066            * @retval None
   1067            */
   1068          void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
   1069          {
   1070            /* Check the parameters */
   1071            assert(IS_TIM_LIST2_PERIPH(TIMx));
   1072          
   1073            /* Set the Capture Compare2 Register value */
   1074            TIMx->CCR2 = Compare2;
   1075          }
   1076          
   1077          /**
   1078            * @brief  Sets the TIMx Capture Compare3 Register value
   1079            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1080            * @param  Compare3: specifies the Capture Compare3 register new value.
   1081            * @retval None
   1082            */
   1083          void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
   1084          {
   1085            /* Check the parameters */
   1086            assert(IS_TIM_LIST3_PERIPH(TIMx));
   1087          
   1088            /* Set the Capture Compare3 Register value */
   1089            TIMx->CCR3 = Compare3;
   1090          }
   1091          
   1092          /**
   1093            * @brief  Sets the TIMx Capture Compare4 Register value
   1094            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1095            * @param  Compare4: specifies the Capture Compare4 register new value.
   1096            * @retval None
   1097            */
   1098          void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
   1099          {
   1100            /* Check the parameters */
   1101            assert(IS_TIM_LIST3_PERIPH(TIMx));
   1102          
   1103            /* Set the Capture Compare4 Register value */
   1104            TIMx->CCR4 = Compare4;
   1105          }
   1106          
   1107          /**
   1108            * @brief  Forces the TIMx output 1 waveform to active or inactive level.
   1109            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1110            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1111            *          This parameter can be one of the following values:
   1112            *            @arg TIM_ForcedAction_Active: Force active level on OC1REF
   1113            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
   1114            * @retval None
   1115            */
   1116          void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1117          {
   1118            uint16_t tmpccmr1 = 0;
   1119          
   1120            /* Check the parameters */
   1121            assert(IS_TIM_LIST1_PERIPH(TIMx));
   1122            assert(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1123            tmpccmr1 = TIMx->CCMR1;
   1124          
   1125            /* Reset the OC1M Bits */
   1126            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
   1127          
   1128            /* Configure The Forced output Mode */
   1129            tmpccmr1 |= TIM_ForcedAction;
   1130          
   1131            /* Write to TIMx CCMR1 register */
   1132            TIMx->CCMR1 = tmpccmr1;
   1133          }
   1134          
   1135          /**
   1136            * @brief  Forces the TIMx output 2 waveform to active or inactive level.
   1137            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1138            *         peripheral.
   1139            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1140            *          This parameter can be one of the following values:
   1141            *            @arg TIM_ForcedAction_Active: Force active level on OC2REF
   1142            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
   1143            * @retval None
   1144            */
   1145          void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1146          {
   1147            uint16_t tmpccmr1 = 0;
   1148          
   1149            /* Check the parameters */
   1150            assert(IS_TIM_LIST2_PERIPH(TIMx));
   1151            assert(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1152            tmpccmr1 = TIMx->CCMR1;
   1153          
   1154            /* Reset the OC2M Bits */
   1155            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
   1156          
   1157            /* Configure The Forced output Mode */
   1158            tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
   1159          
   1160            /* Write to TIMx CCMR1 register */
   1161            TIMx->CCMR1 = tmpccmr1;
   1162          }
   1163          
   1164          /**
   1165            * @brief  Forces the TIMx output 3 waveform to active or inactive level.
   1166            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1167            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1168            *          This parameter can be one of the following values:
   1169            *            @arg TIM_ForcedAction_Active: Force active level on OC3REF
   1170            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
   1171            * @retval None
   1172            */
   1173          void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1174          {
   1175            uint16_t tmpccmr2 = 0;
   1176          
   1177            /* Check the parameters */
   1178            assert(IS_TIM_LIST3_PERIPH(TIMx));
   1179            assert(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1180          
   1181            tmpccmr2 = TIMx->CCMR2;
   1182          
   1183            /* Reset the OC1M Bits */
   1184            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
   1185          
   1186            /* Configure The Forced output Mode */
   1187            tmpccmr2 |= TIM_ForcedAction;
   1188          
   1189            /* Write to TIMx CCMR2 register */
   1190            TIMx->CCMR2 = tmpccmr2;
   1191          }
   1192          
   1193          /**
   1194            * @brief  Forces the TIMx output 4 waveform to active or inactive level.
   1195            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1196            * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
   1197            *          This parameter can be one of the following values:
   1198            *            @arg TIM_ForcedAction_Active: Force active level on OC4REF
   1199            *            @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
   1200            * @retval None
   1201            */
   1202          void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
   1203          {
   1204            uint16_t tmpccmr2 = 0;
   1205          
   1206            /* Check the parameters */
   1207            assert(IS_TIM_LIST3_PERIPH(TIMx));
   1208            assert(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
   1209            tmpccmr2 = TIMx->CCMR2;
   1210          
   1211            /* Reset the OC2M Bits */
   1212            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
   1213          
   1214            /* Configure The Forced output Mode */
   1215            tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
   1216          
   1217            /* Write to TIMx CCMR2 register */
   1218            TIMx->CCMR2 = tmpccmr2;
   1219          }
   1220          
   1221          /**
   1222            * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.
   1223            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1224            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1225            *          This parameter can be one of the following values:
   1226            *            @arg TIM_OCPreload_Enable
   1227            *            @arg TIM_OCPreload_Disable
   1228            * @retval None
   1229            */
   1230          void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1231          {
   1232            uint16_t tmpccmr1 = 0;
   1233          
   1234            /* Check the parameters */
   1235            assert(IS_TIM_LIST1_PERIPH(TIMx));
   1236            assert(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1237          
   1238            tmpccmr1 = TIMx->CCMR1;
   1239          
   1240            /* Reset the OC1PE Bit */
   1241            tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
   1242          
   1243            /* Enable or Disable the Output Compare Preload feature */
   1244            tmpccmr1 |= TIM_OCPreload;
   1245          
   1246            /* Write to TIMx CCMR1 register */
   1247            TIMx->CCMR1 = tmpccmr1;
   1248          }
   1249          
   1250          /**
   1251            * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.
   1252            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1253            *         peripheral.
   1254            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1255            *          This parameter can be one of the following values:
   1256            *            @arg TIM_OCPreload_Enable
   1257            *            @arg TIM_OCPreload_Disable
   1258            * @retval None
   1259            */
   1260          void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1261          {
   1262            uint16_t tmpccmr1 = 0;
   1263          
   1264            /* Check the parameters */
   1265            assert(IS_TIM_LIST2_PERIPH(TIMx));
   1266            assert(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1267          
   1268            tmpccmr1 = TIMx->CCMR1;
   1269          
   1270            /* Reset the OC2PE Bit */
   1271            tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
   1272          
   1273            /* Enable or Disable the Output Compare Preload feature */
   1274            tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
   1275          
   1276            /* Write to TIMx CCMR1 register */
   1277            TIMx->CCMR1 = tmpccmr1;
   1278          }
   1279          
   1280          /**
   1281            * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.
   1282            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1283            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1284            *          This parameter can be one of the following values:
   1285            *            @arg TIM_OCPreload_Enable
   1286            *            @arg TIM_OCPreload_Disable
   1287            * @retval None
   1288            */
   1289          void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1290          {
   1291            uint16_t tmpccmr2 = 0;
   1292          
   1293            /* Check the parameters */
   1294            assert(IS_TIM_LIST3_PERIPH(TIMx));
   1295            assert(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1296          
   1297            tmpccmr2 = TIMx->CCMR2;
   1298          
   1299            /* Reset the OC3PE Bit */
   1300            tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
   1301          
   1302            /* Enable or Disable the Output Compare Preload feature */
   1303            tmpccmr2 |= TIM_OCPreload;
   1304          
   1305            /* Write to TIMx CCMR2 register */
   1306            TIMx->CCMR2 = tmpccmr2;
   1307          }
   1308          
   1309          /**
   1310            * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.
   1311            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1312            * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
   1313            *          This parameter can be one of the following values:
   1314            *            @arg TIM_OCPreload_Enable
   1315            *            @arg TIM_OCPreload_Disable
   1316            * @retval None
   1317            */
   1318          void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
   1319          {
   1320            uint16_t tmpccmr2 = 0;
   1321          
   1322            /* Check the parameters */
   1323            assert(IS_TIM_LIST3_PERIPH(TIMx));
   1324            assert(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1325          
   1326            tmpccmr2 = TIMx->CCMR2;
   1327          
   1328            /* Reset the OC4PE Bit */
   1329            tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
   1330          
   1331            /* Enable or Disable the Output Compare Preload feature */
   1332            tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
   1333          
   1334            /* Write to TIMx CCMR2 register */
   1335            TIMx->CCMR2 = tmpccmr2;
   1336          }
   1337          
   1338          /**
   1339            * @brief  Configures the TIMx Output Compare 1 Fast feature.
   1340            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1341            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1342            *          This parameter can be one of the following values:
   1343            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1344            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1345            * @retval None
   1346            */
   1347          void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1348          {
   1349            uint16_t tmpccmr1 = 0;
   1350          
   1351            /* Check the parameters */
   1352            assert(IS_TIM_LIST1_PERIPH(TIMx));
   1353            assert(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1354          
   1355            /* Get the TIMx CCMR1 register value */
   1356            tmpccmr1 = TIMx->CCMR1;
   1357          
   1358            /* Reset the OC1FE Bit */
   1359            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
   1360          
   1361            /* Enable or Disable the Output Compare Fast Bit */
   1362            tmpccmr1 |= TIM_OCFast;
   1363          
   1364            /* Write to TIMx CCMR1 */
   1365            TIMx->CCMR1 = tmpccmr1;
   1366          }
   1367          
   1368          /**
   1369            * @brief  Configures the TIMx Output Compare 2 Fast feature.
   1370            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1371            *         peripheral.
   1372            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1373            *          This parameter can be one of the following values:
   1374            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1375            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1376            * @retval None
   1377            */
   1378          void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1379          {
   1380            uint16_t tmpccmr1 = 0;
   1381          
   1382            /* Check the parameters */
   1383            assert(IS_TIM_LIST2_PERIPH(TIMx));
   1384            assert(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1385          
   1386            /* Get the TIMx CCMR1 register value */
   1387            tmpccmr1 = TIMx->CCMR1;
   1388          
   1389            /* Reset the OC2FE Bit */
   1390            tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
   1391          
   1392            /* Enable or Disable the Output Compare Fast Bit */
   1393            tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
   1394          
   1395            /* Write to TIMx CCMR1 */
   1396            TIMx->CCMR1 = tmpccmr1;
   1397          }
   1398          
   1399          /**
   1400            * @brief  Configures the TIMx Output Compare 3 Fast feature.
   1401            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1402            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1403            *          This parameter can be one of the following values:
   1404            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1405            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1406            * @retval None
   1407            */
   1408          void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1409          {
   1410            uint16_t tmpccmr2 = 0;
   1411            
   1412            /* Check the parameters */
   1413            assert(IS_TIM_LIST3_PERIPH(TIMx));
   1414            assert(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1415          
   1416            /* Get the TIMx CCMR2 register value */
   1417            tmpccmr2 = TIMx->CCMR2;
   1418          
   1419            /* Reset the OC3FE Bit */
   1420            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
   1421          
   1422            /* Enable or Disable the Output Compare Fast Bit */
   1423            tmpccmr2 |= TIM_OCFast;
   1424          
   1425            /* Write to TIMx CCMR2 */
   1426            TIMx->CCMR2 = tmpccmr2;
   1427          }
   1428          
   1429          /**
   1430            * @brief  Configures the TIMx Output Compare 4 Fast feature.
   1431            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1432            * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1433            *          This parameter can be one of the following values:
   1434            *            @arg TIM_OCFast_Enable: TIM output compare fast enable
   1435            *            @arg TIM_OCFast_Disable: TIM output compare fast disable
   1436            * @retval None
   1437            */
   1438          void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
   1439          {
   1440            uint16_t tmpccmr2 = 0;
   1441          
   1442            /* Check the parameters */
   1443            assert(IS_TIM_LIST3_PERIPH(TIMx));
   1444            assert(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1445          
   1446            /* Get the TIMx CCMR2 register value */
   1447            tmpccmr2 = TIMx->CCMR2;
   1448          
   1449            /* Reset the OC4FE Bit */
   1450            tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
   1451          
   1452            /* Enable or Disable the Output Compare Fast Bit */
   1453            tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
   1454          
   1455            /* Write to TIMx CCMR2 */
   1456            TIMx->CCMR2 = tmpccmr2;
   1457          }
   1458          
   1459          /**
   1460            * @brief  Clears or safeguards the OCREF1 signal on an external event
   1461            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1462            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1463            *          This parameter can be one of the following values:
   1464            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1465            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1466            * @retval None
   1467            */
   1468          void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1469          {
   1470            uint16_t tmpccmr1 = 0;
   1471          
   1472            /* Check the parameters */
   1473            assert(IS_TIM_LIST1_PERIPH(TIMx));
   1474            assert(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1475          
   1476            tmpccmr1 = TIMx->CCMR1;
   1477          
   1478            /* Reset the OC1CE Bit */
   1479            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
   1480          
   1481            /* Enable or Disable the Output Compare Clear Bit */
   1482            tmpccmr1 |= TIM_OCClear;
   1483          
   1484            /* Write to TIMx CCMR1 register */
   1485            TIMx->CCMR1 = tmpccmr1;
   1486          }
   1487          
   1488          /**
   1489            * @brief  Clears or safeguards the OCREF2 signal on an external event
   1490            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1491            *         peripheral.
   1492            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1493            *          This parameter can be one of the following values:
   1494            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1495            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1496            * @retval None
   1497            */
   1498          void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1499          {
   1500            uint16_t tmpccmr1 = 0;
   1501          
   1502            /* Check the parameters */
   1503            assert(IS_TIM_LIST2_PERIPH(TIMx));
   1504            assert(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1505          
   1506            tmpccmr1 = TIMx->CCMR1;
   1507          
   1508            /* Reset the OC2CE Bit */
   1509            tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
   1510          
   1511            /* Enable or Disable the Output Compare Clear Bit */
   1512            tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
   1513          
   1514            /* Write to TIMx CCMR1 register */
   1515            TIMx->CCMR1 = tmpccmr1;
   1516          }
   1517          
   1518          /**
   1519            * @brief  Clears or safeguards the OCREF3 signal on an external event
   1520            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1521            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1522            *          This parameter can be one of the following values:
   1523            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1524            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1525            * @retval None
   1526            */
   1527          void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1528          {
   1529            uint16_t tmpccmr2 = 0;
   1530          
   1531            /* Check the parameters */
   1532            assert(IS_TIM_LIST3_PERIPH(TIMx));
   1533            assert(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1534          
   1535            tmpccmr2 = TIMx->CCMR2;
   1536          
   1537            /* Reset the OC3CE Bit */
   1538            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
   1539          
   1540            /* Enable or Disable the Output Compare Clear Bit */
   1541            tmpccmr2 |= TIM_OCClear;
   1542          
   1543            /* Write to TIMx CCMR2 register */
   1544            TIMx->CCMR2 = tmpccmr2;
   1545          }
   1546          
   1547          /**
   1548            * @brief  Clears or safeguards the OCREF4 signal on an external event
   1549            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1550            * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1551            *          This parameter can be one of the following values:
   1552            *            @arg TIM_OCClear_Enable: TIM Output clear enable
   1553            *            @arg TIM_OCClear_Disable: TIM Output clear disable
   1554            * @retval None
   1555            */
   1556          void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
   1557          {
   1558            uint16_t tmpccmr2 = 0;
   1559          
   1560            /* Check the parameters */
   1561            assert(IS_TIM_LIST3_PERIPH(TIMx));
   1562            assert(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1563          
   1564            tmpccmr2 = TIMx->CCMR2;
   1565          
   1566            /* Reset the OC4CE Bit */
   1567            tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
   1568          
   1569            /* Enable or Disable the Output Compare Clear Bit */
   1570            tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
   1571          
   1572            /* Write to TIMx CCMR2 register */
   1573            TIMx->CCMR2 = tmpccmr2;
   1574          }
   1575          
   1576          /**
   1577            * @brief  Configures the TIMx channel 1 polarity.
   1578            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1579            * @param  TIM_OCPolarity: specifies the OC1 Polarity
   1580            *          This parameter can be one of the following values:
   1581            *            @arg TIM_OCPolarity_High: Output Compare active high
   1582            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1583            * @retval None
   1584            */
   1585          void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1586          {
   1587            uint16_t tmpccer = 0;
   1588          
   1589            /* Check the parameters */
   1590            assert(IS_TIM_LIST1_PERIPH(TIMx));
   1591            assert(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1592          
   1593            tmpccer = TIMx->CCER;
   1594          
   1595            /* Set or Reset the CC1P Bit */
   1596            tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
   1597            tmpccer |= TIM_OCPolarity;
   1598          
   1599            /* Write to TIMx CCER register */
   1600            TIMx->CCER = tmpccer;
   1601          }
   1602          
   1603          /**
   1604            * @brief  Configures the TIMx Channel 1N polarity.
   1605            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1606            * @param  TIM_OCNPolarity: specifies the OC1N Polarity
   1607            *          This parameter can be one of the following values:
   1608            *            @arg TIM_OCNPolarity_High: Output Compare active high
   1609            *            @arg TIM_OCNPolarity_Low: Output Compare active low
   1610            * @retval None
   1611            */
   1612          void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1613          {
   1614            uint16_t tmpccer = 0;
   1615            /* Check the parameters */
   1616            assert(IS_TIM_LIST4_PERIPH(TIMx));
   1617            assert(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1618             
   1619            tmpccer = TIMx->CCER;
   1620          
   1621            /* Set or Reset the CC1NP Bit */
   1622            tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
   1623            tmpccer |= TIM_OCNPolarity;
   1624          
   1625            /* Write to TIMx CCER register */
   1626            TIMx->CCER = tmpccer;
   1627          }
   1628          
   1629          /**
   1630            * @brief  Configures the TIMx channel 2 polarity.
   1631            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   1632            *         peripheral.
   1633            * @param  TIM_OCPolarity: specifies the OC2 Polarity
   1634            *          This parameter can be one of the following values:
   1635            *            @arg TIM_OCPolarity_High: Output Compare active high
   1636            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1637            * @retval None
   1638            */
   1639          void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1640          {
   1641            uint16_t tmpccer = 0;
   1642          
   1643            /* Check the parameters */
   1644            assert(IS_TIM_LIST2_PERIPH(TIMx));
   1645            assert(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1646          
   1647            tmpccer = TIMx->CCER;
   1648          
   1649            /* Set or Reset the CC2P Bit */
   1650            tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
   1651            tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
   1652          
   1653            /* Write to TIMx CCER register */
   1654            TIMx->CCER = tmpccer;
   1655          }
   1656          
   1657          /**
   1658            * @brief  Configures the TIMx Channel 2N polarity.
   1659            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1660            * @param  TIM_OCNPolarity: specifies the OC2N Polarity
   1661            *          This parameter can be one of the following values:
   1662            *            @arg TIM_OCNPolarity_High: Output Compare active high
   1663            *            @arg TIM_OCNPolarity_Low: Output Compare active low
   1664            * @retval None
   1665            */
   1666          void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1667          {
   1668            uint16_t tmpccer = 0;
   1669          
   1670            /* Check the parameters */
   1671            assert(IS_TIM_LIST4_PERIPH(TIMx));
   1672            assert(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1673            
   1674            tmpccer = TIMx->CCER;
   1675          
   1676            /* Set or Reset the CC2NP Bit */
   1677            tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
   1678            tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
   1679          
   1680            /* Write to TIMx CCER register */
   1681            TIMx->CCER = tmpccer;
   1682          }
   1683          
   1684          /**
   1685            * @brief  Configures the TIMx channel 3 polarity.
   1686            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1687            * @param  TIM_OCPolarity: specifies the OC3 Polarity
   1688            *          This parameter can be one of the following values:
   1689            *            @arg TIM_OCPolarity_High: Output Compare active high
   1690            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1691            * @retval None
   1692            */
   1693          void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1694          {
   1695            uint16_t tmpccer = 0;
   1696          
   1697            /* Check the parameters */
   1698            assert(IS_TIM_LIST3_PERIPH(TIMx));
   1699            assert(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1700          
   1701            tmpccer = TIMx->CCER;
   1702          
   1703            /* Set or Reset the CC3P Bit */
   1704            tmpccer &= (uint16_t)~TIM_CCER_CC3P;
   1705            tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
   1706          
   1707            /* Write to TIMx CCER register */
   1708            TIMx->CCER = tmpccer;
   1709          }
   1710          
   1711          /**
   1712            * @brief  Configures the TIMx Channel 3N polarity.
   1713            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1714            * @param  TIM_OCNPolarity: specifies the OC3N Polarity
   1715            *          This parameter can be one of the following values:
   1716            *            @arg TIM_OCNPolarity_High: Output Compare active high
   1717            *            @arg TIM_OCNPolarity_Low: Output Compare active low
   1718            * @retval None
   1719            */
   1720          void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
   1721          {
   1722            uint16_t tmpccer = 0;
   1723           
   1724            /* Check the parameters */
   1725            assert(IS_TIM_LIST4_PERIPH(TIMx));
   1726            assert(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   1727              
   1728            tmpccer = TIMx->CCER;
   1729          
   1730            /* Set or Reset the CC3NP Bit */
   1731            tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
   1732            tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
   1733          
   1734            /* Write to TIMx CCER register */
   1735            TIMx->CCER = tmpccer;
   1736          }
   1737          
   1738          /**
   1739            * @brief  Configures the TIMx channel 4 polarity.
   1740            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   1741            * @param  TIM_OCPolarity: specifies the OC4 Polarity
   1742            *          This parameter can be one of the following values:
   1743            *            @arg TIM_OCPolarity_High: Output Compare active high
   1744            *            @arg TIM_OCPolarity_Low: Output Compare active low
   1745            * @retval None
   1746            */
   1747          void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
   1748          {
   1749            uint16_t tmpccer = 0;
   1750          
   1751            /* Check the parameters */
   1752            assert(IS_TIM_LIST3_PERIPH(TIMx));
   1753            assert(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1754          
   1755            tmpccer = TIMx->CCER;
   1756          
   1757            /* Set or Reset the CC4P Bit */
   1758            tmpccer &= (uint16_t)~TIM_CCER_CC4P;
   1759            tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
   1760          
   1761            /* Write to TIMx CCER register */
   1762            TIMx->CCER = tmpccer;
   1763          }
   1764          
   1765          /**
   1766            * @brief  Enables or disables the TIM Capture Compare Channel x.
   1767            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1768            * @param  TIM_Channel: specifies the TIM Channel
   1769            *          This parameter can be one of the following values:
   1770            *            @arg TIM_Channel_1: TIM Channel 1
   1771            *            @arg TIM_Channel_2: TIM Channel 2
   1772            *            @arg TIM_Channel_3: TIM Channel 3
   1773            *            @arg TIM_Channel_4: TIM Channel 4
   1774            * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
   1775            *          This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
   1776            * @retval None
   1777            */
   1778          void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
   1779          {
   1780            uint16_t tmp = 0;
   1781          
   1782            /* Check the parameters */
   1783            assert(IS_TIM_LIST1_PERIPH(TIMx)); 
   1784            assert(IS_TIM_CHANNEL(TIM_Channel));
   1785            assert(IS_TIM_CCX(TIM_CCx));
   1786          
   1787            tmp = CCER_CCE_SET << TIM_Channel;
   1788          
   1789            /* Reset the CCxE Bit */
   1790            TIMx->CCER &= (uint16_t)~ tmp;
   1791          
   1792            /* Set or reset the CCxE Bit */ 
   1793            TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
   1794          }
   1795          
   1796          /**
   1797            * @brief  Enables or disables the TIM Capture Compare Channel xN.
   1798            * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.
   1799            * @param  TIM_Channel: specifies the TIM Channel
   1800            *          This parameter can be one of the following values:
   1801            *            @arg TIM_Channel_1: TIM Channel 1
   1802            *            @arg TIM_Channel_2: TIM Channel 2
   1803            *            @arg TIM_Channel_3: TIM Channel 3
   1804            * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
   1805            *          This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
   1806            * @retval None
   1807            */
   1808          void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
   1809          {
   1810            uint16_t tmp = 0;
   1811          
   1812            /* Check the parameters */
   1813            assert(IS_TIM_LIST4_PERIPH(TIMx));
   1814            assert(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
   1815            assert(IS_TIM_CCXN(TIM_CCxN));
   1816          
   1817            tmp = CCER_CCNE_SET << TIM_Channel;
   1818          
   1819            /* Reset the CCxNE Bit */
   1820            TIMx->CCER &= (uint16_t) ~tmp;
   1821          
   1822            /* Set or reset the CCxNE Bit */ 
   1823            TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
   1824          }
   1825          /**
   1826            * @}
   1827            */
   1828          
   1829          /** @defgroup TIM_Group3 Input Capture management functions
   1830           *  @brief    Input Capture management functions 
   1831           *
   1832          @verbatim   
   1833           ===============================================================================
   1834                                Input Capture management functions
   1835           ===============================================================================  
   1836             
   1837                 ===================================================================      
   1838                        TIM Driver: how to use it in Input Capture Mode
   1839                 =================================================================== 
   1840                 To use the Timer in Input Capture mode, the following steps are mandatory:
   1841                 
   1842                 1. Enable TIM clock using RCC_APBxPeriphClockCmd(RCC_APBxPeriph_TIMx, ENABLE) function
   1843                 
   1844                 2. Configure the TIM pins by configuring the corresponding GPIO pins
   1845                 
   1846                 2. Configure the Time base unit as described in the first part of this driver,
   1847                    if needed, else the Timer will run with the default configuration:
   1848                    - Autoreload value = 0xFFFF
   1849                    - Prescaler value = 0x0000
   1850                    - Counter mode = Up counting
   1851                    - Clock Division = TIM_CKD_DIV1
   1852                    
   1853                 3. Fill the TIM_ICInitStruct with the desired parameters including:
   1854                    - TIM Channel: TIM_Channel
   1855                    - TIM Input Capture polarity: TIM_ICPolarity
   1856                    - TIM Input Capture selection: TIM_ICSelection
   1857                    - TIM Input Capture Prescaler: TIM_ICPrescaler
   1858                    - TIM Input CApture filter value: TIM_ICFilter
   1859                 
   1860                 4. Call TIM_ICInit(TIMx, &TIM_ICInitStruct) to configure the desired channel with the 
   1861                    corresponding configuration and to measure only frequency or duty cycle of the input signal,
   1862                    or,
   1863                    Call TIM_PWMIConfig(TIMx, &TIM_ICInitStruct) to configure the desired channels with the 
   1864                    corresponding configuration and to measure the frequency and the duty cycle of the input signal
   1865                    
   1866                 5. Enable the NVIC or the DMA to read the measured frequency. 
   1867                    
   1868                 6. Enable the corresponding interrupt (or DMA request) to read the Captured value,
   1869                    using the function TIM_ITConfig(TIMx, TIM_IT_CCx) (or TIM_DMA_Cmd(TIMx, TIM_DMA_CCx)) 
   1870                 
   1871                 7. Call the TIM_Cmd(ENABLE) function to enable the TIM counter.
   1872                 
   1873                 8. Use TIM_GetCapturex(TIMx); to read the captured value.
   1874                 
   1875                 Note1: All other functions can be used separately to modify, if needed,
   1876                        a specific feature of the Timer. 
   1877          
   1878          @endverbatim
   1879            * @{
   1880            */
   1881          
   1882          /**
   1883            * @brief  Initializes the TIM peripheral according to the specified parameters
   1884            *         in the TIM_ICInitStruct.
   1885            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   1886            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
   1887            *         the configuration information for the specified TIM peripheral.
   1888            * @retval None
   1889            */
   1890          void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   1891          {
   1892            /* Check the parameters */
   1893            assert(IS_TIM_LIST1_PERIPH(TIMx));
   1894            assert(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
   1895            assert(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
   1896            assert(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
   1897            assert(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
   1898            
   1899            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   1900            {
   1901              /* TI1 Configuration */
   1902              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1903                         TIM_ICInitStruct->TIM_ICSelection,
   1904                         TIM_ICInitStruct->TIM_ICFilter);
   1905              /* Set the Input Capture Prescaler value */
   1906              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1907            }
   1908            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
   1909            {
   1910              /* TI2 Configuration */
   1911              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1912                         TIM_ICInitStruct->TIM_ICSelection,
   1913                         TIM_ICInitStruct->TIM_ICFilter);
   1914              /* Set the Input Capture Prescaler value */
   1915              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1916            }
   1917            else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
   1918            {
   1919              /* TI3 Configuration */
   1920              TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
   1921                         TIM_ICInitStruct->TIM_ICSelection,
   1922                         TIM_ICInitStruct->TIM_ICFilter);
   1923              /* Set the Input Capture Prescaler value */
   1924              TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1925            }
   1926            else
   1927            {
   1928              /* TI4 Configuration */
   1929              TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
   1930                         TIM_ICInitStruct->TIM_ICSelection,
   1931                         TIM_ICInitStruct->TIM_ICFilter);
   1932              /* Set the Input Capture Prescaler value */
   1933              TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1934            }
   1935          }
   1936          
   1937          /**
   1938            * @brief  Fills each TIM_ICInitStruct member with its default value.
   1939            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure which will
   1940            *         be initialized.
   1941            * @retval None
   1942            */
   1943          void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
   1944          {
   1945            /* Set the default configuration */
   1946            TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
   1947            TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
   1948            TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
   1949            TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
   1950            TIM_ICInitStruct->TIM_ICFilter = 0x00;
   1951          }
   1952          
   1953          /**
   1954            * @brief  Configures the TIM peripheral according to the specified parameters
   1955            *         in the TIM_ICInitStruct to measure an external PWM signal.
   1956            * @param  TIMx: where x can be  1, 2, 3, 4, 5,8, 9 or 12 to select the TIM 
   1957            *         peripheral.
   1958            * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
   1959            *         the configuration information for the specified TIM peripheral.
   1960            * @retval None
   1961            */
   1962          void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   1963          {
   1964            uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
   1965            uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
   1966          
   1967            /* Check the parameters */
   1968            assert(IS_TIM_LIST2_PERIPH(TIMx));
   1969          
   1970            /* Select the Opposite Input Polarity */
   1971            if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
   1972            {
   1973              icoppositepolarity = TIM_ICPolarity_Falling;
   1974            }
   1975            else
   1976            {
   1977              icoppositepolarity = TIM_ICPolarity_Rising;
   1978            }
   1979            /* Select the Opposite Input */
   1980            if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
   1981            {
   1982              icoppositeselection = TIM_ICSelection_IndirectTI;
   1983            }
   1984            else
   1985            {
   1986              icoppositeselection = TIM_ICSelection_DirectTI;
   1987            }
   1988            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   1989            {
   1990              /* TI1 Configuration */
   1991              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   1992                         TIM_ICInitStruct->TIM_ICFilter);
   1993              /* Set the Input Capture Prescaler value */
   1994              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1995              /* TI2 Configuration */
   1996              TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   1997              /* Set the Input Capture Prescaler value */
   1998              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   1999            }
   2000            else
   2001            { 
   2002              /* TI2 Configuration */
   2003              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   2004                         TIM_ICInitStruct->TIM_ICFilter);
   2005              /* Set the Input Capture Prescaler value */
   2006              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2007              /* TI1 Configuration */
   2008              TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
   2009              /* Set the Input Capture Prescaler value */
   2010              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2011            }
   2012          }
   2013          
   2014          /**
   2015            * @brief  Gets the TIMx Input Capture 1 value.
   2016            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   2017            * @retval Capture Compare 1 Register value.
   2018            */
   2019          uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
   2020          {
   2021            /* Check the parameters */
   2022            assert(IS_TIM_LIST1_PERIPH(TIMx));
   2023          
   2024            /* Get the Capture 1 Register value */
   2025            return TIMx->CCR1;
   2026          }
   2027          
   2028          /**
   2029            * @brief  Gets the TIMx Input Capture 2 value.
   2030            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2031            *         peripheral.
   2032            * @retval Capture Compare 2 Register value.
   2033            */
   2034          uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
   2035          {
   2036            /* Check the parameters */
   2037            assert(IS_TIM_LIST2_PERIPH(TIMx));
   2038          
   2039            /* Get the Capture 2 Register value */
   2040            return TIMx->CCR2;
   2041          }
   2042          
   2043          /**
   2044            * @brief  Gets the TIMx Input Capture 3 value.
   2045            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2046            * @retval Capture Compare 3 Register value.
   2047            */
   2048          uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
   2049          {
   2050            /* Check the parameters */
   2051            assert(IS_TIM_LIST3_PERIPH(TIMx)); 
   2052          
   2053            /* Get the Capture 3 Register value */
   2054            return TIMx->CCR3;
   2055          }
   2056          
   2057          /**
   2058            * @brief  Gets the TIMx Input Capture 4 value.
   2059            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2060            * @retval Capture Compare 4 Register value.
   2061            */
   2062          uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
   2063          {
   2064            /* Check the parameters */
   2065            assert(IS_TIM_LIST3_PERIPH(TIMx));
   2066          
   2067            /* Get the Capture 4 Register value */
   2068            return TIMx->CCR4;
   2069          }
   2070          
   2071          /**
   2072            * @brief  Sets the TIMx Input Capture 1 prescaler.
   2073            * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
   2074            * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.
   2075            *          This parameter can be one of the following values:
   2076            *            @arg TIM_ICPSC_DIV1: no prescaler
   2077            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2078            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2079            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2080            * @retval None
   2081            */
   2082          void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2083          {
   2084            /* Check the parameters */
   2085            assert(IS_TIM_LIST1_PERIPH(TIMx));
   2086            assert(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2087          
   2088            /* Reset the IC1PSC Bits */
   2089            TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
   2090          
   2091            /* Set the IC1PSC value */
   2092            TIMx->CCMR1 |= TIM_ICPSC;
   2093          }
   2094          
   2095          /**
   2096            * @brief  Sets the TIMx Input Capture 2 prescaler.
   2097            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2098            *         peripheral.
   2099            * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.
   2100            *          This parameter can be one of the following values:
   2101            *            @arg TIM_ICPSC_DIV1: no prescaler
   2102            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2103            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2104            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2105            * @retval None
   2106            */
   2107          void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2108          {
   2109            /* Check the parameters */
   2110            assert(IS_TIM_LIST2_PERIPH(TIMx));
   2111            assert(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2112          
   2113            /* Reset the IC2PSC Bits */
   2114            TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
   2115          
   2116            /* Set the IC2PSC value */
   2117            TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
   2118          }
   2119          
   2120          /**
   2121            * @brief  Sets the TIMx Input Capture 3 prescaler.
   2122            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2123            * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.
   2124            *          This parameter can be one of the following values:
   2125            *            @arg TIM_ICPSC_DIV1: no prescaler
   2126            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2127            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2128            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2129            * @retval None
   2130            */
   2131          void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2132          {
   2133            /* Check the parameters */
   2134            assert(IS_TIM_LIST3_PERIPH(TIMx));
   2135            assert(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2136          
   2137            /* Reset the IC3PSC Bits */
   2138            TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
   2139          
   2140            /* Set the IC3PSC value */
   2141            TIMx->CCMR2 |= TIM_ICPSC;
   2142          }
   2143          
   2144          /**
   2145            * @brief  Sets the TIMx Input Capture 4 prescaler.
   2146            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2147            * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.
   2148            *          This parameter can be one of the following values:
   2149            *            @arg TIM_ICPSC_DIV1: no prescaler
   2150            *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
   2151            *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
   2152            *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
   2153            * @retval None
   2154            */
   2155          void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
   2156          {  
   2157            /* Check the parameters */
   2158            assert(IS_TIM_LIST3_PERIPH(TIMx));
   2159            assert(IS_TIM_IC_PRESCALER(TIM_ICPSC));
   2160          
   2161            /* Reset the IC4PSC Bits */
   2162            TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
   2163          
   2164            /* Set the IC4PSC value */
   2165            TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
   2166          }
   2167          /**
   2168            * @}
   2169            */
   2170          
   2171          /** @defgroup TIM_Group4 Advanced-control timers (TIM1 and TIM8) specific features
   2172           *  @brief   Advanced-control timers (TIM1 and TIM8) specific features
   2173           *
   2174          @verbatim   
   2175           ===============================================================================
   2176                    Advanced-control timers (TIM1 and TIM8) specific features
   2177           ===============================================================================  
   2178            
   2179                 ===================================================================      
   2180                        TIM Driver: how to use the Break feature
   2181                 =================================================================== 
   2182                 After configuring the Timer channel(s) in the appropriate Output Compare mode: 
   2183                                   
   2184                 1. Fill the TIM_BDTRInitStruct with the desired parameters for the Timer
   2185                    Break Polarity, dead time, Lock level, the OSSI/OSSR State and the 
   2186                    AOE(automatic output enable).
   2187                         
   2188                 2. Call TIM_BDTRConfig(TIMx, &TIM_BDTRInitStruct) to configure the Timer
   2189                    
   2190                 3. Enable the Main Output using TIM_CtrlPWMOutputs(TIM1, ENABLE) 
   2191                    
   2192                 4. Once the break even occurs, the Timer's output signals are put in reset
   2193                    state or in a known state (according to the configuration made in
   2194                    TIM_BDTRConfig() function).
   2195          
   2196          @endverbatim
   2197            * @{
   2198            */
   2199          
   2200          /**
   2201            * @brief  Configures the Break feature, dead time, Lock level, OSSI/OSSR State
   2202            *         and the AOE(automatic output enable).
   2203            * @param  TIMx: where x can be  1 or 8 to select the TIM 
   2204            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
   2205            *         contains the BDTR Register configuration  information for the TIM peripheral.
   2206            * @retval None
   2207            */
   2208          void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
   2209          {
   2210            /* Check the parameters */
   2211            assert(IS_TIM_LIST4_PERIPH(TIMx));
   2212            assert(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
   2213            assert(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
   2214            assert(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
   2215            assert(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
   2216            assert(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
   2217            assert(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
   2218          
   2219            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
   2220               the OSSI State, the dead time value and the Automatic Output Enable Bit */
   2221            TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
   2222                       TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
   2223                       TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
   2224                       TIM_BDTRInitStruct->TIM_AutomaticOutput;
   2225          }
   2226          
   2227          /**
   2228            * @brief  Fills each TIM_BDTRInitStruct member with its default value.
   2229            * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
   2230            *         will be initialized.
   2231            * @retval None
   2232            */
   2233          void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
   2234          {
   2235            /* Set the default configuration */
   2236            TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
   2237            TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
   2238            TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
   2239            TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
   2240            TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
   2241            TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
   2242            TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
   2243          }
   2244          
   2245          /**
   2246            * @brief  Enables or disables the TIM peripheral Main Outputs.
   2247            * @param  TIMx: where x can be 1 or 8 to select the TIMx peripheral.
   2248            * @param  NewState: new state of the TIM peripheral Main Outputs.
   2249            *          This parameter can be: ENABLE or DISABLE.
   2250            * @retval None
   2251            */
   2252          void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
   2253          {
   2254            /* Check the parameters */
   2255            assert(IS_TIM_LIST4_PERIPH(TIMx));
   2256            assert(IS_FUNCTIONAL_STATE(NewState));
   2257          
   2258            if (NewState != DISABLE)
   2259            {
   2260              /* Enable the TIM Main Output */
   2261              TIMx->BDTR |= TIM_BDTR_MOE;
   2262            }
   2263            else
   2264            {
   2265              /* Disable the TIM Main Output */
   2266              TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
   2267            }  
   2268          }
   2269          
   2270          /**
   2271            * @brief  Selects the TIM peripheral Commutation event.
   2272            * @param  TIMx: where x can be  1 or 8 to select the TIMx peripheral
   2273            * @param  NewState: new state of the Commutation event.
   2274            *          This parameter can be: ENABLE or DISABLE.
   2275            * @retval None
   2276            */
   2277          void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
   2278          {
   2279            /* Check the parameters */
   2280            assert(IS_TIM_LIST4_PERIPH(TIMx));
   2281            assert(IS_FUNCTIONAL_STATE(NewState));
   2282          
   2283            if (NewState != DISABLE)
   2284            {
   2285              /* Set the COM Bit */
   2286              TIMx->CR2 |= TIM_CR2_CCUS;
   2287            }
   2288            else
   2289            {
   2290              /* Reset the COM Bit */
   2291              TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
   2292            }
   2293          }
   2294          
   2295          /**
   2296            * @brief  Sets or Resets the TIM peripheral Capture Compare Preload Control bit.
   2297            * @param  TIMx: where x can be  1 or 8 to select the TIMx peripheral
   2298            * @param  NewState: new state of the Capture Compare Preload Control bit
   2299            *          This parameter can be: ENABLE or DISABLE.
   2300            * @retval None
   2301            */
   2302          void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
   2303          { 
   2304            /* Check the parameters */
   2305            assert(IS_TIM_LIST4_PERIPH(TIMx));
   2306            assert(IS_FUNCTIONAL_STATE(NewState));
   2307            if (NewState != DISABLE)
   2308            {
   2309              /* Set the CCPC Bit */
   2310              TIMx->CR2 |= TIM_CR2_CCPC;
   2311            }
   2312            else
   2313            {
   2314              /* Reset the CCPC Bit */
   2315              TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
   2316            }
   2317          }
   2318          /**
   2319            * @}
   2320            */
   2321          
   2322          /** @defgroup TIM_Group5 Interrupts DMA and flags management functions
   2323           *  @brief    Interrupts, DMA and flags management functions 
   2324           *
   2325          @verbatim   
   2326           ===============================================================================
   2327                           Interrupts, DMA and flags management functions
   2328           ===============================================================================  
   2329          
   2330          @endverbatim
   2331            * @{
   2332            */
   2333          
   2334          /**
   2335            * @brief  Enables or disables the specified TIM interrupts.
   2336            * @param  TIMx: where x can be 1 to 14 to select the TIMx peripheral.
   2337            * @param  TIM_IT: specifies the TIM interrupts sources to be enabled or disabled.
   2338            *          This parameter can be any combination of the following values:
   2339            *            @arg TIM_IT_Update: TIM update Interrupt source
   2340            *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2341            *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2342            *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2343            *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2344            *            @arg TIM_IT_COM: TIM Commutation Interrupt source
   2345            *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2346            *            @arg TIM_IT_Break: TIM Break Interrupt source
   2347            *  
   2348            * @note   For TIM6 and TIM7 only the parameter TIM_IT_Update can be used
   2349            * @note   For TIM9 and TIM12 only one of the following parameters can be used: TIM_IT_Update,
   2350            *          TIM_IT_CC1, TIM_IT_CC2 or TIM_IT_Trigger. 
   2351            * @note   For TIM10, TIM11, TIM13 and TIM14 only one of the following parameters can
   2352            *          be used: TIM_IT_Update or TIM_IT_CC1   
   2353            * @note   TIM_IT_COM and TIM_IT_Break can be used only with TIM1 and TIM8 
   2354            *        
   2355            * @param  NewState: new state of the TIM interrupts.
   2356            *          This parameter can be: ENABLE or DISABLE.
   2357            * @retval None
   2358            */
   2359          void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
   2360          {  
   2361            /* Check the parameters */
   2362            assert(IS_TIM_ALL_PERIPH(TIMx));
   2363            assert(IS_TIM_IT(TIM_IT));
   2364            assert(IS_FUNCTIONAL_STATE(NewState));
   2365            
   2366            if (NewState != DISABLE)
   2367            {
   2368              /* Enable the Interrupt sources */
   2369              TIMx->DIER |= TIM_IT;
   2370            }
   2371            else
   2372            {
   2373              /* Disable the Interrupt sources */
   2374              TIMx->DIER &= (uint16_t)~TIM_IT;
   2375            }
   2376          }
   2377          
   2378          /**
   2379            * @brief  Configures the TIMx event to be generate by software.
   2380            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2381            * @param  TIM_EventSource: specifies the event source.
   2382            *          This parameter can be one or more of the following values:	   
   2383            *            @arg TIM_EventSource_Update: Timer update Event source
   2384            *            @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
   2385            *            @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source
   2386            *            @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source
   2387            *            @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source
   2388            *            @arg TIM_EventSource_COM: Timer COM event source  
   2389            *            @arg TIM_EventSource_Trigger: Timer Trigger Event source
   2390            *            @arg TIM_EventSource_Break: Timer Break event source
   2391            * 
   2392            * @note   TIM6 and TIM7 can only generate an update event. 
   2393            * @note   TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.
   2394            *        
   2395            * @retval None
   2396            */
   2397          void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
   2398          { 
   2399            /* Check the parameters */
   2400            assert(IS_TIM_ALL_PERIPH(TIMx));
   2401            assert(IS_TIM_EVENT_SOURCE(TIM_EventSource));
   2402           
   2403            /* Set the event sources */
   2404            TIMx->EGR = TIM_EventSource;
   2405          }
   2406          
   2407          /**
   2408            * @brief  Checks whether the specified TIM flag is set or not.
   2409            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2410            * @param  TIM_FLAG: specifies the flag to check.
   2411            *          This parameter can be one of the following values:
   2412            *            @arg TIM_FLAG_Update: TIM update Flag
   2413            *            @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2414            *            @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2415            *            @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2416            *            @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2417            *            @arg TIM_FLAG_COM: TIM Commutation Flag
   2418            *            @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2419            *            @arg TIM_FLAG_Break: TIM Break Flag
   2420            *            @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 over capture Flag
   2421            *            @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 over capture Flag
   2422            *            @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 over capture Flag
   2423            *            @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 over capture Flag
   2424            *
   2425            * @note   TIM6 and TIM7 can have only one update flag. 
   2426            * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.    
   2427            *
   2428            * @retval The new state of TIM_FLAG (SET or RESET).
   2429            */
   2430          FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   2431          { 
   2432            ITStatus bitstatus = RESET;  
   2433            /* Check the parameters */
   2434            assert(IS_TIM_ALL_PERIPH(TIMx));
   2435            assert(IS_TIM_GET_FLAG(TIM_FLAG));
   2436          
   2437            
   2438            if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
   2439            {
   2440              bitstatus = SET;
   2441            }
   2442            else
   2443            {
   2444              bitstatus = RESET;
   2445            }
   2446            return bitstatus;
   2447          }
   2448          
   2449          /**
   2450            * @brief  Clears the TIMx's pending flags.
   2451            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2452            * @param  TIM_FLAG: specifies the flag bit to clear.
   2453            *          This parameter can be any combination of the following values:
   2454            *            @arg TIM_FLAG_Update: TIM update Flag
   2455            *            @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
   2456            *            @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
   2457            *            @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
   2458            *            @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
   2459            *            @arg TIM_FLAG_COM: TIM Commutation Flag
   2460            *            @arg TIM_FLAG_Trigger: TIM Trigger Flag
   2461            *            @arg TIM_FLAG_Break: TIM Break Flag
   2462            *            @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 over capture Flag
   2463            *            @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 over capture Flag
   2464            *            @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 over capture Flag
   2465            *            @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 over capture Flag
   2466            *
   2467            * @note   TIM6 and TIM7 can have only one update flag. 
   2468            * @note   TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.
   2469            *    
   2470            * @retval None
   2471            */
   2472          void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
   2473          {  
   2474            /* Check the parameters */
   2475            assert(IS_TIM_ALL_PERIPH(TIMx));
   2476             
   2477            /* Clear the flags */
   2478            TIMx->SR = (uint16_t)~TIM_FLAG;
   2479          }
   2480          
   2481          /**
   2482            * @brief  Checks whether the TIM interrupt has occurred or not.
   2483            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2484            * @param  TIM_IT: specifies the TIM interrupt source to check.
   2485            *          This parameter can be one of the following values:
   2486            *            @arg TIM_IT_Update: TIM update Interrupt source
   2487            *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2488            *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2489            *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2490            *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2491            *            @arg TIM_IT_COM: TIM Commutation Interrupt source
   2492            *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2493            *            @arg TIM_IT_Break: TIM Break Interrupt source
   2494            *
   2495            * @note   TIM6 and TIM7 can generate only an update interrupt.
   2496            * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
   2497            *     
   2498            * @retval The new state of the TIM_IT(SET or RESET).
   2499            */
   2500          ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2501          {
   2502            ITStatus bitstatus = RESET;  
   2503            uint16_t itstatus = 0x0, itenable = 0x0;
   2504            /* Check the parameters */
   2505            assert(IS_TIM_ALL_PERIPH(TIMx));
   2506            assert(IS_TIM_GET_IT(TIM_IT));
   2507             
   2508            itstatus = TIMx->SR & TIM_IT;
   2509            
   2510            itenable = TIMx->DIER & TIM_IT;
   2511            if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
   2512            {
   2513              bitstatus = SET;
   2514            }
   2515            else
   2516            {
   2517              bitstatus = RESET;
   2518            }
   2519            return bitstatus;
   2520          }
   2521          
   2522          /**
   2523            * @brief  Clears the TIMx's interrupt pending bits.
   2524            * @param  TIMx: where x can be 1 to 14 to select the TIM peripheral.
   2525            * @param  TIM_IT: specifies the pending bit to clear.
   2526            *          This parameter can be any combination of the following values:
   2527            *            @arg TIM_IT_Update: TIM1 update Interrupt source
   2528            *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
   2529            *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
   2530            *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
   2531            *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
   2532            *            @arg TIM_IT_COM: TIM Commutation Interrupt source
   2533            *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
   2534            *            @arg TIM_IT_Break: TIM Break Interrupt source
   2535            *
   2536            * @note   TIM6 and TIM7 can generate only an update interrupt.
   2537            * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
   2538            *      
   2539            * @retval None
   2540            */
   2541          void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
   2542          {
   2543            /* Check the parameters */
   2544            assert(IS_TIM_ALL_PERIPH(TIMx));
   2545          
   2546            /* Clear the IT pending Bit */
   2547            TIMx->SR = (uint16_t)~TIM_IT;
   2548          }
   2549          
   2550          /**
   2551            * @brief  Configures the TIMx's DMA interface.
   2552            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2553            * @param  TIM_DMABase: DMA Base address.
   2554            *          This parameter can be one of the following values:
   2555            *            @arg TIM_DMABase_CR1  
   2556            *            @arg TIM_DMABase_CR2
   2557            *            @arg TIM_DMABase_SMCR
   2558            *            @arg TIM_DMABase_DIER
   2559            *            @arg TIM1_DMABase_SR
   2560            *            @arg TIM_DMABase_EGR
   2561            *            @arg TIM_DMABase_CCMR1
   2562            *            @arg TIM_DMABase_CCMR2
   2563            *            @arg TIM_DMABase_CCER
   2564            *            @arg TIM_DMABase_CNT   
   2565            *            @arg TIM_DMABase_PSC   
   2566            *            @arg TIM_DMABase_ARR
   2567            *            @arg TIM_DMABase_RCR
   2568            *            @arg TIM_DMABase_CCR1
   2569            *            @arg TIM_DMABase_CCR2
   2570            *            @arg TIM_DMABase_CCR3  
   2571            *            @arg TIM_DMABase_CCR4
   2572            *            @arg TIM_DMABase_BDTR
   2573            *            @arg TIM_DMABase_DCR
   2574            * @param  TIM_DMABurstLength: DMA Burst length. This parameter can be one value
   2575            *         between: TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
   2576            * @retval None
   2577            */
   2578          void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
   2579          {
   2580            /* Check the parameters */
   2581            assert(IS_TIM_LIST3_PERIPH(TIMx));
   2582            assert(IS_TIM_DMA_BASE(TIM_DMABase)); 
   2583            assert(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
   2584          
   2585            /* Set the DMA Base and the DMA Burst Length */
   2586            TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
   2587          }
   2588          
   2589          /**
   2590            * @brief  Enables or disables the TIMx's DMA Requests.
   2591            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the TIM peripheral.
   2592            * @param  TIM_DMASource: specifies the DMA Request sources.
   2593            *          This parameter can be any combination of the following values:
   2594            *            @arg TIM_DMA_Update: TIM update Interrupt source
   2595            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   2596            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   2597            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   2598            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   2599            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   2600            *            @arg TIM_DMA_Trigger: TIM Trigger DMA source
   2601            * @param  NewState: new state of the DMA Request sources.
   2602            *          This parameter can be: ENABLE or DISABLE.
   2603            * @retval None
   2604            */
   2605          void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
   2606          { 
   2607            /* Check the parameters */
   2608            assert(IS_TIM_LIST5_PERIPH(TIMx)); 
   2609            assert(IS_TIM_DMA_SOURCE(TIM_DMASource));
   2610            assert(IS_FUNCTIONAL_STATE(NewState));
   2611            
   2612            if (NewState != DISABLE)
   2613            {
   2614              /* Enable the DMA sources */
   2615              TIMx->DIER |= TIM_DMASource; 
   2616            }
   2617            else
   2618            {
   2619              /* Disable the DMA sources */
   2620              TIMx->DIER &= (uint16_t)~TIM_DMASource;
   2621            }
   2622          }
   2623          
   2624          /**
   2625            * @brief  Selects the TIMx peripheral Capture Compare DMA source.
   2626            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2627            * @param  NewState: new state of the Capture Compare DMA source
   2628            *          This parameter can be: ENABLE or DISABLE.
   2629            * @retval None
   2630            */
   2631          void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
   2632          {
   2633            /* Check the parameters */
   2634            assert(IS_TIM_LIST3_PERIPH(TIMx));
   2635            assert(IS_FUNCTIONAL_STATE(NewState));
   2636          
   2637            if (NewState != DISABLE)
   2638            {
   2639              /* Set the CCDS Bit */
   2640              TIMx->CR2 |= TIM_CR2_CCDS;
   2641            }
   2642            else
   2643            {
   2644              /* Reset the CCDS Bit */
   2645              TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
   2646            }
   2647          }
   2648          /**
   2649            * @}
   2650            */
   2651          
   2652          /** @defgroup TIM_Group6 Clocks management functions
   2653           *  @brief    Clocks management functions
   2654           *
   2655          @verbatim   
   2656           ===============================================================================
   2657                                   Clocks management functions
   2658           ===============================================================================  
   2659          
   2660          @endverbatim
   2661            * @{
   2662            */
   2663          
   2664          /**
   2665            * @brief  Configures the TIMx internal Clock
   2666            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2667            *         peripheral.
   2668            * @retval None
   2669            */
   2670          void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
   2671          {
   2672            /* Check the parameters */
   2673            assert(IS_TIM_LIST2_PERIPH(TIMx));
   2674          
   2675            /* Disable slave mode to clock the prescaler directly with the internal clock */
   2676            TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
   2677          }
   2678          
   2679          /**
   2680            * @brief  Configures the TIMx Internal Trigger as External Clock
   2681            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   2682            *         peripheral.
   2683            * @param  TIM_InputTriggerSource: Trigger source.
   2684            *          This parameter can be one of the following values:
   2685            *            @arg TIM_TS_ITR0: Internal Trigger 0
   2686            *            @arg TIM_TS_ITR1: Internal Trigger 1
   2687            *            @arg TIM_TS_ITR2: Internal Trigger 2
   2688            *            @arg TIM_TS_ITR3: Internal Trigger 3
   2689            * @retval None
   2690            */
   2691          void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   2692          {
   2693            /* Check the parameters */
   2694            assert(IS_TIM_LIST2_PERIPH(TIMx));
   2695            assert(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
   2696          
   2697            /* Select the Internal Trigger */
   2698            TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
   2699          
   2700            /* Select the External clock mode1 */
   2701            TIMx->SMCR |= TIM_SlaveMode_External1;
   2702          }
   2703          
   2704          /**
   2705            * @brief  Configures the TIMx Trigger as External Clock
   2706            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
   2707            *         to select the TIM peripheral.
   2708            * @param  TIM_TIxExternalCLKSource: Trigger source.
   2709            *          This parameter can be one of the following values:
   2710            *            @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
   2711            *            @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
   2712            *            @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
   2713            * @param  TIM_ICPolarity: specifies the TIx Polarity.
   2714            *          This parameter can be one of the following values:
   2715            *            @arg TIM_ICPolarity_Rising
   2716            *            @arg TIM_ICPolarity_Falling
   2717            * @param  ICFilter: specifies the filter value.
   2718            *          This parameter must be a value between 0x0 and 0xF.
   2719            * @retval None
   2720            */
   2721          void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
   2722                                          uint16_t TIM_ICPolarity, uint16_t ICFilter)
   2723          {
   2724            /* Check the parameters */
   2725            assert(IS_TIM_LIST1_PERIPH(TIMx));
   2726            assert(IS_TIM_IC_POLARITY(TIM_ICPolarity));
   2727            assert(IS_TIM_IC_FILTER(ICFilter));
   2728          
   2729            /* Configure the Timer Input Clock Source */
   2730            if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
   2731            {
   2732              TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   2733            }
   2734            else
   2735            {
   2736              TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
   2737            }
   2738            /* Select the Trigger source */
   2739            TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
   2740            /* Select the External clock mode1 */
   2741            TIMx->SMCR |= TIM_SlaveMode_External1;
   2742          }
   2743          
   2744          /**
   2745            * @brief  Configures the External clock Mode1
   2746            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2747            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2748            *          This parameter can be one of the following values:
   2749            *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2750            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2751            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2752            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2753            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2754            *          This parameter can be one of the following values:
   2755            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2756            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2757            * @param  ExtTRGFilter: External Trigger Filter.
   2758            *          This parameter must be a value between 0x00 and 0x0F
   2759            * @retval None
   2760            */
   2761          void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
   2762                                      uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   2763          {
   2764            uint16_t tmpsmcr = 0;
   2765          
   2766            /* Check the parameters */
   2767            assert(IS_TIM_LIST3_PERIPH(TIMx));
   2768            assert(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   2769            assert(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   2770            assert(IS_TIM_EXT_FILTER(ExtTRGFilter));
   2771            /* Configure the ETR Clock source */
   2772            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   2773            
   2774            /* Get the TIMx SMCR register value */
   2775            tmpsmcr = TIMx->SMCR;
   2776          
   2777            /* Reset the SMS Bits */
   2778            tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
   2779          
   2780            /* Select the External clock mode1 */
   2781            tmpsmcr |= TIM_SlaveMode_External1;
   2782          
   2783            /* Select the Trigger selection : ETRF */
   2784            tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
   2785            tmpsmcr |= TIM_TS_ETRF;
   2786          
   2787            /* Write to TIMx SMCR */
   2788            TIMx->SMCR = tmpsmcr;
   2789          }
   2790          
   2791          /**
   2792            * @brief  Configures the External clock Mode2
   2793            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2794            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2795            *          This parameter can be one of the following values:
   2796            *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2797            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2798            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2799            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2800            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2801            *          This parameter can be one of the following values:
   2802            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2803            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2804            * @param  ExtTRGFilter: External Trigger Filter.
   2805            *          This parameter must be a value between 0x00 and 0x0F
   2806            * @retval None
   2807            */
   2808          void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
   2809                                       uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   2810          {
   2811            /* Check the parameters */
   2812            assert(IS_TIM_LIST3_PERIPH(TIMx));
   2813            assert(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   2814            assert(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   2815            assert(IS_TIM_EXT_FILTER(ExtTRGFilter));
   2816          
   2817            /* Configure the ETR Clock source */
   2818            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
   2819          
   2820            /* Enable the External clock mode2 */
   2821            TIMx->SMCR |= TIM_SMCR_ECE;
   2822          }
   2823          /**
   2824            * @}
   2825            */
   2826          
   2827          /** @defgroup TIM_Group7 Synchronization management functions
   2828           *  @brief    Synchronization management functions 
   2829           *
   2830          @verbatim   
   2831           ===============================================================================
   2832                                 Synchronization management functions
   2833           ===============================================================================  
   2834                             
   2835                 ===================================================================      
   2836                        TIM Driver: how to use it in synchronization Mode
   2837                 =================================================================== 
   2838                 Case of two/several Timers
   2839                 **************************
   2840                 1. Configure the Master Timers using the following functions:
   2841                    - void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource); 
   2842                    - void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);  
   2843                 2. Configure the Slave Timers using the following functions: 
   2844                    - void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);  
   2845                    - void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode); 
   2846                    
   2847                 Case of Timers and external trigger(ETR pin)
   2848                 ********************************************       
   2849                 1. Configure the External trigger using this function:
   2850                    - void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
   2851                                         uint16_t ExtTRGFilter);
   2852                 2. Configure the Slave Timers using the following functions: 
   2853                    - void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);  
   2854                    - void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode); 
   2855          
   2856          @endverbatim
   2857            * @{
   2858            */
   2859          
   2860          /**
   2861            * @brief  Selects the Input Trigger source
   2862            * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14  
   2863            *         to select the TIM peripheral.
   2864            * @param  TIM_InputTriggerSource: The Input Trigger source.
   2865            *          This parameter can be one of the following values:
   2866            *            @arg TIM_TS_ITR0: Internal Trigger 0
   2867            *            @arg TIM_TS_ITR1: Internal Trigger 1
   2868            *            @arg TIM_TS_ITR2: Internal Trigger 2
   2869            *            @arg TIM_TS_ITR3: Internal Trigger 3
   2870            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   2871            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   2872            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   2873            *            @arg TIM_TS_ETRF: External Trigger input
   2874            * @retval None
   2875            */
   2876          void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
   2877          {
   2878            uint16_t tmpsmcr = 0;
   2879          
   2880            /* Check the parameters */
   2881            assert(IS_TIM_LIST1_PERIPH(TIMx)); 
   2882            assert(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
   2883          
   2884            /* Get the TIMx SMCR register value */
   2885            tmpsmcr = TIMx->SMCR;
   2886          
   2887            /* Reset the TS Bits */
   2888            tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
   2889          
   2890            /* Set the Input Trigger source */
   2891            tmpsmcr |= TIM_InputTriggerSource;
   2892          
   2893            /* Write to TIMx SMCR */
   2894            TIMx->SMCR = tmpsmcr;
   2895          }
   2896          
   2897          /**
   2898            * @brief  Selects the TIMx Trigger Output Mode.
   2899            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the TIM peripheral.
   2900            *     
   2901            * @param  TIM_TRGOSource: specifies the Trigger Output source.
   2902            *   This parameter can be one of the following values:
   2903            *
   2904            *  - For all TIMx
   2905            *            @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output(TRGO)
   2906            *            @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output(TRGO)
   2907            *            @arg TIM_TRGOSource_Update: The update event is selected as the trigger output(TRGO)
   2908            *
   2909            *  - For all TIMx except TIM6 and TIM7
   2910            *            @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag
   2911            *                                     is to be set, as soon as a capture or compare match occurs(TRGO)
   2912            *            @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output(TRGO)
   2913            *            @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output(TRGO)
   2914            *            @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output(TRGO)
   2915            *            @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output(TRGO)
   2916            *
   2917            * @retval None
   2918            */
   2919          void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
   2920          {
   2921            /* Check the parameters */
   2922            assert(IS_TIM_LIST5_PERIPH(TIMx));
   2923            assert(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   2924          
   2925            /* Reset the MMS Bits */
   2926            TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
   2927            /* Select the TRGO source */
   2928            TIMx->CR2 |=  TIM_TRGOSource;
   2929          }
   2930          
   2931          /**
   2932            * @brief  Selects the TIMx Slave Mode.
   2933            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM peripheral.
   2934            * @param  TIM_SlaveMode: specifies the Timer Slave Mode.
   2935            *          This parameter can be one of the following values:
   2936            *            @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal(TRGI) reinitialize 
   2937            *                                      the counter and triggers an update of the registers
   2938            *            @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high
   2939            *            @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI
   2940            *            @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter
   2941            * @retval None
   2942            */
   2943          void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
   2944          {
   2945            /* Check the parameters */
   2946            assert(IS_TIM_LIST2_PERIPH(TIMx));
   2947            assert(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   2948          
   2949            /* Reset the SMS Bits */
   2950            TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
   2951          
   2952            /* Select the Slave Mode */
   2953            TIMx->SMCR |= TIM_SlaveMode;
   2954          }
   2955          
   2956          /**
   2957            * @brief  Sets or Resets the TIMx Master/Slave Mode.
   2958            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM peripheral.
   2959            * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   2960            *          This parameter can be one of the following values:
   2961            *            @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer
   2962            *                                             and its slaves (through TRGO)
   2963            *            @arg TIM_MasterSlaveMode_Disable: No action
   2964            * @retval None
   2965            */
   2966          void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
   2967          {
   2968            /* Check the parameters */
   2969            assert(IS_TIM_LIST2_PERIPH(TIMx));
   2970            assert(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   2971          
   2972            /* Reset the MSM Bit */
   2973            TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
   2974            
   2975            /* Set or Reset the MSM Bit */
   2976            TIMx->SMCR |= TIM_MasterSlaveMode;
   2977          }
   2978          
   2979          /**
   2980            * @brief  Configures the TIMx External Trigger (ETR).
   2981            * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   2982            * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
   2983            *          This parameter can be one of the following values:
   2984            *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
   2985            *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
   2986            *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
   2987            *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
   2988            * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
   2989            *          This parameter can be one of the following values:
   2990            *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
   2991            *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
   2992            * @param  ExtTRGFilter: External Trigger Filter.
   2993            *          This parameter must be a value between 0x00 and 0x0F
   2994            * @retval None
   2995            */
   2996          void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
   2997                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
   2998          {
   2999            uint16_t tmpsmcr = 0;
   3000          
   3001            /* Check the parameters */
   3002            assert(IS_TIM_LIST3_PERIPH(TIMx));
   3003            assert(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
   3004            assert(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
   3005            assert(IS_TIM_EXT_FILTER(ExtTRGFilter));
   3006          
   3007            tmpsmcr = TIMx->SMCR;
   3008          
   3009            /* Reset the ETR Bits */
   3010            tmpsmcr &= SMCR_ETR_MASK;
   3011          
   3012            /* Set the Prescaler, the Filter value and the Polarity */
   3013            tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
   3014          
   3015            /* Write to TIMx SMCR */
   3016            TIMx->SMCR = tmpsmcr;
   3017          }
   3018          /**
   3019            * @}
   3020            */
   3021          
   3022          /** @defgroup TIM_Group8 Specific interface management functions
   3023           *  @brief    Specific interface management functions 
   3024           *
   3025          @verbatim   
   3026           ===============================================================================
   3027                              Specific interface management functions
   3028           ===============================================================================  
   3029          
   3030          @endverbatim
   3031            * @{
   3032            */
   3033          
   3034          /**
   3035            * @brief  Configures the TIMx Encoder Interface.
   3036            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   3037            *         peripheral.
   3038            * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.
   3039            *          This parameter can be one of the following values:
   3040            *            @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.
   3041            *            @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.
   3042            *            @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending
   3043            *                                       on the level of the other input.
   3044            * @param  TIM_IC1Polarity: specifies the IC1 Polarity
   3045            *          This parameter can be one of the following values:
   3046            *            @arg TIM_ICPolarity_Falling: IC Falling edge.
   3047            *            @arg TIM_ICPolarity_Rising: IC Rising edge.
   3048            * @param  TIM_IC2Polarity: specifies the IC2 Polarity
   3049            *          This parameter can be one of the following values:
   3050            *            @arg TIM_ICPolarity_Falling: IC Falling edge.
   3051            *            @arg TIM_ICPolarity_Rising: IC Rising edge.
   3052            * @retval None
   3053            */
   3054          void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
   3055                                          uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
   3056          {
   3057            uint16_t tmpsmcr = 0;
   3058            uint16_t tmpccmr1 = 0;
   3059            uint16_t tmpccer = 0;
   3060              
   3061            /* Check the parameters */
   3062            assert(IS_TIM_LIST2_PERIPH(TIMx));
   3063            assert(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   3064            assert(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   3065            assert(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   3066          
   3067            /* Get the TIMx SMCR register value */
   3068            tmpsmcr = TIMx->SMCR;
   3069          
   3070            /* Get the TIMx CCMR1 register value */
   3071            tmpccmr1 = TIMx->CCMR1;
   3072          
   3073            /* Get the TIMx CCER register value */
   3074            tmpccer = TIMx->CCER;
   3075          
   3076            /* Set the encoder Mode */
   3077            tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
   3078            tmpsmcr |= TIM_EncoderMode;
   3079          
   3080            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   3081            tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
   3082            tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
   3083          
   3084            /* Set the TI1 and the TI2 Polarities */
   3085            tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
   3086            tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
   3087          
   3088            /* Write to TIMx SMCR */
   3089            TIMx->SMCR = tmpsmcr;
   3090          
   3091            /* Write to TIMx CCMR1 */
   3092            TIMx->CCMR1 = tmpccmr1;
   3093          
   3094            /* Write to TIMx CCER */
   3095            TIMx->CCER = tmpccer;
   3096          }
   3097          
   3098          /**
   3099            * @brief  Enables or disables the TIMx's Hall sensor interface.
   3100            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   3101            *         peripheral.
   3102            * @param  NewState: new state of the TIMx Hall sensor interface.
   3103            *          This parameter can be: ENABLE or DISABLE.
   3104            * @retval None
   3105            */
   3106          void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
   3107          {
   3108            /* Check the parameters */
   3109            assert(IS_TIM_LIST2_PERIPH(TIMx));
   3110            assert(IS_FUNCTIONAL_STATE(NewState));
   3111          
   3112            if (NewState != DISABLE)
   3113            {
   3114              /* Set the TI1S Bit */
   3115              TIMx->CR2 |= TIM_CR2_TI1S;
   3116            }
   3117            else
   3118            {
   3119              /* Reset the TI1S Bit */
   3120              TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
   3121            }
   3122          }
   3123          /**
   3124            * @}
   3125            */
   3126          
   3127          /** @defgroup TIM_Group9 Specific remapping management function
   3128           *  @brief   Specific remapping management function
   3129           *
   3130          @verbatim   
   3131           ===============================================================================
   3132                               Specific remapping management function
   3133           ===============================================================================  
   3134          
   3135          @endverbatim
   3136            * @{
   3137            */
   3138          
   3139          /**
   3140            * @brief  Configures the TIM2, TIM5 and TIM11 Remapping input capabilities.
   3141            * @param  TIMx: where x can be 2, 5 or 11 to select the TIM peripheral.
   3142            * @param  TIM_Remap: specifies the TIM input remapping source.
   3143            *          This parameter can be one of the following values:
   3144            *            @arg TIM2_TIM8_TRGO: TIM2 ITR1 input is connected to TIM8 Trigger output(default)
   3145            *            @arg TIM2_ETH_PTP:   TIM2 ITR1 input is connected to ETH PTP trogger output.
   3146            *            @arg TIM2_USBFS_SOF: TIM2 ITR1 input is connected to USB FS SOF. 
   3147            *            @arg TIM2_USBHS_SOF: TIM2 ITR1 input is connected to USB HS SOF. 
   3148            *            @arg TIM5_GPIO:      TIM5 CH4 input is connected to dedicated Timer pin(default)
   3149            *            @arg TIM5_LSI:       TIM5 CH4 input is connected to LSI clock.
   3150            *            @arg TIM5_LSE:       TIM5 CH4 input is connected to LSE clock.
   3151            *            @arg TIM5_RTC:       TIM5 CH4 input is connected to RTC Output event.
   3152            *            @arg TIM11_GPIO:     TIM11 CH4 input is connected to dedicated Timer pin(default) 
   3153            *            @arg TIM11_HSE:      TIM11 CH4 input is connected to HSE_RTC clock
   3154            *                                 (HSE divided by a programmable prescaler)  
   3155            * @retval None
   3156            */
   3157          void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
   3158          {
   3159           /* Check the parameters */
   3160            assert(IS_TIM_LIST6_PERIPH(TIMx));
   3161            assert(IS_TIM_REMAP(TIM_Remap));
   3162          
   3163            /* Set the Timer remapping configuration */
   3164            TIMx->OR =  TIM_Remap;
   3165          }
   3166          /**
   3167            * @}
   3168            */
   3169          
   3170          /**
   3171            * @brief  Configure the TI1 as Input.
   3172            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13 or 14 
   3173            *         to select the TIM peripheral.
   3174            * @param  TIM_ICPolarity : The Input Polarity.
   3175            *          This parameter can be one of the following values:
   3176            *            @arg TIM_ICPolarity_Rising
   3177            *            @arg TIM_ICPolarity_Falling
   3178            *            @arg TIM_ICPolarity_BothEdge  
   3179            * @param  TIM_ICSelection: specifies the input to be used.
   3180            *          This parameter can be one of the following values:
   3181            *            @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   3182            *            @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   3183            *            @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   3184            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3185            *          This parameter must be a value between 0x00 and 0x0F.
   3186            * @retval None
   3187            */
   3188          static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3189                                 uint16_t TIM_ICFilter)
   3190          {
   3191            uint16_t tmpccmr1 = 0, tmpccer = 0;
   3192          
   3193            /* Disable the Channel 1: Reset the CC1E Bit */
   3194            TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
   3195            tmpccmr1 = TIMx->CCMR1;
   3196            tmpccer = TIMx->CCER;
   3197          
   3198            /* Select the Input and set the filter */
   3199            tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
   3200            tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   3201          
   3202            /* Select the Polarity and set the CC1E Bit */
   3203            tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   3204            tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
   3205          
   3206            /* Write to TIMx CCMR1 and CCER registers */
   3207            TIMx->CCMR1 = tmpccmr1;
   3208            TIMx->CCER = tmpccer;
   3209          }
   3210          
   3211          /**
   3212            * @brief  Configure the TI2 as Input.
   3213            * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9 or 12 to select the TIM 
   3214            *         peripheral.
   3215            * @param  TIM_ICPolarity : The Input Polarity.
   3216            *          This parameter can be one of the following values:
   3217            *            @arg TIM_ICPolarity_Rising
   3218            *            @arg TIM_ICPolarity_Falling
   3219            *            @arg TIM_ICPolarity_BothEdge   
   3220            * @param  TIM_ICSelection: specifies the input to be used.
   3221            *          This parameter can be one of the following values:
   3222            *            @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   3223            *            @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   3224            *            @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   3225            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3226            *          This parameter must be a value between 0x00 and 0x0F.
   3227            * @retval None
   3228            */
   3229          static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3230                                 uint16_t TIM_ICFilter)
   3231          {
   3232            uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   3233          
   3234            /* Disable the Channel 2: Reset the CC2E Bit */
   3235            TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
   3236            tmpccmr1 = TIMx->CCMR1;
   3237            tmpccer = TIMx->CCER;
   3238            tmp = (uint16_t)(TIM_ICPolarity << 4);
   3239          
   3240            /* Select the Input and set the filter */
   3241            tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
   3242            tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
   3243            tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
   3244          
   3245            /* Select the Polarity and set the CC2E Bit */
   3246            tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   3247            tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
   3248          
   3249            /* Write to TIMx CCMR1 and CCER registers */
   3250            TIMx->CCMR1 = tmpccmr1 ;
   3251            TIMx->CCER = tmpccer;
   3252          }
   3253          
   3254          /**
   3255            * @brief  Configure the TI3 as Input.
   3256            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   3257            * @param  TIM_ICPolarity : The Input Polarity.
   3258            *          This parameter can be one of the following values:
   3259            *            @arg TIM_ICPolarity_Rising
   3260            *            @arg TIM_ICPolarity_Falling
   3261            *            @arg TIM_ICPolarity_BothEdge         
   3262            * @param  TIM_ICSelection: specifies the input to be used.
   3263            *          This parameter can be one of the following values:
   3264            *            @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   3265            *            @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   3266            *            @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   3267            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3268            *          This parameter must be a value between 0x00 and 0x0F.
   3269            * @retval None
   3270            */
   3271          static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3272                                 uint16_t TIM_ICFilter)
   3273          {
   3274            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   3275          
   3276            /* Disable the Channel 3: Reset the CC3E Bit */
   3277            TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
   3278            tmpccmr2 = TIMx->CCMR2;
   3279            tmpccer = TIMx->CCER;
   3280            tmp = (uint16_t)(TIM_ICPolarity << 8);
   3281          
   3282            /* Select the Input and set the filter */
   3283            tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
   3284            tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
   3285          
   3286            /* Select the Polarity and set the CC3E Bit */
   3287            tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   3288            tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
   3289          
   3290            /* Write to TIMx CCMR2 and CCER registers */
   3291            TIMx->CCMR2 = tmpccmr2;
   3292            TIMx->CCER = tmpccer;
   3293          }
   3294          
   3295          /**
   3296            * @brief  Configure the TI4 as Input.
   3297            * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
   3298            * @param  TIM_ICPolarity : The Input Polarity.
   3299            *          This parameter can be one of the following values:
   3300            *            @arg TIM_ICPolarity_Rising
   3301            *            @arg TIM_ICPolarity_Falling
   3302            *            @arg TIM_ICPolarity_BothEdge     
   3303            * @param  TIM_ICSelection: specifies the input to be used.
   3304            *          This parameter can be one of the following values:
   3305            *            @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   3306            *            @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   3307            *            @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   3308            * @param  TIM_ICFilter: Specifies the Input Capture Filter.
   3309            *          This parameter must be a value between 0x00 and 0x0F.
   3310            * @retval None
   3311            */
   3312          static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
   3313                                 uint16_t TIM_ICFilter)
   3314          {
   3315            uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   3316          
   3317            /* Disable the Channel 4: Reset the CC4E Bit */
   3318            TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
   3319            tmpccmr2 = TIMx->CCMR2;
   3320            tmpccer = TIMx->CCER;
   3321            tmp = (uint16_t)(TIM_ICPolarity << 12);
   3322          
   3323            /* Select the Input and set the filter */
   3324            tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
   3325            tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
   3326            tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
   3327          
   3328            /* Select the Polarity and set the CC4E Bit */
   3329            tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   3330            tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
   3331          
   3332            /* Write to TIMx CCMR2 and CCER registers */
   3333            TIMx->CCMR2 = tmpccmr2;
   3334            TIMx->CCER = tmpccer ;
   3335          }
   3336          
   3337          /**
   3338            * @}
   3339            */
   3340          
   3341          /**
   3342            * @}
   3343            */
   3344          
   3345          /**
   3346            * @}
   3347            */
   3348          
   3349          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     TI1_Config                      16
     TI2_Config                      16
     TI3_Config                      16
     TI4_Config                      16
     TIM_ARRPreloadConfig            16
     TIM_BDTRConfig                  16
     TIM_BDTRStructInit               0
     TIM_CCPreloadControl            16
     TIM_CCxCmd                      24
     TIM_CCxNCmd                     24
     TIM_ClearFlag                   16
     TIM_ClearITPendingBit           16
     TIM_ClearOC1Ref                 16
     TIM_ClearOC2Ref                 16
     TIM_ClearOC3Ref                 16
     TIM_ClearOC4Ref                 16
     TIM_Cmd                         16
     TIM_CounterModeConfig           16
     TIM_CtrlPWMOutputs              16
     TIM_DMACmd                      16
     TIM_DMAConfig                   16
     TIM_DeInit                       8
     TIM_ETRClockMode1Config         24
     TIM_ETRClockMode2Config         24
     TIM_ETRConfig                   24
     TIM_EncoderInterfaceConfig      32
     TIM_ForcedOC1Config             16
     TIM_ForcedOC2Config             16
     TIM_ForcedOC3Config             16
     TIM_ForcedOC4Config             16
     TIM_GenerateEvent               16
     TIM_GetCapture1                  8
     TIM_GetCapture2                  8
     TIM_GetCapture3                  8
     TIM_GetCapture4                  8
     TIM_GetCounter                   8
     TIM_GetFlagStatus               16
     TIM_GetITStatus                 24
     TIM_GetPrescaler                 8
     TIM_ICInit                      16
     TIM_ICStructInit                 0
     TIM_ITConfig                    16
     TIM_ITRxExternalClockConfig     16
     TIM_InternalClockConfig          8
     TIM_OC1FastConfig               16
     TIM_OC1Init                     24
     TIM_OC1NPolarityConfig          16
     TIM_OC1PolarityConfig           16
     TIM_OC1PreloadConfig            16
     TIM_OC2FastConfig               16
     TIM_OC2Init                     24
     TIM_OC2NPolarityConfig          16
     TIM_OC2PolarityConfig           16
     TIM_OC2PreloadConfig            16
     TIM_OC3FastConfig               16
     TIM_OC3Init                     24
     TIM_OC3NPolarityConfig          16
     TIM_OC3PolarityConfig           16
     TIM_OC3PreloadConfig            16
     TIM_OC4FastConfig               16
     TIM_OC4Init                     24
     TIM_OC4PolarityConfig           16
     TIM_OC4PreloadConfig            16
     TIM_OCStructInit                 0
     TIM_PWMIConfig                  24
     TIM_PrescalerConfig             16
     TIM_RemapConfig                 16
     TIM_SelectCCDMA                 16
     TIM_SelectCOM                   16
     TIM_SelectHallSensor            16
     TIM_SelectInputTrigger          16
     TIM_SelectMasterSlaveMode       16
     TIM_SelectOCxM                  24
     TIM_SelectOnePulseMode          16
     TIM_SelectOutputTrigger         16
     TIM_SelectSlaveMode             16
     TIM_SetAutoreload               16
     TIM_SetClockDivision            16
     TIM_SetCompare1                 16
     TIM_SetCompare2                 16
     TIM_SetCompare3                 16
     TIM_SetCompare4                 16
     TIM_SetCounter                  16
     TIM_SetIC1Prescaler             16
     TIM_SetIC2Prescaler             16
     TIM_SetIC3Prescaler             16
     TIM_SetIC4Prescaler             16
     TIM_TIxExternalClockConfig      24
     TIM_TimeBaseInit                16
     TIM_TimeBaseStructInit           0
     TIM_UpdateDisableConfig         16
     TIM_UpdateRequestConfig         16


   Section sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     TIM_DeInit                                      510
     TIM_TimeBaseInit                                356
     TIM_TimeBaseStructInit                           24
     TIM_PrescalerConfig                             176
     TIM_CounterModeConfig                           140
     TIM_SetCounter                                  140
     TIM_SetAutoreload                               114
     TIM_GetCounter                                  112
     TIM_GetPrescaler                                112
     TIM_UpdateDisableConfig                         164
     TIM_UpdateRequestConfig                         164
     TIM_ARRPreloadConfig                            194
     TIM_SelectOnePulseMode                          184
     TIM_SetClockDivision                            184
     TIM_Cmd                                         196
     TIM_OC1Init                                     518
     TIM_OC2Init                                     484
     TIM_OC3Init                                     448
     TIM_OC4Init                                     342
     TIM_OCStructInit                                 34
     TIM_SelectOCxM                                  332
     TIM_SetCompare1                                 124
     TIM_SetCompare2                                  92
     TIM_SetCompare3                                  74
     TIM_SetCompare4                                  74
     TIM_ForcedOC1Config                             170
     TIM_ForcedOC2Config                             132
     TIM_ForcedOC3Config                             106
     TIM_ForcedOC4Config                             108
     TIM_OC1PreloadConfig                            144
     TIM_OC2PreloadConfig                            122
     TIM_OC3PreloadConfig                            122
     TIM_OC4PreloadConfig                            124
     TIM_OC1FastConfig                               168
     TIM_OC2FastConfig                               138
     TIM_OC3FastConfig                               122
     TIM_OC4FastConfig                               124
     TIM_ClearOC1Ref                                 168
     TIM_ClearOC2Ref                                 136
     TIM_ClearOC3Ref                                 122
     TIM_ClearOC4Ref                                 118
     TIM_OC1PolarityConfig                           156
     TIM_OC1NPolarityConfig                           84
     TIM_OC2PolarityConfig                           122
     TIM_OC2NPolarityConfig                           86
     TIM_OC3PolarityConfig                           108
     TIM_OC3NPolarityConfig                           86
     TIM_OC4PolarityConfig                           112
     TIM_CCxCmd                                      214
     TIM_CCxNCmd                                     142
     TIM_ICInit                                      372
     TIM_ICStructInit                                 22
     TIM_PWMIConfig                                  222
     TIM_GetCapture1                                 120
     TIM_GetCapture2                                  88
     TIM_GetCapture3                                  74
     TIM_GetCapture4                                  74
     TIM_SetIC1Prescaler                             180
     TIM_SetIC2Prescaler                             150
     TIM_SetIC3Prescaler                             128
     TIM_SetIC4Prescaler                             122
     TIM_BDTRConfig                                  282
     TIM_BDTRStructInit                               30
     TIM_CtrlPWMOutputs                              100
     TIM_SelectCOM                                    94
     TIM_CCPreloadControl                             96
     TIM_ITConfig                                    214
     TIM_GenerateEvent                               162
     TIM_GetFlagStatus                               262
     TIM_ClearFlag                                   144
     TIM_GetITStatus                                 260
     TIM_ClearITPendingBit                           138
     TIM_DMAConfig                                   376
     TIM_DMACmd                                      156
     TIM_SelectCCDMA                                 118
     TIM_InternalClockConfig                          90
     TIM_ITRxExternalClockConfig                     148
     TIM_TIxExternalClockConfig                      236
     TIM_ETRClockMode1Config                         246
     TIM_ETRClockMode2Config                         214
     TIM_SelectInputTrigger                          206
     TIM_SelectOutputTrigger                         170
     TIM_SelectSlaveMode                             148
     TIM_SelectMasterSlaveMode                       130
     TIM_ETRConfig                                   192
     TIM_EncoderInterfaceConfig                      262
     TIM_SelectHallSensor                            126
     TIM_RemapConfig                                 128
     TI1_Config                                       56
     TI2_Config                                       66
     TI3_Config                                       66
     TI4_Config                                       66
     ??DataTable75                                     4
     ??DataTable75_1                                   4
     ??DataTable75_2                                   4
     ??DataTable75_3                                   4
     ??DataTable75_4                                   4
     ??DataTable75_5                                   4
     ??DataTable75_6                                   4
     ??DataTable75_7                                   4
     ??DataTable75_8                                   4
     ??DataTable75_9                                   4
     ??DataTable75_10                                  4
     ??DataTable75_11                                  4
     ??DataTable75_12                                  4
     ??DataTable75_13                                  4
     ??DataTable77                                     4
     ??DataTable77_1                                   4
     ??DataTable77_2                                   4
     ??DataTable79                                     4
     ??DataTable81                                     4
     ??DataTable81_1                                   4
     ??DataTable82                                     4
     ??DataTable82_1                                   4
     ??DataTable82_2                                   4
     ??DataTable82_3                                   4
     ??DataTable82_4                                   4
     ??DataTable82_5                                   4
     ??DataTable82_6                                   4
     ??DataTable82_7                                   4
     ??DataTable82_8                                   4
     ??DataTable82_9                                   4
     ??DataTable82_10                                  4
     ??DataTable82_11                                  4
     ??DataTable82_12                                  4
     ??DataTable82_13                                  4
     ??DataTable83                                     4
     ??DataTable83_1                                   4
     ??DataTable84                                     4
     ??DataTable85                                     4
     ??DataTable87                                     4
     ??DataTable88                                     4
     ??DataTable88_1                                   4
     ??DataTable88_2                                   4
     ??DataTable88_3                                   4
     ??DataTable88_4                                   4
     ??DataTable88_5                                   4
     ??DataTable89                                     4
     ??DataTable90                                     4
     ??DataTable92                                     4
     ??DataTable93                                     4
     ??DataTable94                                     4
     ??DataTable94_1                                   4
     ??DataTable94_2                                   4
     ??DataTable94_3                                   4
     ??DataTable94_4                                   4
     ??DataTable94_5                                   4
     ??DataTable96                                     4
     ??DataTable96_1                                   4
     ??DataTable96_2                                   4
     ??DataTable96_3                                   4
     ??DataTable96_4                                   4
     ??DataTable96_5                                   4
     ??DataTable97                                     4
     ??DataTable102                                    4
     ??DataTable103                                    4
     ??DataTable104                                    4
     ??DataTable110                                    4
     ??DataTable110_1                                  4
     ??DataTable110_2                                  4
     ??DataTable111                                    4
     ??DataTable111_1                                  4
     ??DataTable111_2                                  4
     ??DataTable111_3                                  4
     ??DataTable111_4                                  4
     ??DataTable112                                    4
     ??DataTable112_1                                  4
     ??DataTable112_2                                  4
     ??DataTable112_3                                  4
     ??DataTable112_4                                  4
     ??DataTable112_5                                  4
     ??DataTable113                                    4
     ??DataTable119                                    4
     ??DataTable122                                    4
     ??DataTable122_1                                  4
     ??DataTable122_2                                  4
     ??DataTable123                                    4
     ??DataTable125                                    4
     ??DataTable126                                    4
     ??DataTable126_1                                  4
     ??DataTable126_2                                  4
     ??DataTable127                                    4
     ??DataTable127_1                                  4
     ??DataTable127_2                                  4
     ??DataTable127_3                                  4
     ??DataTable127_4                                  4
     ??DataTable128                                    4
     ??DataTable129                                    4
     ??DataTable129_1                                  4
     ??DataTable129_2                                  4
     ??DataTable129_3                                  4
     ??DataTable129_4                                  4
     ??DataTable129_5                                  4
     ??DataTable129_6                                  4
     ??DataTable129_7                                  4
     ??DataTable129_8                                  4
     ??DataTable130                                    4
     ??DataTable131                                    4
     ??DataTable131_1                                  4
     ??DataTable132                                    4
     ??DataTable133                                    4
     ??DataTable133_1                                  4
     ??DataTable133_2                                  4
     ??DataTable133_3                                  4
     ??DataTable133_4                                  4
     ??DataTable133_5                                  4
     ??DataTable134                                    4
     ??DataTable135                                    4
     ??DataTable136                                    4
     ??DataTable136_1                                  4
     ??DataTable136_2                                  4
     ??DataTable136_3                                  4
     ??DataTable136_4                                  4
     ??DataTable137                                    4
     ??DataTable137_1                                  4
     ??DataTable137_2                                  4
     ??DataTable138                                    4
     ??DataTable138_1                                  4
     ??DataTable139                                    4
     ??DataTable139_1                                  4
     ??DataTable139_2                                  4
     ??DataTable139_3                                  4
     ??DataTable139_4                                  4
     ??DataTable139_5                                  4
     ??DataTable139_6                                  4
     ??DataTable141                                    4
     ??DataTable142                                    4
     ??DataTable145                                    4
     ??DataTable145_1                                  4
     ??DataTable145_2                                  4
     ??DataTable146                                    4
     ??DataTable146_1                                  4
     ??DataTable146_2                                  4
     ??DataTable148                                    4
     ??DataTable148_1                                  4
     ??DataTable148_2                                  4
     ??DataTable149                                    4
     ??DataTable149_1                                  4
     ??DataTable149_2                                  4
     ??DataTable149_3                                  4
     ??DataTable149_4                                  4
     ??DataTable149_5                                  4
     ??DataTable149_6                                  4
     ??DataTable149_7                                  4
     ??DataTable149_8                                  4
     ??DataTable149_9                                  4
     ??DataTable149_10                                 4
     ??DataTable149_11                                 4
     ??DataTable149_12                                 4
     ??DataTable149_13                                 4
     ??DataTable149_14                                 4
     ??DataTable149_15                                 4
     ??DataTable149_16                                 4
     ??DataTable149_17                                 4
     ??DataTable149_18                                 4
     ??DataTable149_19                                 4
     ??DataTable149_20                                 4
     ??DataTable149_21                                 4
     ??DataTable149_22                                 4
     ??DataTable149_23                                 4
     ??DataTable149_24                                 4
     ??DataTable149_25                                 4
     ??DataTable149_26                                 4
     ??DataTable149_27                                 4
     ??DataTable149_28                                 4
     ??DataTable149_29                                 4
     ??DataTable149_30                                 4
     ??DataTable149_31                                 4
     ?<Constant "IS_TIM_ALL_PERIPH(TIMx)">            24
     ?<Constant "D:\\work\\\320\320\261\352\262\372  176
     ?<Constant "IS_TIM_COUNTER_MODE(T...">           64
     ?<Constant "IS_TIM_CKD_DIV(TIM_Ti...">           60
     ?<Constant "IS_TIM_PRESCALER_RELO...">           44
     ?<Constant "IS_TIM_LIST3_PERIPH(T...">           28
     ?<Constant "IS_TIM_COUNTER_MODE(T...">_1         40
     ?<Constant "IS_FUNCTIONAL_STATE(N...">           32
     ?<Constant "IS_TIM_UPDATE_SOURCE(...">           40
     ?<Constant "IS_TIM_OPM_MODE(TIM_O...">           28
     ?<Constant "IS_TIM_LIST1_PERIPH(T...">           28
     ?<Constant "IS_TIM_CKD_DIV(TIM_CKD)">            24
     ?<Constant "IS_TIM_OC_MODE(TIM_OC...">           48
     ?<Constant "IS_TIM_OUTPUT_STATE(T...">           56
     ?<Constant "IS_TIM_OC_POLARITY(TI...">           56
     ?<Constant "IS_TIM_OUTPUTN_STATE(...">           60
     ?<Constant "IS_TIM_OCN_POLARITY(T...">           56
     ?<Constant "IS_TIM_OCNIDLE_STATE(...">           60
     ?<Constant "IS_TIM_OCIDLE_STATE(T...">           56
     ?<Constant "IS_TIM_LIST2_PERIPH(T...">           28
     ?<Constant "IS_TIM_CHANNEL(TIM_Ch...">           28
     ?<Constant "IS_TIM_OCM(TIM_OCMode)">             24
     ?<Constant "IS_TIM_FORCED_ACTION(...">           40
     ?<Constant "IS_TIM_OCPRELOAD_STAT...">           40
     ?<Constant "IS_TIM_OCFAST_STATE(T...">           32
     ?<Constant "IS_TIM_OCCLEAR_STATE(...">           36
     ?<Constant "IS_TIM_OC_POLARITY(TI...">_1         36
     ?<Constant "IS_TIM_LIST4_PERIPH(T...">           28
     ?<Constant "IS_TIM_OCN_POLARITY(T...">_1         40
     ?<Constant "IS_TIM_CCX(TIM_CCx)">                20
     ?<Constant "IS_TIM_COMPLEMENTARY_...">           44
     ?<Constant "IS_TIM_CCXN(TIM_CCxN)">              24
     ?<Constant "IS_TIM_IC_POLARITY(TI...">           56
     ?<Constant "IS_TIM_IC_SELECTION(T...">           56
     ?<Constant "IS_TIM_IC_PRESCALER(T...">           56
     ?<Constant "IS_TIM_IC_FILTER(TIM_...">           52
     ?<Constant "IS_TIM_IC_PRESCALER(T...">_1         32
     ?<Constant "IS_TIM_OSSR_STATE(TIM...">           56
     ?<Constant "IS_TIM_OSSI_STATE(TIM...">           56
     ?<Constant "IS_TIM_LOCK_LEVEL(TIM...">           56
     ?<Constant "IS_TIM_BREAK_STATE(TI...">           52
     ?<Constant "IS_TIM_BREAK_POLARITY...">           64
     ?<Constant "IS_TIM_AUTOMATIC_OUTP...">           72
     ?<Constant "IS_TIM_IT(TIM_IT)">                  20
     ?<Constant "IS_TIM_EVENT_SOURCE(T...">           40
     ?<Constant "IS_TIM_GET_FLAG(TIM_F...">           28
     ?<Constant "IS_TIM_GET_IT(TIM_IT)">              24
     ?<Constant "IS_TIM_DMA_BASE(TIM_D...">           32
     ?<Constant "IS_TIM_DMA_LENGTH(TIM...">           40
     ?<Constant "IS_TIM_LIST5_PERIPH(T...">           28
     ?<Constant "IS_TIM_DMA_SOURCE(TIM...">           36
     ?<Constant "IS_TIM_INTERNAL_TRIGG...">           60
     ?<Constant "IS_TIM_IC_POLARITY(TI...">_1         36
     ?<Constant "IS_TIM_IC_FILTER(ICFi...">           28
     ?<Constant "IS_TIM_EXT_PRESCALER(...">           44
     ?<Constant "IS_TIM_EXT_POLARITY(T...">           40
     ?<Constant "IS_TIM_EXT_FILTER(Ext...">           32
     ?<Constant "IS_TIM_TRIGGER_SELECT...">           52
     ?<Constant "IS_TIM_TRGO_SOURCE(TI...">           36
     ?<Constant "IS_TIM_SLAVE_MODE(TIM...">           36
     ?<Constant "IS_TIM_MSM_STATE(TIM_...">           40
     ?<Constant "IS_TIM_ENCODER_MODE(T...">           40
     ?<Constant "IS_TIM_IC_POLARITY(TI...">_2         36
     ?<Constant "IS_TIM_IC_POLARITY(TI...">_3         36
     ?<Constant "IS_TIM_LIST6_PERIPH(T...">           28
     ?<Constant "IS_TIM_REMAP(TIM_Remap)">            24

 
  2 824 bytes in section .rodata
 15 764 bytes in section .text
 
 15 764 bytes of CODE  memory
  2 824 bytes of CONST memory

Errors: none
Warnings: none
